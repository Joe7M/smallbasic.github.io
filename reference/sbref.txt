SmallBASIC Language reference

░██████╗███╗░░░███╗░█████╗░██╗░░░░░██╗░░░░░██████╗░░█████╗░░██████╗██╗░█████╗░
██╔════╝████╗░████║██╔══██╗██║░░░░░██║░░░░░██╔══██╗██╔══██╗██╔════╝██║██╔══██╗
╚█████╗░██╔████╔██║███████║██║░░░░░██║░░░░░██████╦╝███████║╚█████╗░██║██║░░╚═╝
░╚═══██╗██║╚██╔╝██║██╔══██║██║░░░░░██║░░░░░██╔══██╗██╔══██║░╚═══██╗██║██║░░██╗
██████╔╝██║░╚═╝░██║██║░░██║███████╗███████╗██████╦╝██║░░██║██████╔╝██║╚█████╔╝
╚═════╝░╚═╝░░░░░╚═╝╚═╝░░╚═╝╚══════╝╚══════╝╚═════╝░╚═╝░░╚═╝╚═════╝░╚═╝░╚════╝░

AT BEEP CAT CLS DEFINEKEY FORM INKEY INPUT LINEINPUT LINPUT LOCATE LOGPRINT NOSOUND PEN PLAY PRINT SOUND 
TAB APPEND ARRAY CDBL CINT CREAL DATA DELETE DIM EMPTY ERASE INSERT ISARRAY ISDIR ISFILE ISLINK ISMAP 
ISNUMBER ISSTRING LBOUND LEN READ REDIM RESTORE SEARCH SORT SWAP UBOUND DATE DATEDMY DATEFMT JULIAN TICKS 
TIME TIMEHMS TIMER TIMESTAMP WEEKDAY ACCESS BGETC BLOAD BPUTC BSAVE CHDIR CHMOD CLOSE COPY DIRWALK EOF 
EXIST FILES FREEFILE INPUT INPUT KILL LOCK LOF MKDIR OPEN RENAME RMDIR SEEK SEEK TLOAD TSAVE WRITE ARC 
CHART CIRCLE COLOR DRAW DRAWPOLY IMAGE LINE PAINT PEN PLOT POINT PSET RECT RGB RGBF SHOWPAGE TEXTHEIGHT 
TEXTWIDTH TXTH TXTW VIEW WINDOW XMAX XPOS YMAX YPOS AND AS BAND BG BOR BYREF CALL CASE CATCH CONST DECLARE 
DEF DO ELIF ELSE ELSEIF END END TRY ENDIF EQV EXIT FALSE FI FOR FUNC GOSUB GOTO IF IFF IMP IN LABEL LET 
LIKE LOCAL LSHIFT MDL MOD NAND NEXT NOR NOT ON OR REM REPEAT RETURN RSHIFT SELECT STEP STOP SUB THEN 
THROW TO TRUE TRY UNTIL USE USG USING WEND WHILE XNOR XOR ABS ABSMAX ABSMIN ACOS ACOSH ACOT ACOTH ACSC 
ACSCH ASEC ASECH ASIN ASINH ATAN ATAN2 ATANH ATN CEIL COS COSH COT COTH CSC CSCH DEG DERIV DETERM DIFFEQN 
EXP EXPRSEQ FIX FLOOR FRAC INT INTERSECT INVERSE LINEQN LOG LOG10 M3APPLY M3IDENT M3ROTATE M3SCALE M3TRANS 
MAX MIN POLYAREA POLYCENT POLYEXT POW PTDISTLN PTDISTSEG PTSIGN RAD RND ROOT ROUND SEC SECH SEGCOS SEGLEN 
SEGSIN SEQ SGN SIN SINH SQR STATMEAN STATMEANDEV STATSPREADP STATSPREADS SUM SUMSQ TAN TANH ASC BCS BIN 
CBS CHOP CHR DISCLOSE ENCLOSE FORMAT HEX INSTR JOIN LCASE LEFT LEFTOF LEFTOFLAST LOWER LTRIM MID OCT 
REPLACE RIGHT RIGHTOF RIGHTOFLAST RINSTR RTRIM SINPUT SPACE SPC SPLIT SPRINT SQUEEZE STR STRING TRANSLATE 
TRIM UCASE UPPER VAL CHAIN COMMAND CWD DELAY ENV ENV EXEC EXPORT FRE HOME IMPORT INCLUDE MAXINT NIL OPTION 
PAUSE PI PROGLINE RANDOMIZE RUN SBVER SELF STKDUMP TROFF TRON UNIT 

+========================================================================================+
|                                     1. (Console) AT                                    |
+========================================================================================+

AT x, y

Moves the console cursor to the specified position. x,y are in pixels.

+========================================================================================+
|                                    2. (Console) BEEP                                   |
+========================================================================================+

BEEP

Generates a beep sound.

+========================================================================================+
|                                     3. (Console) CAT                                   |
+========================================================================================+

CAT (x)

Returns a console code. 0 = reset, 1 = bold, -1 bold-off, 2 = underline,
-2 = underline-off, 3 = reverse, -3 = reverse-off.


    ' Note: tested and works with SB 0.12.2 on Linux 64-bit.
    Color 14, 1
    ? Cat(1); "This is Bold text"; Cat(-1)
    ?
    ? Cat(2); "This is Underline text"; Cat(-2)
    ?
    ? Cat(3); "This is Reverse text"; Cat(-3)
    ? 
    ' Cat(0) resets ALL attributes, including colors.
    ? Cat(1); Cat(2); "This is Bold & Underline text"; Cat(0) 
    ?
    ? Cat(2); Cat(3); "This is Underline & Reverse text (with default colors)"; Cat(0)
    Pause


    ' Note: tested and works with SB 0.12.2 on Linux 64-bit.
    ' See also Article "ESCAPE codes" for more codes.
    Const ESCS = Chr(27) + "[" ' Escape sequence prefix.
    Const BG_BLACK = ESCS + "40m" ' background colors
    Const BG_GREEN = ESCS + "42m"
    Const ATTR_OFF = ESCS + "0m"  ' reset ALL console attributes
    Const BOLD_ON  = ESCS + "1m"  ' strong
    Const BOLD_OFF = ESCS + "21m"
    Const LINE_ON  = ESCS + "4m"  ' underline
    Const LINE_OFF = ESCS + "24m"
    Const REVE_ON  = ESCS + "7m"  ' reverse
    Const REVE_OFF = ESCS + "27m"
    Def green(text)   = BG_GREEN + text + BG_BLACK
    Def bold(text)    = BOLD_ON + text + BOLD_OFF
    Def uline(text)   = LINE_ON + text + LINE_OFF
    Def reverse(text) = REVE_ON + text + REVE_OFF

    ? green(bold("This is Green Bold text"))
    ?
    ? uline("This is Underline text")
    ?
    ? reverse("This is Reverse text")
    ? 
    Color 14 ' yellow text color
    ' ATTR_OFF resets ALL attributes, including colors.
    ? green(bold(uline("This is Green, Bold & Underline text"))) + ATTR_OFF
    ?
    ? reverse(uline("This is Underline & Reverse text (with default colors)"))
    Pause


    ' Note:
    ' * You may Include "csi_const.bas" file in another file to make your code more clear.
    '
    ' * "Supported" codes, are those supported by SmallBASIC IDE (not by another Terminal Emulator).
    ' * CSI is "Control Sequence Introducer" (or "Control Sequence Initiator"), i.e. Chr(27) + "[".
    ' * See also: Home -- Articles -- ESCAPE codes
    ' * See also: Home -- Language reference -- Graphics -- COLOR -- color_const.bas
    ' * See  https://en.wikipedia.org/wiki/ANSI_escape_code  for more Escape codes.
    '
    ' demo - add these lines to another BAS file:
    ' ------------------------------------------
    '  Include "csi_const.bas" ' actuall filename must be lower case for Linux.
    '
    '  Color 14: ? "Press a key to start..."
    '  Pause
    '  ? C0_FF + CSI_UNDERLINE + CSI_BG_BLUE + "It's me...!" + CSI_NORMAL
    '  ? "It's me again...!" + C0_BEL
    ' ------------------------------------------

    ' csi_const.bas constants:
    Const CSI = Chr(27) + "[" ' Control Sequence Introducer
    ' Reset all terminal attributes to their defaults:
    Const CSI_NORMAL = CSI + "0m"
    ' Supported foreground color values for characters (30m-37m):
    Const CSI_BLACK   = CSI + "30m"
    Const CSI_RED     = CSI + "31m"
    Const CSI_GREEN   = CSI + "32m"
    Const CSI_YELLOW  = CSI + "33m"
    Const CSI_BLUE    = CSI + "34m"
    Const CSI_MAGENTA = CSI + "35m"
    Const CSI_CYAN    = CSI + "36m"
    Const CSI_WHITE   = CSI + "37m"
    ' Supported background color values for characters (40m-47m):
    Const CSI_BG_BLACK   = CSI + "40m"
    Const CSI_BG_RED     = CSI + "41m"
    Const CSI_BG_GREEN   = CSI + "42m"
    Const CSI_BG_YELLOW  = CSI + "43m"
    Const CSI_BG_BLUE    = CSI + "44m"
    Const CSI_BG_MAGENTA = CSI + "45m"
    Const CSI_BG_CYAN    = CSI + "46m"
    Const CSI_BG_WHITE   = CSI + "47m"
    ' Supported font attributes (these returned by CAT as well):
    Const CSI_BOLD          = CSI + "1m"  ' = Cat(1)
    Const CSI_BOLD_OFF      = CSI + "21m" ' = Cat(-1)
    Const CSI_UNDERLINE     = CSI + "4m"  ' = Cat(2)
    Const CSI_UNDERLINE_OFF = CSI + "24m" ' = Cat(-2)
    Const CSI_REVERSE       = CSI + "7m"  ' = Cat(3)
    Const CSI_REVERSE_OFF   = CSI + "27m" ' = Cat(-3)
    ' Other font attributes:
    Const CSI_ITALIC        = CSI + "3m"
    Const CSI_ITALIC_OFF    = CSI + "23m"
    Const CSI_BLINK         = CSI + "5m"
    Const CSI_BLINK_OFF     = CSI + "25m"
    ' Supported cursor movment:
    Const CSI_EL  = CSI + "K"    ' EL - Erase in Line (clear to end of line).
    ' Supported C0 Control Codes (See https://en.wikipedia.org/wiki/C0_and_C1_control_codes):
    Const C0_BEL = Chr(7)         ' BEL - bell (beep) (-C- \\a)
    Const C0_HT  = Chr(9)         ' HT  - Horizontal Tabulation (tab) (-C- \\t)
    Const C0_LF  = Chr(10)        ' LF  - Line Feed (-C- \\n)
    Const C0_FF  = Chr(12)        ' FF  - Form Feed (clear screen) (-C- \\f)
    Const C0_CR  = Chr(13)        ' CR  - Carriage Return (-C- \\r)
    Const C0_NL  = C0_CR + C0_LF  ' CNL - Cursor Next Line (Windows style for \\n)
    ' Note: New-Line (or line-break) character(s) is different on each system:
    '       Windows and DOS uses a pair of CR and LF characters to terminate lines.
    '       UNIX, Linux, FreeBSD and OS X uses a single LF character only.
    '       Classic Mac operating system uses a single CR character only.
    '       ... And the list goes on (https://en.wikipedia.org/wiki/Newline).

    ' Useful non-standard codes (for Android and FLTK versions):
    Const CSI_ALERTBOX = CSI + " A"  ' Displays an Alert Box
    Const CSI_KEYBOARD = CSI + " K"  ' Displays the Virtual Keyboard
    Const CSI_LABEL    = CSI + " L"  ' Displays a Label at the bottom of the screen

+========================================================================================+
|                                     4. (Console) CLS                                   |
+========================================================================================+

CLS 

Clears the screen.

+========================================================================================+
|                                  5. (Console) DEFINEKEY                                |
+========================================================================================+

DEFINEKEY k,sub

Binds a keystroke to a user defined function,

    sub moveLeft
       if (block.x > 0) then
         moveBlock -1, 0
       fi
    end
    defineKey 0xFF04, moveLeft

To unbind the keystroke definition pass 0 as the sub argument, for
example:

    DEFINEKEY 0xFF04, 0


Example 1:

    ' DEFINEKEY demo.bas  SmallBASIC 0.12.2 [B+=MGA] 2016-03-30
    'remember Etch-A-Sketch?
    'definekey key,sub
    'example: 
    definekey 0xFF04, moveleft   'press left arrow
    definekey 0xFF05, moveright  'press right arrow
    definekey 0xFF09, moveup     'press up arror
    definekey 0xFF0A, movedown   'press down arrow
    definekey 99, togglecolor    'press c for color toggle black (erase), blue, red, white
    definekey 115, togglestepper 'press s for stepper 1,5,10,50
    definekey 27, quit           'press esc to quit
    colr=15
    stepper=1
    tx=xmax/2
    ty=ymax/2
    pset tx,ty,0
    while 1
      color 0,0
      locate 0,0:? spc(100)
      color colr,0
      locate 0,0
      if colr=0 then color colr,15
      ?"tx= ";tx;" ty= ";ty;" c= ";colr;" s=";stepper;
      if colr=0 then color colr,0
      lc=(lc+1) mod 2
      if lc then pset step 0,0,14 else pset step 0,0,0
      delay 60
    wend
    sub moveleft
      pset step 0,0
      if tx-stepper>=0 then tx-=stepper:line step -stepper,0 else beep
    end
    sub moveright
      pset step 0,0
      if tx+stepper<=xmax then tx+=stepper:line step stepper,0 else beep
    end
    sub moveup
      pset step 0,0
      if ty-stepper>=0 then ty-=stepper:line step 0,-stepper else beep
    end
    sub movedown
      pset step 0,0
      if ty+stepper<=ymax then ty+=stepper:line step 0,stepper else beep
    end
    sub togglecolor
      select case colr
      case 0 : colr=9
      case 9 : colr=12
      case 12: colr=15
      case 15: colr=0
      end select
    end
    sub togglestepper
      select case stepper
      case 1 : stepper=5
      case 5 : stepper=10
      case 10: stepper=50
      case 50: stepper=1
      end select
    end
    sub quit
      stop
    end


Example 2:

    ' Note:
    ' * You may Include "definekey_const.bas" file in another file to make your code more clear.
    '
    ' * Created using SmallBASIC version 0.12.2 (on Linux Mint 17.3).
    ' * More keys might be included in future/other versions of SmallBASIC.
    ' * Values for DEFINEKEY cannot be used for INKEY.
    ' * I could not verify all keys (especially CTRL & ALT seems not to work).
    ' * Key codes are from "keymap.h": https://sourceforge.net/p/smallbasic/code/HEAD/tree/trunk/smallbasic/src/keymap.h
    '
    ' Demo - add these lines to another BAS file:
    ' ------------------------------------------
    '  Include "definekey_const.bas"
    '
    '  Definekey DK_LEFT, left_arrow
    '
    '  Sub left_arrow: i++: ? i; " ";
    '  End Sub
    '
    '  ? "Press Left-Arrow key, or Ctrl+B to stop...": Pause
    '  While 1: Wend
    ' ------------------------------------------
    ' definekey_const.bas - DEFINEKEY key codes (keymap.h; 30/4/2010)
    ' Note: bind a regular character with 'DEFINEKEY Asc("a"), sub'
    Const IS_PALM_OS = (Left(OSNAME, 1) = "P") ' Else is_UNIX / is_Windows
    ' PalmOS - H/W keys:
    Const DK_PALM_PGUP  = 0xFF01
    Const DK_PALM_PGDN  = 0xFF02
    Const DK_PALM_BTN1  = 0xFF03
    Const DK_PALM_BTN2  = 0xFF04
    Const DK_PALM_BTN3  = 0xFF05
    Const DK_PALM_BTN4  = 0xFF06
    Const DK_PALM_FIND  = 0xFF07
    Const DK_PALM_CALC  = 0xFF08
    Const DK_BREAK      = Iff(IS_PALM_OS, DK_PALM_BTN4, 0x3) ' MemoPad, Ctrl+C
    Const DK_DELETE     = 127 ' (in keymap.h: DELETE = 8,  BACKSPACE = 127)
    Const DK_BACKSPACE  = 8
    Const DK_TAB        = 9
    Const DK_ENTER      = 13  ' 13 is CR (in keymap.h: ENTER = '\\n')
    ' Common with Handhelds (0xFF00 to 0xFF0F):
    Const DK_PGUP       = 0xFF01
    Const DK_PRIOR      = DK_PGUP
    Const DK_PGDN       = 0xFF02
    Const DK_NEXT       = DK_PGDN
    Const DK_LEFT       = 0xFF04
    Const DK_RIGHT      = 0xFF05
    Const DK_UP         = 0xFF09
    Const DK_DN         = 0xFF0A
    Const DK_DOWN       = DK_DN
    ' Common on PCs (0xFF10 to 0xFF1F):
    Const DK_INSERT     = 0xFF10
    Const DK_HOME       = 0xFF11
    Const DK_END        = 0xFF12
    ' Other application keys:
    Const DK_MENU       = 0xFF1F
    ' Function keys (16 codes), e.g. Definekey DK_FUNC(1):
    Def DK_FUNC(x)      = 0xFFF0 + x   ' -- Verified with 1-12 (F1-F12)
    Def DK_SFUNC(x)     = 0xFFE0 + x   ' ( ...is it for F13-F16 ? )
    ' Control keys, e.g. Definekey DK_CTRL(ASC("R")):
    Def DK_CTRL(x)      = x - 64   ' x must be a capital character
    ' Alt keys, e.g. Definekey DK_ALT(ASC("r")):
    Def DK_ALT(x)       = 0xFF20 + (x - Iff(x >= 97, 57, 31))
    ' Keypad:
    Const DK_KP_DIV     = 0xFFDA
    Const DK_KP_MUL     = 0xFFDB
    Const DK_KP_MINUS   = 0xFFDC
    Const DK_KP_PLUS    = 0xFFDD
    Const DK_KP_ENTER   = 0xFFDE
    Const DK_KP_HOME    = 0xFFD7
    Const DK_KP_UP      = 0xFFD8
    Const DK_KP_PGUP    = 0xFFD9
    Const DK_KP_LEFT    = 0xFFD4
    Const DK_KP_CENTER  = 0xFFD5
    Const DK_KP_RIGHT   = 0xFFD6
    Const DK_KP_END     = 0xFFD1
    Const DK_KP_DOWN    = 0xFFD2
    Const DK_KP_PGDN    = 0xFFD3
    Const DK_KP_INS     = 0xFFD0
    Const DK_KP_DEL     = 0xFFDF
    ' Mouse:
    Const DK_MK_PUSH    = 0xFFC0
    Const DK_MK_DRAG    = 0xFFC1
    Const DK_MK_MOVE    = 0xFFC2
    Const DK_MK_RELEASE = 0xFFC3
    Const DK_MK_WHEEL   = 0xFFC4
    Const DK_MK_FIRST   = DK_MK_PUSH
    Const DK_MK_LAST    = DK_MK_WHEEL

+========================================================================================+
|                                    6. (Console) FORM                                   |
+========================================================================================+

FORM(map)

Creates a form object from a MAP variable. This provides access to the
following sub-commands:

  ------------ --------------------------------------------------------------------------------------------------------------
  doEvents()   Process system events for mouse and keyboard handling.
  close()      Closes the active FORM.
  refresh(n)   n=1 Copy the UI state into the FORM input variables. n=0 Update the UI state using the FORM input variables.
  ------------ --------------------------------------------------------------------------------------------------------------

The form MAP may contain the following properties

  -------- ----------------------------------------
  value    The value from the active input field.
  inputs   Array of inputs.
  focus    Index to the focused input.
  -------- ----------------------------------------

Inputs is an array of type MAP, each element may contain the following
properties

  ----------------- -------------------------------------------------------
  x                 X coordinate.
  y                 Y coordinate.
  width             Input width.
  height            Input height.
  value             The internal value associated with the input.
  label             The display label for the input.
  name              The name of the input.
  type              The type of input, see below.
  help              Listbox or single line text input help text.
  backgroundColor   Background color.
  color             Forground color.
  isExit            Whether clicking the input exits the current program.
  isExternal        Whether the link field opens in an external browser.
  resizable         Whether the field can be resized.
  visible           Whether the input field is visible.
  selectedIndex     The selected item in a listbox or choice.
  length            Length of an TEXT input field.
  noFocus           The input cannot receive focus.
  onclick           SUB to invoke when clicked.
  ----------------- -------------------------------------------------------

The type attribute can be one of the following

  --------- ----------------------------------
  button    Push button.
  label     Display label.
  link      Hyperlinked text.
  listbox   Listbox.
  choice    Dropdown listbox.
  text      Single or multi-line text input.
  image     Image button.
  --------- ----------------------------------


Example

    f.handleKeys = 0
    ' create some buttons
    button1.y = 120
    button1.label = "Button1"
    button1.value = "valudofButton1"
    button1.backgroundcolor = rgb(255,0,0)
    button1.onclick = HelloWorld 'this prints on load
    button2.x = -1
    button2.y = 120
    button2.label = "Button2"
    button2.value = "valueofButton2"
    button3.value = "cats"
    button3.x = -1
    button3.y = 120
    button3.background = 223344
    b4.type = "choice"
    b4.value = "cats|dogs|Fish|cats|dogs|Fish|cats|dogs|Fish|cats|dogs|Fish"
    b4.selectedIndex = 2
    b4.x = -1
    b4.y = 120
    b5.type = "list"
    b5.value = "cats|dogs|Fish|cats|dogs|Fish|cats|dogs|Fish|cats|dogs|Fish|end|lol"
    b5.x = -1
    b5.y = 120
    b5.height = 120
    b6.type = "text"
    b6.value = "cats"
    b6.length=30
    b6.x = -1
    b6.y = 120
    b6.width = 50
    b6.noFocus = 0
    ' add buttons to the form
    f.inputs << button1
    f.inputs << button2
    f.inputs << button3
    f.inputs << b4
    f.inputs << b5
    f.inputs << b6
    f.backgroundcolor = "green"
    ' at this stage 'f' is just a plain user defined structure (map)
    ' after calling FORM, 'f' becomes a system form object with three special functions
    ' doEvents, close and refresh (see sokoban.bas for refresh)
    f = form(f)
    ' the string version of the form is JSON  (see https://en.wikipedia.org/wiki/JSON)
    TSAVE "f.frm", f
    while 1
      ' pump the system event queue
      f.doEvents()
      ' process the event
      in$ = inkey
      at 0,0
      if len(in$)>1 then
        flag= asc(left(in$,1))
        keychar =right(in$,1)
      n= asc(keychar)
        if (flag == 1)
          ? "Ctrl    : ";keychar ; "   "
        else if (flag == 2)
          ? "Alt    : "; keychar
        else if (flag == 3)
          ? "Ctrl+Alt: "; keychar ; "   "
        else
          ? "Arrow: "; n ; "   "
        end if
      else
        vkey = asc(in$)
        if (vkey == 8) then
          ? "backspace!"
        else if (vkey == 127) then
          ? "delete !"
        else
          ? " key=           "; in$; " "; vkey
        endif
    endif
    if b6.value <> "cats" then ? b6.value
      if (len(f.value) > 0) then
        print f.value; "                  "
      end if
    wend
    f.close()
    func HelloWorld
    ? "hello world"
    end

+========================================================================================+
|                                    7. (Console) INKEY                                  |
+========================================================================================+

INKEY

Returns the last key-code in keyboard buffer, or an empty string if
there are no keys. Special key-codes like the function-keys are returned
as 2-byte string.

    k=INKEY
    IF LEN(k)
      IF LEN(k)=2
        ? "H/W #"+ASC(RIGHT(k,1))
      ELSE
        ? k; " "; ASC(k)
      FI
    ELSE
      ? "keyboard buffer is empty"
    FI


    ' Key values:
    Const K_BKSP   = Chr(0x08)  ' BackSpace
    Const K_TAB    = Chr(0x09)
    Const K_ENTER  = Chr(0x0D)
    Const K_ESC    = Chr(0x1B)  ' Escape
    Const K_DELETE = Chr(0x7F)
    Const K_PGUP   = K_ESC + Chr(0x01)  ' Page Up
    Const K_PGDN   = K_ESC + Chr(0x02)  ' Page Down
    Const K_LEFT   = K_ESC + Chr(0x04)  ' Arrow Left
    Const K_RIGHT  = K_ESC + Chr(0x05)  ' Arrow Right
    Const K_UP     = K_ESC + Chr(0x09)  ' Arrow Up
    Const K_DOWN   = K_ESC + Chr(0x0A)  ' Arrow Down
    Const K_INSERT = K_ESC + Chr(0x10)
    Const K_HOME   = K_ESC + Chr(0x11)
    Const K_END    = K_ESC + Chr(0x12)

    ' Edit string:
    Def edit_char(txt, pos, char, ins_mode) = Replace(txt, pos, char, ins_mode = 0)
    Def delete_char(txt, pos) = Replace(txt, pos, "", 1)

    ' Initialize three demo fields:
    f_lbl = ["First Name:", "Last Name: ", "Your Hobby:"] ' field label
    f_row = [3, 5, 7]     ' label row
    f_col = [1, 1, 1]     ' label column
    f_len = [10, 10, 20]  ' variable length
    f_var = ["", "", ""]  ' variable value

    ' Index of fields:
    Const MIN_IX = Lbound(f_lbl)
    Const MAX_IX = Ubound(f_lbl)
    ix = MIN_IX   ' Start on first field index
    ins_mode = 1  ' Start in insert character mode

    ' Main demo loop:
    While True
      ' Update variables:
      eol = Len(f_var(ix)) + 1                ' End Of Line
      If pos > eol Or pos < 1 Then pos = eol  ' Adjust cursor pos on new field
      ' Update screen:
      For i = MIN_IX To MAX_IX
        ' Print all fields:
        s  = Cat(0) + f_lbl(i) + " "
        s += Cat(3) + f_var(i) + Spc(f_len(i) - Len(f_var(i))) + " " ' + eol
        Locate f_row(i), f_col(i)
        Print s + Cat(0);
        ' Print the cursor:
        If i = ix Then
          If Not ins_mode Then Color 15
          Locate f_row(i), f_col(i) + Len(f_lbl(i)) + pos
          Print Cat(2) + Mid(f_var(i) + " ", pos, 1); ' (+ " " for eol)
        Fi
      Next i
      ' Update status line:
      s = "  (Esc=Stop)   |   " + Iff(ins_mode, "Insert ", "Replace") + Spc(3)
      s += Format("| 00:", ix) + Iff(pos = eol, "EOL", Format("000", pos)) + Spc(1)
      Locate 0, 0: Print Cat(0) + Cat(3) + s;
      Showpage ' SHOWPAGE makes INKEY works smoother (using SB 0.12.2)
      ' Wait for a key:
      Repeat: key = Inkey
      Until key <> ""
      ' Check key:
      Select Case key
      Case K_ESC:    Stop
      Case K_INSERT: ins_mode = Not ins_mode
      Case K_ENTER, K_TAB: ix++: If ix > MAX_IX Then ix = MIN_IX
      Case K_DOWN:   If ix < MAX_IX Then ix++
      Case K_UP:     If ix > MIN_IX Then ix--
      Case K_PGDN:   ix = MAX_IX
      Case K_PGUP:   ix = MIN_IX
      Case K_HOME:   pos = 1
      Case K_END:    pos = eol
      Case K_LEFT:   If pos > 1   Then pos--
      Case K_RIGHT:  If pos < eol Then pos++
      Case K_DELETE: If pos < eol Then f_var(ix) = delete_char(f_var(ix), pos)
      Case K_BKSP:   If pos > 1   Then pos--: f_var(ix) = delete_char(f_var(ix), pos)
      Case Else
        If Len(key) = 1 And Asc(key) >= 32 Then            ' Regular character?
          ins = ins_mode And (Len(f_var(ix)) < f_len(ix))  ' Insert mode
          rep = (Not ins_mode) And (pos <= f_len(ix))      ' Replace mode
          If ins Or rep Then
            f_var(ix) = edit_char(f_var(ix), pos, key, ins_mode)
            pos++  ' Move cursor to next character
          Fi
        Fi
      End Select
    Wend

I have been a bit stuck with INKEY for some time. I started building a
little TextBox editor over a year ago and got stuck on something with
INKEY and moved on. As I recall INKEY was not returning unique key
numbers but I forget which… posted sometime ago on this issue. Anyway,
this demo is exactly the kind of thing I had in mind! Thank you shian!!!
I wonder if text selecting is also possible, eg [ctrl+]shft+ home | end
? BTW is CAT working for anyone? I was testing it last night and
couldn’t get anything going (Windows 10-64 and SB 0.12.2).


    REM Language:  SmallBASIC 0.12.6 (Linux 32-bit)
    REM Purpose:   Special key values returned by INKEY.
    REM            (Values returned by INKEY cannot be used for DEFINEKEY).
    REM File name: key.bas
    REM Unit name: key
    REM Version:   1.0.0  24/05/2016
    REM Author:    shian

    ' --- Start demo code ------------------------------------
    '
    'Import key
    '
    '? "Press Escape to stop..."
    'Repeat: k = Inkey
    '  Select Case k
    '  Case Key.ENTER    : ? "Key.ENTER"
    '  Case Key.TABK     : ? "Key.TABK"
    '  Case Key.CLICK    : ? "Key.CLICK"
    '  Case Key.FN(1)    : ? "Key.FN(1)"
    '  Case Key.FN(12)   : ? "Key.FN(12)"
    '  Case Key.CTRL("A"): ? "Key.CTRL(a)"
    '  Case Key.ALT("A") : ? "Key.ALT(a)"
    '  Case Key.CTRL(Key.Enter) : ? "Key.CTRL(Key.Enter)"
    '  Case Key.ALT(Key.Enter)  : ? "Key.ALT(Key.Enter)"
    '  Case Key.SHIFT(Key.Enter): ? "Key.SHIFT(Key.Enter)"
    '  End Select
    'Until k = Key.ESC
    '
    ' --- End demo code ------------------------------------

    Unit key

    ' Useful Constants:
    Export BKSP, TABK, ENTER, ESC, BLANK, DEL
    Export PGUP, PGDN, LEFTK, RIGHTK, UP, DOWN 
    Export INS, HOMEK, ENDK, CLICK
    ' Useful Functions:
    Export FN, CTRL, ALT, SHIFT
    Export CTRL_ALT, ALT_SHIFT, CTRL_SHIFT  ' (used by system)
    ' The left character of INKEY (Useful only for special cases):
    Export CTRL_CHR, ALT_CHR, SHIFT_CHR
    Export CTRL_ALT_CHR, ALT_SHIFT_CHR, CTRL_SHIFT_CHR

    Const CTRL_CHR       = Chr(0x01)    ' for Ctrl+Char
    Const ALT_CHR        = Chr(0x02)    ' for Alt+Char
    Const SHIFT_CHR      = Chr(0x03)    ' for Shift+Char
    Const CTRL_ALT_CHR   = Chr(0x04)    ' for Ctrl+Alt+Char   (used by system)
    Const ALT_SHIFT_CHR  = Chr(0x05)    ' for Alt+Shift+Char  (used by system)
    Const CTRL_SHIFT_CHR = Chr(0x06)    ' for Ctrl+Shift+Char (used by system)
    Const BKSP   = Chr(0x08)            ' BackSpace
    Const TABK   = Chr(0x09)            ' Tab key
    Const ENTER  = Chr(0x0D)
    Const ESC    = Chr(0x1B)            ' Escape
    Const BLANK  = Chr(0x20)            ' Space key
    Const DEL    = Chr(0x7F)            ' Delete
    Const PGUP   = ESC + Chr(0x01)      ' Page Up
    Const PGDN   = ESC + Chr(0x02)      ' Page Down
    Const LEFTK  = ESC + Chr(0x04)      ' Arrow Left key
    Const RIGHTK = ESC + Chr(0x05)      ' Arrow Right key
    Const UP     = ESC + Chr(0x09)      ' Arrow Up
    Const DOWN   = ESC + Chr(0x0A)      ' Arrow Down
    Const INS    = ESC + Chr(0x10)      ' Insert
    Const HOMEK  = ESC + Chr(0x11)      ' Home key
    Const ENDK   = ESC + Chr(0x12)      ' End key
    Const CLICK  = ESC + Chr(0xC0)      ' Left Mouse Button Click
    Def FN(n)    = ESC + Chr(0xF0 + n)  ' FN(1) is F1 (up to 12).
    Def CTRL(c)  = CTRL_CHR  + Lcase(c) ' Ctrl+a, Ctrl+Enter, etc
    Def ALT(c)   = ALT_CHR   + Lcase(c) ' Alt+a, Alt+Enter, etc
    Def SHIFT(c) = SHIFT_CHR + c        ' Shift+Enter, Shift+Tab, etc

    ' These are system shortcuts - so it's advisable NOT to use them at all!
    ' (however, it's possible to detect them when not used by the system).
    Def CTRL_ALT(c)   = CTRL_ALT_CHR   + Lcase(c)  ' Ctrl+Alt+a, etc
    Def ALT_SHIFT(c)  = ALT_SHIFT_CHR  + Lcase(c)  ' Alt+Shift+a, etc
    Def CTRL_SHIFT(c) = CTRL_SHIFT_CHR + Lcase(c)  ' Ctrl+Shift+a, etc

    ' ' Use this code to test and print key codes as hexa:
    ' ' --------------------------------------------------
    ' Print "Press Ctrl+B to stop..."
    ' While 1: k = Inkey: l = Len(k)
    '   If l Then
    '     ? "0x"; Right("00" + Hex(Asc(k)), 2);
    '     If l = 2 Then ? Right("00" + Hex(Asc(Mid(k, 2))), 2);
    '     Print
    '   Fi
    ' Wend

When the first character in the two character code is 27, the second
character is a code for the given special key. You would need to inspect
the SB source to work out the equivalent SmallBASIC key constants, but
I’ll have a look at generating a constants.bas file that you can include
in your programs.

As reported by Shian (thanks Shian!), there are a few problems with
INKEY. I’ll fix these in the next update. There is supposed to be a
different first character code for SHIFT/ALT etc states.

Also, INKEY needs to read from the system event queue to get the next
keystroke. It currently does a pause for key, but I think it should
actually block in the call to read the queue, that way when you type a
key there would be no delay. Either way this doesn’t work well for
shooter type games, but there is a better way. Have a look at:

https://github.com/smallbasic/SmallBASIC/blob/master/samples/distro-exam…

This uses the DEFINEKEY command to register keystroke handlers for game
keys. When you hit the game key, the registered FUNC will get called
more or less immediately, somewhere inside the game main looI think this
should work well in the space shooter (which is awesome by the way).

Code for quick lookup of a key code:

http://smallbasic.sourceforge.net/?q=node/1583

+========================================================================================+
|                                    8. (Console) INPUT                                  |
+========================================================================================+

INPUT [prompt,|;] var[, var [, ...]]

Reads from “keyboard” text and stores it in a variable.

+========================================================================================+
|                                  9. (Console) LINEINPUT                                |
+========================================================================================+

LINEINPUT [#fileN] var

Reads a whole text line from file or console.

+========================================================================================+
|                                   10. (Console) LINPUT                                 |
+========================================================================================+

LINPUT [#fileN] var

Reads a whole text line from file or console.

+========================================================================================+
|                                   11. (Console) LOCATE                                 |
+========================================================================================+

LOCATE y, x

Moves the console cursor to the specified position. x,y are in character
cells.


    ' calculate y and x in characters cells:
    Def lines = (Ymax + 1) \\ Txth("x")   ' maximum lines in window
    Def columns = (Xmax + 1) \\ Txtw("x") ' maximum columns in window
    ' center line,column for printing "text" (top,left is 0,0):
    Def center_line = lines \\ 2
    Def center_column(text) = (columns \\ 2) - (Len(text) \\ 2)
    ' attributes for printing text (ESCAPE codes):
    Const ESC = Chr(27)
    Const bold_on  = ESC + "[1m"  ' strong
    Const bold_off = ESC + "[21m"
    Const line_on  = ESC + "[4m"  ' underline
    Const line_off = ESC + "[24m"
    Const reve_on  = ESC + "[7m"  ' reverse
    Const reve_off = ESC + "[27m"
    ' colors for printing text:
    Const WHITE = 7
    Const BLACK = 0
    Const YELLOW = 14
    Const BLUE = 1
    Const HELLO = "* Hello World! *" ' text to print.
    ' loop until user press Esc key:
    While Inkey <> Chr(27)
      ' update screen if user resized the window:
      If (x <> Xmax) Or (y <> Ymax) Then
        Color WHITE, BLACK
        Cls
        Print Using "Please resize window (Esc=Stop) 000:0000"; lines, columns;
        ' Print hello world:
        l = center_line
        c = center_column(HELLO)
        Color YELLOW, BLUE
        Locate l - 1, c: Print bold_on + HELLO + bold_off;
        Locate l    , c: Print reve_on + HELLO + reve_off;
        Locate l + 1, c: Print line_on + HELLO + line_off;
        ' remember current windows size:
        x = Xmax
        y = Ymax
      Endif
    Wend


    ' LOCATE MOD CHR ASC.bas  SmallBASIC 0.12.2 [B+=MGA] 2016-03-23
    ' LOCATE row, column - sets the next print location on screen, rows down, columns across
    ' a MOD b - returns the remainder of a/b as integer 0 to b-1
    '           for example odd number n mod 2 returns 1, while even number n mod 2 returns 0
    '           n mod 10 returns 0,1,2,3,4,5,6,7,8 or 9  we will use this in demo
    ' CHR - returns the CHaRracter for the ASC number, for demo we will print a chart of CHR for ASC numbers 30-129
    ' ASC(Character) - is a number code for a print characters, 32 is the code for a space
    ' ? - is shortcut for PRINT
    ' RIGHT(string,n) - returns right most n characters of string
    ' STR(n) - returns a number in string form
    ' : - code statement seperator often used with LOCATE row, column : ? string
    LOCATE 1,16 : ? "ASC Table 30-129:"  'locate print spot, print title for our chart
    FOR column=0 to 9 'print a header, 10 numbers plus + (to add to row value)
      LOCATE 2,column*5+4 : ? "+";column
    NEXT
    FOR row=3 to 12
      LOCATE row,0 : ? RIGHT(" "+STR(row*10)+":",4)
    NEXT
    FOR ASCnumber=30 to 129   'note ASC(32) = space so wont see anything in Table
      row=ASCnumber\\10 ' \\ rounds division down to integer
      column=(ASCnumber MOD 10)*5+5  'times 5 to space out the characters printed plus 5 for column labels
      LOCATE row,column : ? CHR(ASCnumber)   '<=========== handy reference
    NEXT
    PAUSE

+========================================================================================+
|                                  12. (Console) LOGPRINT                                |
+========================================================================================+

LOGPRINT ...

PRINT to the application logfile. The syntax is the same as command
PRINT.

+========================================================================================+
|                                  13. (Console) NOSOUND                                 |
+========================================================================================+

NOSOUND

Stop background sound and clear the sound queue.

+========================================================================================+
|                                    14. (Console) PEN                                   |
+========================================================================================+

PEN ON|OFF

Enables/Disables the PEN/MOUSE mechanism.

+========================================================================================+
|                                    15. (Console) PLAY                                  |
+========================================================================================+

PLAY string

Play musical notes.

-   A-G[-|+|#][nnn][.] Play note A..G, +|# is sharp, - is flat, . is
    multiplier 1.5
-   On Octave 0..6, < moves down one octave, > moves up one octave
-   Nnn Play note 0..84 (0 = pause)
-   Pnnn Pause 1..64
-   Lnnn Length of note 1..64 (1/nnn)
-   Tnnn Tempo 32..255. Number of 1/4 notes per minute.
-   MS Staccato (1/2)
-   MN Normal (3/4)
-   ML Legato
-   Vnnn Volume 0..100
-   MF Play on foreground
-   MB Play on background
-   Q Clear sound queue

+========================================================================================+
|                                   16. (Console) PRINT                                  |
+========================================================================================+

PRINT [USING [format];] [expr|str [,|; [expr|str]] ...

Display text or the value of an expression.

PRINT SEPARATORS

  -------- ------------------------------------------------------
  TAB(n)   Moves cursor position to the nth column.
  SPC(n)   Prints a number of spaces specified by n.
  ;        Carriage return/line feed suppressed after printing.
  ,        Carriage return/line feed suppressed after printing.
  -------- ------------------------------------------------------

PRINT USING

Print USING uses the FORMAT() function to display numbers and strings.
Unlike FORMAT it can also include literals.

-   [_] - Print next character as a literal. The combination _#, for
    example, allows you to include a number sign as a literal in your
    numeric format.
-   [other] Characters other than the foregoing may be included as
    literals in the format string.

When a PRINT USING command is executed the format will remains on the
memory until a new format is passed. Calling a PRINT USING without a new
format specified the PRINT will use the format of previous call.

    PRINT USING "##: #,###,##0.00";
    FOR i=0 TO 20
        PRINT USING; i+1, A(i)
    NEXT
    ....
    PRINT USING "Total ###,##0 of \\ \\"; number, "bytes"

The symbol ? can be used instead of keyword PRINT You can use ‘USG’
instead of ‘USING’.

quote: IT’S ALL IN THE PUNCTUATION AT THE END OF A PRINT STATEMENT

    REM 3 ways to print hello five time.bas 2016-03-05 SmallBASIC 0.12.2 [B+=MGA]
    'It's all in the punctuation at the end of a print statement
    '1) no punctiation  = whole print lines CR=carriage return and LF=line feed, ready to go on next line
    for i=1 to 5
      print "hello"
    next
    ?:? '2 blank lines

    '2) a comma which tabs to next avaiable tab column and will stay on same line until run out of coloumns
    for i=1 to 5
      print "hello",
    next
    ? "& this will finish the hello, line."
    ?:? 'the first ?=print will finish the print line, the 2 two are blank lines

    '3) a semicolon (and space after hello)
    for i=1 to 5
      print "hello";" ";  'or just print "hello ";
    next
    ? "... this line needs to be finsihed."
    pause

To gain even more control of where your next PRINT statement will end up
on screen checkout the older LOCATE keyword and the more modern method
of using AT.


    ' PRINT can also print to an open file or device (not only to console).
    ' Note: new-line (or line-break) character(s) is different on each system:
    '       Windows and DOS uses a pair of CR and LF characters to terminate lines. 
    '       UNIX, Linux, FreeBSD and OS X uses a single LF character only. 
    '       Classic Mac operating system uses a single CR character only.
    '       * CR is CHR(13); LF is CHR(10).

    ' Print lines to demo file:
    Open "PRINT.TMP" For Output As #1
    Print #1, "hello_1" ' print [hello new-line]
    Print #1, "Hello_2", "Hello_3"  ' print [hello tab hello new-line]
    Print #1, "Hello_4"; "Hello_5"; ' print [hello hello]
    Print #1, ' print [new-line]
    Print #1, ' print [new-line]
    Print #1, ; ' print [].
    Print #1, Using "000 &"; 55, "is my mailbox" ' print [055... new-line]
    ? #1, "Hello_?" ' print [Hello_? new-line]
    Close #1
    ' Load lines from demo file and print them to console:
    Open "PRINT.TMP" For Input As #1
    Color 0, 7
    While Not Eof(1) Do
      Lineinput #1, s
      Print s
    Wend
    Close #1
    Pause

+========================================================================================+
|                                   17. (Console) SOUND                                  |
+========================================================================================+

SOUND freq, dur_ms [, vol] [BG]

Plays a sound.

-   freq The frequency
-   dur_ms The duration in milliseconds
-   vol The volume in 1/100 units
-   BG Play it in background

+========================================================================================+
|                                    18. (Console) TAB                                   |
+========================================================================================+

TAB (n)

Moves cursor position to the nth column.


    print tab(50); "Oh! TAB works with PRINT and moves x pixels not x character cells."
    pause 

+========================================================================================+
|                                    19. (Data) APPEND                                   |
+========================================================================================+

APPEND a, val [, val [, ...]]

Inserts the values at the end of the specified array.

-   a - An array-variable.
-   val - Any value or expression

+========================================================================================+
|                                     20. (Data) ARRAY                                   |
+========================================================================================+

ARRAY [var | expr]

Creates a ARRAY or MAP variable from the given string or expression.

The ARRAY command supports JSON (Javascript object notation) syntax. The
MAP provides value-key pair access along with array or dotted notation.
The MAP can be converted back into a JSON string using the STR command.
You can test whether a variable is a MAP using the ISMAP command.

The following example shows a possible JSON representation describing a
person:

    {
      "firstName": "John",
      "lastName": "Smith",
      "isAlive": true,
      "age": 25,
      "address": {
        "streetAddress": "21 2nd Street",
        "city": "New York",
        "state": "NY",
        "postalCode": "10021-3100"
      },
      "phoneNumbers": [
        {
          "type": "home",
          "number": "212 555-1234"
        },
        {
          "type": "office",
          "number": "646 555-4567"
        },
        {
          "type": "mobile",
          "number": "123 456-7890"
        }
      ],
      "children": [],
      "spouse": null
    }

Example 1:

    Def uline(text) = Cat(2) + text + Cat(-2) ' Underline text
    Cls
    ? uline("1-Dimension Map Array:")
    ?
    a = Array("{x:100, y:300, title:top-left}")
    ? "a is:       "; a
    ? "a is map?   "; Ismap(a)
    ?
    ? "a.x is:     "; a.x
    ? "a.y is:     "; a.y
    ? "a.title is: "; a.title
    ?
    a.x = "N/A"
    ? "a.x is now: "; a.x
    ?
    ?:?:? " Press any key..."
    Pause
    Cls
    ? uline("1-Dimension Map Array, with 1-D Nested Map Array:")
    ?
    Dim a(1 To 10, 1 To 2)
    a(5, 1) = Array("{x:1, y:3, down:{x:4, y:7}}")
    ? "a(5, 1) is:            "; a(5, 1)
    ? "a(5, 1) is map?        "; Ismap(a(5, 1))
    ? "a is map?              "; Ismap(a)
    ?
    ? "a(5, 1).x is:          "; a(5, 1).x
    ? "a(5, 1).y is:          "; a(5, 1).y
    ? "a(5, 1).down.x is:     "; a(5, 1).down.x
    ? "a(5, 1).down.y is:     "; a(5, 1).down.y
    ?
    a(5, 1).down.x = "N/A"
    ? "a(5, 1).down.x is now: "; a(5, 1).down.x
    ?
    ?:?:? " Press any key..."
    Pause
    Cls
    ? uline("1-Dimension Map Array, with Two 1-D Nested Map Arrays:")
    ?
    a = Array("{x:1, y:3, down:[{x:4, y:7}, {x:6, y:9}]}")
    ? "a is:               "; a
    ? "a is map?           "; Ismap(a)
    ?
    ? "a.x is:             "; a.x
    ? "a.y is:             "; a.y
    ? "a.down(0).x is:     "; a.down(0).x
    ? "a.down(0).y is:     "; a.down(0).y
    ? "a.down(1).x is:     "; a.down(1).x
    ? "a.down(1).y is:     "; a.down(1).y
    ?
    a.down(1).x = "N/A"
    ? "a.down(1).x is now: "; a.down(1).x
    ?
    ?:?:? " Press any key..."
    Pause
    Cls
    ? uline("Create 1-Dimension Map Array without using ARRAY Keyword:")
    ?
    b.x = 40
    b.y = 50
    b.title = "Top-Left"
    ? "b.x is:     "; b.x
    ? "b.y is:     "; b.y
    ? "b.title is: "; b.title
    ?
    ? "b is:       "; b
    ? "b is map?   "; Ismap(b)
    ?
    ?:?:? " Press any key..."
    Pause

Example 2:

    REM SmallBASIC
    REM created: 03/04/2016
    ? "Let's test reading files"
    ? "FREEFILE is ", FREEFILE
    ? "OPEN file [FOR INPUT|OUTPUT|APPEND] AS #fileN"
    ? "OPEN \\"jump\\" FOR INPUT AS #1"
    OPEN "jump" FOR INPUT AS #1
    ? "==================="
    ? "Test TLOAD to array"
    ? "==================="
    ? "TLOAD file, BYREF var [, type]"
    ? "Loads a text file into array variable."
    ? "Each text-line is an array element."
    ? "type 0 = load into array (default)"
    ?
    ? "TLOAD #1, i,0"
    TLOAD #1,i,0
    ? "CLOSE file 1 for INPUT"
    CLOSE #1
    ? "========================================"
    ?
    ? "ISARRAY ",ISARRAY (i)
    ? "Process values & instructions"
    ? "Check for the @ sign"
    ? "Convert dec2bin"
    ? "Pad out to 16 bits"
    ?
    ? "REDIM i to split destination table"
    ? "& make dictionary"
    REDIM i(1,7)
    ?
    ? "Print array contents"
    ?
    ? "No","jump",,"bin"
    For j=0 to 7
      ? j,i(0,j),,i(1,j)
      next j
    ?
    ? "SEARCH list (above) for Assembler"
    ? "SEARCH i, \\"JEQ\\", r"
    SEARCH i, "JEQ", r
    ? "r = ", r
    ? "jump   = ",i(0,r)
    ? "binary = ",i(1,r)

Example 3:

    ? "OPEN \\"dest\\" FOR INPUT AS #1"
    OPEN "dest" FOR INPUT AS #1
    ? "TLOAD #1, i,0"
    TLOAD #1,i,0
    ? "CLOSE file 1 for INPUT"
    CLOSE #1
    ? "Print the dest file shown below.
    ? 
    ? "null"
    ? "M"
    ? "D"
    ? "MD"
    ? "A"
    ? "AM"
    ? "AD"
    ? "AMD"
    ? "000"
    ? "001"
    ? "010"
    ? "011"
    ? "100"
    ? "101"
    ? "110"
    ? "111"
    ?
    ? "REDIM i to split destination table"
    ? "& make dictionary"
    REDIM i(1,7)
    ?
    ? "Print array contents"
    ?
    ? "No","func",,"bin"
    For j=0 to 7
      ? j,i(0,j),,i(1,j)
      next j
    ?
    ? "SEARCH list (above) for Assembler"
    ? "SEARCH i, \\"AM\\", r"
    SEARCH i, "AM", r
    ? "r = ", r
    ? "destination = ",i(0,r)
    ? "binary      = ",i(1,r)

+========================================================================================+
|                                     21. (Data) CDBL                                    |
+========================================================================================+

CDBL (x)

Convert x to 64b real number. Meaningless. Used for compatibility.

+========================================================================================+
|                                     22. (Data) CINT                                    |
+========================================================================================+

CINT (x)

Converts x to 32b integer. Meaningless. Used for compatibility.

+========================================================================================+
|                                     23. (Data) CREAL                                   |
+========================================================================================+

CREAL (x)

Convert x to 64b real number. Meaningless. Used for compatibility.

+========================================================================================+
|                                     24. (Data) DATA                                    |
+========================================================================================+

DATA constant1 [,constant2]...

Stores one or more constants, of any type, for subsequent access via
READ command.

DATA commands are non executable statements that supply a stream of data
constants for use by READ commands. All the items supplied by all the
DATA commands in a program make up one continuous “string” of
information that is accessed in order by your program’s READ commands.

    RESTORE MyDataBlock
    FOR I=1 TO 3
        READ v
        PRINT v
    NEXT
    END
    ...
    LABEL MyDataBlock
    DATA 1,2,3

+========================================================================================+
|                                    25. (Data) DELETE                                   |
+========================================================================================+

DELETE a, idx [, count]

Deletes ‘count’ elements at position ‘idx’ of array ‘a’.

-   a - An array-variable.
-   idx - Position in the array.
-   count - The number of the elements to be deleted.

+========================================================================================+
|                                      26. (Data) DIM                                    |
+========================================================================================+

DIM var([lower TO] upper [, ...]) [, ...]

Reserves storage space for an array.

The array will have (upper-lower)+1 elements. If lower is not specified,
and OPTION BASE hasn’t used, elements start at 0.

    REM One dimension array of 7 elements, starting from 0
    DIM A(6)
    ...
    REM One dimension array of 6 elements, starting from 1
    DIM A(1 TO 6)
    ...
    REM Three dimension array
    DIM A(1 TO 6, 1 TO 4, 1 TO 8)
    ...
    REM Allocating zero-length arrays:
    DIM z()
    ...
    IF LEN(Z)=0 THE APPEND Z, "The first element"


    Option Base 1 ' Set default lower bound of arrays to 1
    ? "Showing x,y,z elements of index 5:"
    ?
    ' Reserve space for a single 1-dimensional array:
    x = 0
    y = 10
    z = 20
    Dim a(1 To 30)
    For i = 1 To 10
      a(i + x) = i
      a(i + y) = i + 10
      a(i + z) = i + 100
    Next
    ? a(5 + x), a(5 + y), a(5 + z),, "(1-dimensional array)"

    ' Reserve the same space for three 1-dimensional arrays:
    Dim a_x(1 To 10), a_y(1 To 10), a_z(1 To 10)
    For i = 1 To 10
      a_x(i) = i
      a_y(i) = i + 10
      a_z(i) = i + 100
    Next
    ? a_x(5), a_y(5), a_z(5),, "(three 1-dimensional arrays)"

    ' Reserve the same space for a single 2-dimensional array:
    x = 1
    y = 2
    z = 3
    Dim a(1 To 10, x To z)
    For i = 1 To 10
      a(i, x) = i
      a(i, y) = i + 10
      a(i, z) = i + 100
    Next
    ? a(5, x), a(5, y), a(5, z),, "(2-dimensional array)"

    ' Reserve the same space for a single nested array:
    Dim a(1 To 10)
    For i = 1 To 10
      a(i) = [,,] ' convert this element to nested array
      a(i)(x) = i
      a(i)(y) = i + 10
      a(i)(z) = i + 100
    Next
    ? a(5)(x), a(5)(y), a(5)(z),, "(nested array)"

    ' Reserve the same space for a single map array (see also: ARRAY, ISMAP):
    Dim a(1 To 10)
    For i = 1 To 10
      a(i).x = i
      a(i).y = i + 10
      a(i).z = i + 100
    Next
    ? a(5).x, a(5).y, a(5).z,, "(map array)"

    Pause

+========================================================================================+
|                                     27. (Data) EMPTY                                   |
+========================================================================================+

EMPTY (x)

Returns true if x is: a zero length array, an empty string, an integer
or real with the value 0.

-   If x is a string, returns true if the len(x) is 0.
-   If x is an integer or a real returns true if the x = 0.
-   If x is an array, returns true if x is a zero-length array (array
    without elements).

+========================================================================================+
|                                     28. (Data) ERASE                                   |
+========================================================================================+

ERASE var[, var[, ... var]]

Deallocates the memory used by the specified arrays or variables. After
that these variables turned to simple integers with zero value.

    DIM x(100)
    ...
    PRINT FRE(0)
    ERASE x
    PRINT FRE(0)
    PRINT x(1):REM ERROR

+========================================================================================+
|                                    29. (Data) INSERT                                   |
+========================================================================================+

INSERT a, idx, val [, val [, ...]]]

Inserts the values to the specified array at the position idx.

-   a - An array-variable.
-   idx - Position in the array.
-   val - Any value or expression.

+========================================================================================+
|                                    30. (Data) ISARRAY                                  |
+========================================================================================+

ISARRAY (x)

Returns true if x is an array.

+========================================================================================+
|                                     31. (Data) ISDIR                                   |
+========================================================================================+

ISDIR (x)

Returns true if x is a directory.

+========================================================================================+
|                                    32. (Data) ISFILE                                   |
+========================================================================================+

ISFILE (x)

Returns true if x is a regular file.

+========================================================================================+
|                                    33. (Data) ISLINK                                   |
+========================================================================================+

ISLINK (x)

Returns true if x is a link.

+========================================================================================+
|                                     34. (Data) ISMAP                                   |
+========================================================================================+

ISMAP (x)

Returns true if x is an MAP variable type. A MAP provides value-key pair
access along with array or dotted notation. The MAP can be initialized
from a String variable using the ARRAY command.

+========================================================================================+
|                                   35. (Data) ISNUMBER                                  |
+========================================================================================+

ISNUMBER (x)

Returns true if x is a number (or it can be converted to a number).

    ? ISNUMBER(12)          :REM true
    ? ISNUMBER("12")        :REM true
    ? ISNUMBER("12E+2")     :REM true
    ? ISNUMBER("abc")       :REM false
    ? ISNUMBER("1+2")       :REM false
    ? ISNUMBER("int(2.4)")  :REM false

+========================================================================================+
|                                   36. (Data) ISSTRING                                  |
+========================================================================================+

ISSTRING (x)

Returns true if x is a string (and cannot be converted to a number).

    ? ISSTRING(12)      :REM false
    ? ISSTRING("12")    :REM false
    ? ISSTRING("12E+2") :REM false
    ? ISSTRING("abc")   :REM true
    ? ISSTRING("1+2")   :REM true

+========================================================================================+
|                                    37. (Data) LBOUND                                   |
+========================================================================================+

LBOUND (array [, dim])

Returns the lower bound of ‘array’.

+========================================================================================+
|                                      38. (Data) LEN                                    |
+========================================================================================+

LEN(d)

Returns the length of the value contained in the variable.

-   If x is a string, returns the length of the string.
-   If x is an array, returns the number of the elements.
-   If x is an number, returns the length of the STR(x).


    ' format text lines
    Def set(text, var) = Left(text + Space(60), 60) + Len(var)  
    Color 15 
    ? "var is..." + Space(50) + "Len(var):"
    ?
    Color 7
    var = 15.2 ' number
    ? set("var = 15.2", var)
    ?
    var = "SmallBASIC" ' string
    ? set("var = \\"SmallBASIC\\"", var)
    ?
    var = [1, 2, "xyz"] ' 1-dimension array
    ? set("var = [1, 2, \\"xyz\\"]", var)
    var = [1, 2, [3, "xyz"]] ' 1-dimension array and 1 nested array
    ? set("var = [1, 2, [3, \\"xyz\\"]]", var)
    var = [1, 2, [3, [4, "xyz"]]] ' 1-dimension array and 2 nested arrays
    ? set("var = [1, 2, [3, [4, \\"xyz\\"]]]", var)
    ?
    var = [] ' 1-dimension array
    ? set("var = []", var)
    var = [1, 2; "xyz"] ' 2-dimension array
    ? set("var = [1, 2; \\"xyz\\"]", var)
    var = [;;,] ' 3-dimension array
    ? set("var = [;;,]", var)
    ?
    Dim var() ' empty array
    ? set("Dim var()", var)
    Dim var(16 To 20) ' 1-dimension array
    ? set("Dim var(16 To 20)", var)
    Dim var(16 To 20, 1 To 2) ' 2-dimension array
    ? set("Dim var(16 To 20, 1 To 2)", var)
    ?
    var = Array("{x:1, y:3}") ' 1-dimension map array
    ? set("var = Array(\\"{x:1, y:3}\\")", var)
    ' 1-dimension map array and 1 nested map array:
    var = Array("{x:1, y:3, down:{x:4, y:7}}") 
    ? set("var = Array(\\"{x:1, y:3, down:{x:4, y:7}}\\")", var)
    ' 1-dimension map array and 1 nested map array:
    var = Array("{x:1, y:3, down:[{x:4, y:7}, {x:6, y:9}]}")
    ? set("var = Array(\\"{x:1, y:3, down:[{x:4, y:7}, {x:6, y:9}]}\\")", var)
    Pause

I added integer to list (50), and got len = 2 Now I wonder if Floats
change according to precision needed. Now I wonder if integers change
too… Append quick experiment: Oh, I guess it’s the length of the number
as STR’d up to 17 …then it floats?


    ' Len(number) = Len(Str(number))...
    ' but IEEE format for float and big numbers is hard to predict...
    ' few examples on 64-bit system:
    ? Str(100)                  ' 100
    ? Str(100.51)               ' 100.51000000000001
    ? Str(-300.3)               ' -300.30000000000001
    ? Str(0xFFFFFFFF)           ' 4294967295
    ? Str(0xFFFFFFFFFFFFFFFF)   ' -1
    ? Str(99999999999999.888888888888888) ' 99999999999999.890625
    ? Str(1.999999E+302)        ' 1.999999E+302

Yes, I think it is the len of the string in exponent format when the
number is too long to store as string without exponent notation. I was
doing long integers and it was matching len(STR number) and when
switched to e format it was still the len of the number as string only
with e format (very much shorter).
https:support.microsoft.com_en-us_kb_42980 (replace _ with / to get the
address) This article shows that it’s not easy to convert IEEE
floating-point binary numbers to decimal numbers.

+========================================================================================+
|                                     39. (Data) READ                                    |
+========================================================================================+

READ var[, var ...]

Assigns values in DATA items to specified variables.

var - Any variable.

Unless a RESTORE command is executed, SmallBASIC moves to the next DATA
item with each READ assignment. If SmallBASIC runs out of DATA items to
READ, an run-time error occurs.

    FOR c=1 TO 6
       READ x
       PRINT x
    NEXT
    ...
    DATA "a,b,c", 2
    DATA 3, 4
    DATA "fifth", 6

+========================================================================================+
|                                     40. (Data) REDIM                                   |
+========================================================================================+

REDIM x

Same as DIM only the contents of x are preserved.


    ' inspired by Bambi56...
    Option Base 1 ' Start arrays at 1 (not 0)
    Const FILENAME = "One hell of a REDIM.tmp" 
    ' Save 6 lines in demo file:
    Open FILENAME For Output As #1
     ? #1, "one"
     ? #1, "two"
     ? #1, "three"
     ? #1, 1
     ? #1, 2
     ? #1, 3; ' (Using ; to avoid an extra empty line).
    Close #1
    ' Load 6 lines from demo file:
    Tload FILENAME, lines
    Color 15
    ? "One hell of a REDIM..."
    Color 7
    ' Print lines before redim:
    ?
    ? "lines before REDIM: "; lines
    ?
    ' Redim lines into two columns:
    Const TOTAL_LINES = Len(lines) \\ 2
    Redim lines(1 To 2, 1 To TOTAL_LINES)
    ' Print lines after redim:
    ? "lines after REDIM:  "; lines
    ?
    For l = 1 To TOTAL_LINES
      ? lines(1, l);      ' First column
      Locate Ypos, 15 
      ? lines(2, l)       ' Second column
    Next row
    Pause

I never would have guessed you could TLOAD an OPENed file and Bambi56
used the file number from OPEN to do the TLOAD. Very interesting…

+========================================================================================+
|                                    41. (Data) RESTORE                                  |
+========================================================================================+

RESTORE label

Specifies the position of the next data to be read.

+========================================================================================+
|                                    42. (Data) SEARCH                                   |
+========================================================================================+

SEARCH A, key, BYREF ridx [USE cmpfunc]

Scans an array for the key. If key is not found the SEARCH command
returns (in ridx) the value. (LBOUND(A)-1). In default-base arrays that
means -1. The cmpfunc (if its specified) it takes 2 vars to compare. It
must return 0 if x = y; non-zero if x <> y.

    FUNC cmp(x,y)
      cmp=!(x=y)
    END
    ...
    DIM A(5)
    FOR i=0 TO 5
        A(i)=5-i
    NEXT
    SEARCH A, 4, r USE cmp(x,y)
    PRINT r:REM prints 1
    PRINT A(r): REM prints 4


    ' Note: I'm not sure yet about a practical use for [USE cmpfunc] syntax...
    Def q(text) = Enclose(text) ' Enclose text with quotation marks, ""
    Def rev(text) = Cat(3) + text + Cat(-3)  ' reverse colors of text
    Sub title(text)
      ?: Color 14: Print text: Color 7  ' print title in color
    End Sub

    Dim a(5 To 7)
    a(5) = "Hello" 
    a(6) = "World"
    a(7) = 123
    ? rev(" Dim a(5 To 7) = " + Str(a) + " ")
    title "Use SEARCH to find index of matching element in array (Base LBOUND(a)):"
    Search a, "Hello", i:  ? "Search a, " + q("Hello") + ", i: "; i
    Search a,  "ello", i:  ? "Search a, " + q("ello") + " , i: "; i
    Search a, "HELLO", i:  ? "Search a, " + q("HELLO") + ", i: "; i
    Search a, "World", i:  ? "Search a, " + q("World") + ", i: "; i
    Search a,     123, i:  ? "Search a, " + " 123   "  + ", i: "; i
    Search a,      12, i:  ? "Search a, " + " 12    "  + ", i: "; i
    title "Use IN to find index of matching element in array (Always Base 1):"
    ? q("Hello") + " In a: ";  "Hello" In a
    ? q("ello") + "  In a: ";   "ello" In a
    ? q("HELLO") + " In a: ";  "HELLO" In a
    ? q("World") + " In a: ";  "World" In a
    ? " 123    In a: ";            123 In a
    ? " 12     In a: ";            12  In a
    Pause


    Option Base 1
    ' x is the current array element of search;
    ' y is the array element (key) that we search for.
    Func create_new_array(x, y, Byref new_a)
      ' Create a new array:
      If x <> 0 Then Append new_a, x 
      
      ' Standard expression to continue the search:
      create_new_array = Not (x = y) 
    End Func

    ' Start demo:
    a = ["a"; "b", "c", "d", "e"; "f"] ' Array for search
    e = "c"     ' Element (key) to find
    Dim new_a() ' Initialize empty new array
    Search a, e, ix Use create_new_array(x, y, new_a)
    ? "Array for search: "; a
    ?
    ? "Element (key) to find: "; e
    ?
    ' Check return-index (ix):
    If ix = Lbound(a) - 1 Then
      ? "Element not found in array."
    Else
      ? "Element found in array at index: "; ix
    Fi
    ?
    ? "New array created on search: "; new_a
    Pause

+========================================================================================+
|                                     43. (Data) SORT                                    |
+========================================================================================+

SORT array [USE cmpfunc]

Sorts an array. The cmpfunc if specified, takes 2 vars to compare and
must return: -1 if x < y, +1 if x > y, 0 if x = y.

    FUNC qscmp(x,y)
    IF x=y
        qscmp=0
    ELIF x>y
        qscmp=1
    ELSE
        qscmp=-1
    ENDIF
    END
    ...
    DIM A(5)
    FOR i=0 TO 5
        A(i)=RND
    NEXT
    SORT A USE qscmp(x,y)

+========================================================================================+
|                                     44. (Data) SWAP                                    |
+========================================================================================+

SWAP a, b

Exchanges the values of two variables. The parameters may be variables
of any type.

+========================================================================================+
|                                    45. (Data) UBOUND                                   |
+========================================================================================+

UBOUND (array [, dim])

Returns the upper bound of ‘array’.

+========================================================================================+
|                                     46. (Date) DATE                                    |
+========================================================================================+

DATE

Returns the current date as string “DD/MM/YYYY”.

+========================================================================================+
|                                    47. (Date) DATEDMY                                  |
+========================================================================================+

DATEDMY dmy| julian_date, BYREF d, BYREF m, BYREF y

Returns the day, month and the year as integers.

+========================================================================================+
|                                    48. (Date) DATEFMT                                  |
+========================================================================================+

DATEFMT (format, dmy| (d,m,y)| julian_date)

Returns formatted date string.

Format:

  ------ --------------------------
  D      one or two digits of Day
  DD     2-digit day
  DDD    3-char day name
  DDDD   full day name
  M      1 or 2 digits of month
  MM     2-digit month
  MMM    3-char month name
  MMMM   full month name
  YY     2-digit year (2K)
  YYYY   4-digit year
  ------ --------------------------

    PRINT DATEFMT("ddd dd, mm/yy", "23/11/2001")
    REM prints "Fri 23, 11/01"

+========================================================================================+
|                                    49. (Date) JULIAN                                   |
+========================================================================================+

JULIAN (dmy| (d,m,y))

Returns the Julian date. (dates must be greater than 1/1/100 AD).

    PRINT Julian(DATE)
    PRINT Julian(31, 12, 2001)

Earlier this month I had done some code to calculate Oil Tank usage and
used a ridiculously long and complex formula for calculating the number
of days between two dates. I should have used the julian date function:


    REM julian demo.bas 2016-02-28 SmallBASIC 0.12.2 [B+=MGA]
    'oh julian returns the number of days since 1/1/100
    'it is perfect for calculating the number of days between two dates
    'but the date given to the julian function must be in form dd/mm/yyyy or m,d,y (see help)
    'Date just so happens also returns in dd/mm/yyyy format so...
    ? "Today is ";date
    input "To test what julian returns, enter a date dd/mm/yyyy ";adate
    ? "julian(";adate;") returns: ";julian(adate)
    ? "That is/was ";abs(julian(adate)-julian(date));" days from today."
    ?:input "To test the other format julian accepts enter a date as: dd,mm,yyyy(enter) ";d,m,y
    ? "That is/was ";abs(julian(d,m,y)-julian(date));" days from today."
    ?:? "Again julian is excellent for calculating the number of days between two dates."
    pause
    end

+========================================================================================+
|                                     50. (Date) TICKS                                   |
+========================================================================================+

TICKS

Returns the number of milliseconds that have elapsed between successive
calls.

+========================================================================================+
|                                     51. (Date) TIME                                    |
+========================================================================================+

TIME

Returns the current time as string “HH:MM:SS”.

+========================================================================================+
|                                    52. (Date) TIMEHMS                                  |
+========================================================================================+

TIMEHMS hms| timer, BYREF h, BYREF m, BYREF s

Converts a time-value to hours, minutes and seconds integer values.

+========================================================================================+
|                                     53. (Date) TIMER                                   |
+========================================================================================+

TIMER

Returns the number of seconds from midnight.

+========================================================================================+
|                                   54. (Date) TIMESTAMP                                 |
+========================================================================================+

TIMESTAMP filename

Returns the file last modified date and time.

+========================================================================================+
|                                    55. (Date) WEEKDAY                                  |
+========================================================================================+

WEEKDAY (dmy| (d,m,y)| julian_date)

Returns the day of the week (0 = Sunday).

    PRINT WeekDay(DATE)
    PRINT WeekDay(Julian(31, 12, 2001))
    PRINT WeekDay(31, 12, 2001)

    SPLIT "Sun Mon Tue Wed Thu Fri Sat", " ", wd
    today = "Today is " + wd(WEEKDAY(DATE)) + " " + DATE
    PRINT today

+========================================================================================+
|                                    56. (File) ACCESS                                   |
+========================================================================================+

ACCESS (file)

Returns the access rights of the file.

-   file - A string expression that follows OS file naming conventions.

Returns file permissions as per chmod() and stat() system calls.

The bits (in octal):

  ------- ---------------------------
  04000      set user ID on execution
  02000     set group ID on execution
  01000                    sticky bit
  00400                 read by owner
  00200                write by owner
  00100       execute/search by owner
  00040                 read by group
  00020                write by group
  00010       execute/search by group
  00004                read by others
  00002               write by others
  00001      execute/search by others
  ------- ---------------------------

    IF ACCESS("/bin/sh") AND 0o4 THEN
     PRINT "I can read it!"
    ENDIF

+========================================================================================+
|                                     57. (File) BGETC                                   |
+========================================================================================+

BGETC (fileN)

Reads and returns a byte from file or device (Binary mode) .

+========================================================================================+
|                                     58. (File) BLOAD                                   |
+========================================================================================+

BLOAD filename[, address]

Loads a specified memory image file into memory.

+========================================================================================+
|                                     59. (File) BPUTC                                   |
+========================================================================================+

BPUTC# fileN; byte

Writes a byte on file or device. (Binary mode).

+========================================================================================+
|                                     60. (File) BSAVE                                   |
+========================================================================================+

BSAVE filename, address, length

Copies a specified portion of memory to a specified file.

+========================================================================================+
|                                     61. (File) CHDIR                                   |
+========================================================================================+

CHDIR dir

Changes the current working directory.

+========================================================================================+
|                                     62. (File) CHMOD                                   |
+========================================================================================+

CHMOD file, mode

Change permissions of a file. See also ACCESS.

-   file - A string expression that follows OS file naming conventions.
-   mode - Compatible with system call chmod()‘s ’mode’ parameter.

    ' Make myfile available to anyone (read/write)
    CHMOD "myfile.bas", 0o666
    ...
    ' Make myfile available to anyone (execute/read/write)
    CHMOD "myfile.bas", 0o777

+========================================================================================+
|                                     63. (File) CLOSE                                   |
+========================================================================================+

CLOSE #fileN

Close a file or device.

+========================================================================================+
|                                     64. (File) COPY                                    |
+========================================================================================+

COPY \"file\", \"newfile\"

Makes a copy of specified file to the ‘newfile’.

+========================================================================================+
|                                    65. (File) DIRWALK                                  |
+========================================================================================+

DIRWALK directory [, wildcards] [USE ...]

Walk through the specified directories. The user-defined function must
returns zero to stop the process.

    FUNC PRNF(x)
      ? x
      PRNF=TRUE
    END
    ...
    DIRWALK "." USE PRNF(x)


    ' Note: this demo is also a useful utility (version 2)

    ' -------------------- Start of Demo search ---------------------
    ' "." = Start search in current directory:
    dir = "."
    ' Exclude some binary files to speed up search (it's not case sensitive):
    exclude_ext = "jpeg jpg png gif mp3 mp4 zip 7z exe dat"
    ' Search this "string":
    word = "FUNC "
    ' 0 = Not case sensitive search; 1 = Case sensitive search:
    case_sensitive = 0
    ' Search it!
    search_word dir, exclude_ext, word, case_sensitive

    ' ' Demo only for dir_list():
    ' a = dir_list(dir, exclude_ext)
    ' For i In a Do ? i
    ' ? " - Length of list: "; Len(a)
    ' -------------------- End of Demo search ---------------------

    ' Purpose: return sorted array of directory files-list (including files in
    '          sub-directories, but not directory-names).
    ' Details: "dir" is the top directory to start search from (default = ".");
    '          "exclude_ext" is a Not case sensitive string of file-extension(s)
    '          to exclude from list (default = ""), For example:
    '           "jpeg jpg zip z7 gif wav mp3" ' Space delimited extensions.
    ' Example:
    '  a = dir_list("", "")  ' a is all files in current dir (and its sub-dirs).
    '  a = dir_list("..", "bak zip") ' a is files in upper dir, exclude .bak .zip
    Func dir_list(dir, exclude_ext)
      Local a, ext
      ' Verify "dir" ("." is current directory):
      dir = Trim(dir): If dir = "" Then dir = "."            '
      ' Exclude extension in Any case (for Windows):
      ext = Enclose(Lcase(Squeeze(exclude_ext)), " ")

      ' Make the dir list (DIRWALK):
      Func make_list(f)
        Local e                             ' File Extension (without ".")
        If Isfile(f) Then                   ' Don't add directory-names to list
          e = Enclose(Lcase(Rightoflast(f, ".")), " ")
          If Not (e In ext) Then a << f     ' Exclude extension? or append file
        Fi
        make_list = True                    ' (True = Continue to walk)
      End Func
      Dirwalk dir Use make_list(x)          ' (Note: parameter name must be 'x')
      ' Sort dir list and ignore case (SORT):
      Func no_case(x, y)
        x = Lcase(x)
        y = Lcase(y)
        Select Case 1
        Case x = y: no_case =  0
        Case x > y: no_case = +1
        Case Else : no_case = -1
        End Select
      End Func
      Sort a Use no_case(x, y)
      dir_list = a
    End Func

    ' Purpose: search for a "word" in "dir" (and its sub-dirs), and print results.
    ' Details: for "dir" and "exclude_ext" details - See dir_list() function.
    '          "word" is the string to search for.
    '          'cs' is case sensitive search - True or False.
    Sub search_word(dir, exclude_ext, word, cs)
      Local w, file, list, l, lines, p     ' For Searching
      Local c_page, c_line                 ' Counters
      Local t_lines, t_files, old_t_lines  ' Totals (for sum)
      Local LINES_PER_PAGE, attr = 3
      LINES_PER_PAGE = 10                 ' How many lines to print before pause?

      list = dir_list(dir, exclude_ext)    ' Get the list of all files
      w = Iff(cs, word, Ucase(word))       ' Case sensitive search?
      ? Cat(0); Chr(12); Cat(attr);        ' Clear console attributes and screen
      ' Load and search in each file:
      For file In list
        Tload file, lines
        c_line = 0

        ' Search in each line:
        For l In lines
          c_line++  ' Keep line # for [print the line]
          ' Look for the word in this line:
          If cs Then
            p = Instr(l, w)
          Else
            p = Instr(Ucase(l), w)
          Fi
          ' If word found then print the line:
          If p Then
            ? Cat(2); file + " [" + c_line + "]"; Cat(-2); " "; Mid(l, p)
            c_page++
            If c_page = LINES_PER_PAGE Then c_page = 0: Pause
            t_lines++  ' Keep total lines # for sum
          Fi
        Next l
        If t_lines > old_t_lines Then
          old_t_lines = t_lines
          attr = -attr: ? Cat(attr);  ' Change color on new file
          t_files++                   ' Keep total files # for sum
        Fi
      Next file

      ' Print sum:
      If c_page <> 0 Then Pause
      ? Cat(0)  ' Clear all console attributes
      Color 15
      ? "- Search in: "; Enclose(dir)
      ? "- Exclude file-extension(s): "; Enclose(Squeeze(exclude_ext))
      ? "- Search "; Iff(cs, "IS", "is NOT"); " case sensitive."
      ? "- Found "; Enclose(word); &
      " in "; t_lines; " lines, in "; t_files; " files "; &
      "(out of "; Len(list); " files)."
      ?
      Color 7
      ? "Done. Press Backspace key...";
      While Inkey <> Chr(8): Wend
    End Sub

+========================================================================================+
|                                      66. (File) EOF                                    |
+========================================================================================+

EOF (fileN)

Returns true if the file pointer is at end of the file. For COMx and
SOCL VFS returns true if the connection is broken.

+========================================================================================+
|                                     67. (File) EXIST                                   |
+========================================================================================+

EXIST (file)

Returns true if file exists.


    ' Return nonexisting file or directory name (12 A..Z letters + extension)
    ' in the current directory; e.g. filename = tempfile("-me.tmp") 
    Func tempfile(ext)
      Local i, f = Space(12) + ext
      Repeat
        For i = 1 To 12 
          f = Replace(f, i, Chr(floor((Rnd * 25.5) + 65)))
        Next
      Until Not Exist(f)
      tempfile = f
    End Func
    ' demo:
    filename = tempfile(".bak")
    a << "This is a backup file: " + filename ' append one line
    Tsave filename, a
    Tload filename, b
    ? b
    Pause
    Kill filename ' delete demo file

+========================================================================================+
|                                     68. (File) FILES                                   |
+========================================================================================+

FILES (wildcards)

Returns an array with the filenames. If there are no files returns an
empty array.

The directory listing, if assigned to a string, will create a string
array. Each filename is assigned to its own element in the string array.
sample program example:


    20 a$=FILES("*.*")
    30 n=LEN(a$)
    40 FOR i = 0 to n-1
    50 PRINT a$(i)
    60 NEXT i

+========================================================================================+
|                                   69. (File) FREEFILE                                  |
+========================================================================================+

FREEFILE

Returns an unused file handle.

+========================================================================================+
|                                     70. (File) INPUT                                   |
+========================================================================================+

INPUT #fileN; var1 [,delim] [, var2 [,delim]] ...

Reads data from file.

+========================================================================================+
|                                     71. (File) INPUT                                   |
+========================================================================================+

INPUT (len [, fileN])

Reads ‘len’ bytes from file or console (if fileN is omitted). This
function does not convert the data or remove spaces.

+========================================================================================+
|                                     72. (File) KILL                                    |
+========================================================================================+

KILL \"file\"

Deletes the specified file.

+========================================================================================+
|                                     73. (File) LOCK                                    |
+========================================================================================+

LOCK

Lock a record or an area (not yet implemented).

+========================================================================================+
|                                      74. (File) LOF                                    |
+========================================================================================+

LOF (fileN)

Returns the length of file in bytes. For other devices, returns the
number of available data.

+========================================================================================+
|                                     75. (File) MKDIR                                   |
+========================================================================================+

MKDIR dir

Create a directory.

+========================================================================================+
|                                     76. (File) OPEN                                    |
+========================================================================================+

OPEN file [FOR {INPUT|OUTPUT|APPEND}] AS #fileN

Makes a file or device available for sequential input, sequential
output.

-   file - A string expression that follows OS file naming conventions.
-   fileN - A file-handle (integer 1 to 256).

FOR

  -------- ---------------------------------------------
  INPUT    Sequential input
  OUTPUT   Sequential output
  APPEND   Sequential output, beginning at current EOF
  -------- ---------------------------------------------

The files are always opened as shared.

+========================================================================================+
|                                    77. (File) RENAME                                   |
+========================================================================================+

RENAME \"file\", \"newname\"

Renames the specified file.

+========================================================================================+
|                                     78. (File) RMDIR                                   |
+========================================================================================+

RMDIR dir

Removes a directory.

+========================================================================================+
|                                     79. (File) SEEK                                    |
+========================================================================================+

SEEK #fileN; pos

Sets file position for the next read/write.


    Const FILE = "RANDOM.TMP"
    Const RLEN = 50 ' record-length in bytes
    ' left justify string in buffer. s is string; l is buffer-length.
    Def lset(s, l) = Left(s + Space(l), l)
    ' append records to demo file:
    Open FILE For Output As #1
    For record = 1 To 7
      Read s
      Print #1, lset(s, RLEN); ' end with ; to avoid new-line char
    Next
    Const TOTAL_RECORDS = Lof(1) / RLEN
    Close #1
    ' 7 demo records:
    Data "OPEN: Open file for sequential input/output."
    Data "FREEFILE: Returns an unused file handle."
    Data "SEEK: Sets file position for next read/write."
    Data "EOF: True if file pointer is at end of file."
    Data "LOF: Returns the length of file in bytes."
    Data "CLOSE: Close a file."
    Data "COPY: Copy file to a new file."
    ' retrieve and display demo records using SEEK:
    Open FILE For Input As #1
    Repeat
      Color 7, 0: Locate 1, 1
      Input "Enter record # (1.." + TOTAL_RECORDS + ") to retrieve: ", n
      
      If n >= 1 And n <= TOTAL_RECORDS Then
        Locate 3, 1: Print "Rec #"; n; ": "; 
        Seek #1, (n - 1) * RLEN ' seek to record position (base 0)
        Color 15, 3: Print Input(RLEN, 1);
      Endif
    Until Isstring(n)
    Close #1

+========================================================================================+
|                                     80. (File) SEEK                                    |
+========================================================================================+

SEEK (fileN)

Returns the current file position.

+========================================================================================+
|                                     81. (File) TLOAD                                   |
+========================================================================================+

TLOAD file, BYREF var [, type]

Loads a text file into array variable. Each text-line is an array
element. type 0 = load into array (default), 1 = load into string.

Both these methods load a string/text file into an array.


    ' TLOAD.bas  SmallBASIC 0.12.2 [B+=MGA] 2016-04-04
    'with TLOAD you don't even have to dim your array to have it created
    me="TLOAD.bas"
    TLOAD me,ta    '<==== it's all done in one line!
    'show me
    for ln = 0 to ubound(ta)
      ? ln;" ";ta(ln)
    next
    ?
    ?"compare TLOAD above to INPUT method below to load array"
    ?
    'compare to this
    dim ia()
    open me for input as #1
    while not eof(1)
      input #1, aline
      ia << aline
    wend
    close #1            '<=== this took 7 lines
    'show me again
    for ln = 0 to ubound(ia)
      ? ln;" ";ia(ln)
    next
    pause


    ' See also: Home -- Articles -- Welcome to SmallBASIC -- *Arrays and Matrices*
    Option Base 1 ' Start arrays at 1 (not 0)
    ' Save few text lines in demo file:
    s1 = "xx_1 xx_2"
    s2 = "yy_1      yy_2  yy_3"
    s3 = "  zz_1   zz_2 "
    s4 = "JEQ"
    Open "demo.tmp" For Output As #1
     Print #1, s1
     Print #1, s2
     Print #1, s3
     Print #1, s4
    Close #1
    ' Load demo file into 1-dimension array:
    Tload "demo.tmp", lines, 0
    Const MAX_LINES = Ubound(lines)
    Const BLANK = " "
    ' Convert array to nested array and display it:
    For i = 1 To MAX_LINES
      
      ' Split array into words, i.e. nested array; space, " ", is the delimiter:
      Split Squeeze(lines(i)), BLANK, lines(i)
      ?
      ? "Line "; i; ":   "; lines(i)
      ' Print word for each column:
      For w = 1 To Len(lines(i))
        ?  "Column "; w; ": "; lines(i)(w) ' (i)(w) is a nested array...
      Next
    Next
    Pause

+========================================================================================+
|                                     82. (File) TSAVE                                   |
+========================================================================================+

TSAVE file, var

Writes an array to a text file. Each array element is a text-line.

-   file - A string expression that follows OS file naming conventions.
-   var - An array variable or a string variable. Expressions are not
    allowed.

+========================================================================================+
|                                     83. (File) WRITE                                   |
+========================================================================================+

WRITE #fileN; var1 [, ...]

Store variables to a file as binary data.

The READ/WRITE command set is used to store variables to a file as
binary data. The common problem with INPUT/PRINT set is there are many
conflicts with data. > PRINT #1; “Hello, world” The above example only
wrote one string and you want read it in one variable, but this is
impossible for INPUT command to understand, because INPUT finds the
separator comma, so it thinks there are two variables not one. So, now,
you can store arrays, strings etc and what you write is what you will
read the next time. _The parameters can be variables ONLY._ _Its very
bad idea to mixed READ/WRITE commands with INPUT/PRINT commands in the
same file._

This is how to store numeric arrays into files, WRITE # and read them
out again, READ #. The graphic example is longer but also useful as
utility…


    ' WRITE READ.bas  SmallBASIC 0.12.2 [B+=MGA] 2016-04-03
    const secwide=200
    const sechigh=200
    dim sect(secwide,sechigh)
    dim fsect(secwide,sechigh)
    for i=1 to 100
      if rnd<.5 then
        circle rnd*xmax,rnd*ymax,rnd*100,1,7+(rnd*9)\\1
      else
        circle rnd*xmax,rnd*ymax,rnd*100,1,7+(rnd*9)\\1 filled
      fi
    next
    getsec 200,400          '<== load array with data
    rect 200,400,400,600,15 '<=== draw square around the section captured
    savesect                '<== array data to file
    input "OK press enter for write read test ";temp
    cls
    loadsect     '<== file data to array
    x=100:y=100
    while 1
      cls
      drwsec x,y '<== using data from file
      showpage
      delay 10
      x=x+5:y=y+5
    wend
    sub savesect
      open "READ WRITE test.dat" for output as #1
      local x,y
      for y=0 to sechigh
        for x=0 to secwide
          write #1,sect(x,y) '<==== array data to file
        next
      next
      close #1
    end
    sub loadsect
       open "READ WRITE test.dat" for input as #1
      local x,y
      for y=0 to sechigh
        for x=0 to secwide
          read #1,fsect(x,y)  '<=== load file array
        next
      next
      close #1 
    end
    sub getsec(xstart,ystart)
      local x,y
      'these are all global
      for y=0 to sechigh
        for x=0 to secwide
          sect(x,y)=POINT(xstart+x,ystart+y) '<== data from screen points
        next
      next
    end 
    sub drwsec(leftx,topy)
      local x,y
      for y=0 to sechigh
        for x=0 to secwide
          pset x+leftx,y+topy,fsect(x,y) '<== array from file
        next
      next
    end 


    ' This demo sets properties of each tile in a matrix,
    ' then it stores the array in config file,
    ' then it loads the array from that config file.
    ' Note: WRITE/READ are using binary format for storing numbers, therefore
    '       number 1, for example, takes the same space as number -26845339.14
    Const TILES_X    = 20 ' Maximum tiles in x axis
    Const TILES_Y    = 15 ' Maximum tiles in y axis
    Const PROPERTIES = 3  ' Maximum properties for each tile in the matrix.
    Const P_FILENAME = 1 ' Some demo properties for each tile
    Const P_FILETYPE = 2
    Const P_HIDE     = 3
    ' Create 3-dimension array to store tiles properties:
    Dim tile(1 To TILES_X, 1 To TILES_Y, 1 To PROPERTIES)
    ' Demo to set a single tile properties, at x,y=10,2 in matrix:
    tile(10, 2, P_FILENAME) = "bricks.bmp" ' file name to load tile from
    tile(10, 2, P_FILETYPE) = "BMP16"      ' format of tile-file  
    tile(10, 2, P_HIDE)     = 1            ' hide/show [1/0] this tile
     
    ' Save tiles in config file 1:
    Open "tiles1.cfg" For Output As #1
    For y = 1 To TILES_Y
      For x = 1 To TILES_X
        For p = 1 To PROPERTIES
          Write #1; tile(x, y, p)
        Next p
      Next x
    Next y
    Close #1
    ' Load tiles from config file 1:
    Open "tiles1.cfg" For Input As #1
    For y = 1 To TILES_Y
      For x = 1 To TILES_X
        For p = 1 To PROPERTIES
          Read #1; tile(x, y, p)
        Next p
      Next x
    Next y
    Close #1
    ' Print demo of a single tile properties, at x,y=10,2 in matrix:
    ? "File name to load tile from: "; tile(10, 2, P_FILENAME)
    ? "Format of tile-file: "; tile(10, 2, P_FILETYPE)
    ? "Hide/Show [1/0] this tile: "; tile(10, 2, P_HIDE)
    Pause

+========================================================================================+
|                                    84. (Graphics) ARC                                  |
+========================================================================================+

ARC [STEP] x,y,r,astart,aend [,aspect [,color]] [COLOR color]

Draws an arc. astart, aend = first,last angle in radians.

+========================================================================================+
|                                   85. (Graphics) CHART                                 |
+========================================================================================+

CHART LINECHART|BARCHART, array() [, style [, x1, y1, x2, y2]]

Draws a chart of array values in the rectangular area x1,y1,x2,y2.
Styles: 0 = simple, 1 = with-marks, 2 = with ruler, 3 = with marks and
ruler.

    Const LINECHART = 1
    Const BARCHART = 2

    Const LINE_CHART = 1
    Const BAR_CHART  = 2
    demo = [1.5,2,3.5,4,5,6.5,7,8,9.5,10,11,12.5]
    Color 0, 15
    For type = LINE_CHART To BAR_CHART ' 1 to 2
      text = Iff(type = LINE_CHART, "LINE_CHART", "BAR_CHART")
      For style = 0 To 3
        Cls
        Print " Chart Type: "; type; " ("; text; ")"
        Print " Chart Style: "; style
        Print
        Print "Press any key...";
        Chart type, demo, style, 150, 150, 750, 550
        Pause
      Next style
    Next type

+========================================================================================+
|                                  86. (Graphics) CIRCLE                                 |
+========================================================================================+

CIRCLE [STEP] x,y,r [,aspect [, color]] [COLOR color] [FILLED]

Draws a circle (or an ellipse if the aspect is specified).


    ' Aspect ratio is relation between width-height of a circle,
    ' for example:
    ' aspect = 1   = Perfect circle;
    ' aspect = 1.5 = Stretch circle vertically (ellipse);
    ' aspect = 0.5 = Stretch circle horizontally (ellipse);
    ' let's draw perfect circles for the flower:
    Const ASPECT_RATIO = 1
    ' define parameters for main circle:
    Const CENTER = [150, 150] ' [x, y] define the center point to draw a circle
    Const RADIUS = 50         ' radius in pixels (pixel is a single point)
    Const TEXT = "Smile!"     ' text to print in the middle of main circle
    ' define parameters for leafs:
    Const LEAF_RADIUS = 30    ' using smaller circles for leafs
    ' center point for straight leafs (distance from main circle's center):
    Const LEAF_CENTER_STRAIGHT   = RADIUS + LEAF_RADIUS
    ' rotate center point for transverse leafs (distance as above):
    Const LEAF_CENTER_TRANSVERSE = LEAF_CENTER_STRAIGHT * Sin(Rad(45))
    ' Start the program:
    Print " Press any key to draw leaf by leaf...";
    Pause
    Cls
    ' draw one invisible point to set the 'current position':
    Pset CENTER Color 0
    ' let's use shorter variable names (easier to read):
    a = ASPECT_RATIO
    r = LEAF_RADIUS
    ' draw the straight leafs (relative to the 'current position'):
    c = LEAF_CENTER_STRAIGHT
    Circle Step 0, -c, r, a Color 15 FILLED: Pause ' top
    Circle Step 0, +c, r, a Color 14 FILLED: Pause ' down
    Circle Step -c, 0, r, a Color 13 FILLED: Pause ' left
    Circle Step +c, 0, r, a Color 12 FILLED: Pause ' right
    ' draw the transverse leafs (relative to the 'current position'):
    c = LEAF_CENTER_TRANSVERSE
    Circle Step -c, -c, r, a Color 11 FILLED: Pause ' top-left
    Circle Step +c, +c, r, a Color  8 FILLED: Pause ' down-right
    Circle Step +c, -c, r, a Color 10 FILLED: Pause ' top-right
    Circle Step -c, +c, r, a Color  9 FILLED: Pause ' down-left
    ' draw the main circle:
    Circle CENTER, RADIUS, ASPECT_RATIO Color 14
    ' print text in the middle of main circle:
    At CENTER(0) - (Txtw(TEXT) \\ 2), CENTER(1) - (Txth(TEXT) \\ 2)
    Color 15: Print TEXT;
    Pause


    'Another aspect or circle.bas  SmallBASIC 0.12.2 [B+=MGA] 2016-03-16
    'with aspect it is not the same old circle
    cx=xmax/2:cy=ymax/2:rface=250:reye=50:xle=cx-100:xre=cx+100:dir=1
    while 1
      cls
      circle cx,cy,rface,1,14 filled
      circle xle,cy,reye,1-a,9 filled
      circle xre,cy,reye,1-a,9 filled
      circle cx,cy+130-a*50,100+a*50,.21+2*a,12 filled
      circle cx,cy+100-a*50,100+a*50,.21+a,14 filled
      at 0,0 :?a
      showpage
      delay 1
      a+=.002*dir
      if a=.26 then dir=dir*-1
      if a=-.1 then dir=dir*-1
    wend

By default CIRCLE draws with anti-aliasing. For details, see: Fast,
Antialiased Circles and Ellipses

To turn off anti-aliasing, add this to the start of your program:

     option predef antialias off

+========================================================================================+
|                                   87. (Graphics) COLOR                                 |
+========================================================================================+

COLOR foreground-color [, background-color]

Specifies the foreground and background colors.


    Print "0 to 15 colors available for printing text..."
    Print
    For back = 0 To 7 Do
      text = back Xor 15 ' count down text color (15 to 8)
      
      Color text, back
      Print Using " text_, back COLOR ##, ## "; text, back;
      
      Color back, text ' reverse colors
      Print Using " text_, back COLOR ##, ## "; back, text
    Next
    Pause


    Print "Try color printing with some RGB shades"
    Print
    For shade = 0 To 10
      text = rgb(shade*25,0,0)
      back=rgb(255-shade*25,255-shade*25,255-shade*25)
      Color text, back
      Print "Here is black to red on white to black ";shade*25;",";255-25*shade
      
      Color back, text ' reverse colors
      Print "Here is reverse white to black  on black  to red."
      print
    Next
    Pause

Here is chart of the 16 QB colors and their numbers:


    'QB color chart of 16 colors for 0 = black to 15 = bright white
    dy=ymax/16
    for i=0 to 15
      rect 0,i*dy,xmax,i*dy+dy,i filled
      at 0,i*dy:? i;
    next
    pause

SmallBASIC recognizes two color Systems RGB(red,green,blue) and QB
colors 0-15 (3 systems if you count RGBF which is like RGB but instead
of 0-255 for each of red, green blue in RGB, the RGBF uses scale 0-1 for
each of red,green, blue). You may Include> “color_const.bas” file in
another file to make your code more clear.


    ' demo - add these lines to another BAS file:
    ' ------------------------------------------
    '  Include "color_const.bas" ' actuall filename must be lower case for Linux.
    '
    '  Circle 200, 200, 50, 1, YELLOW FILLED
    '  Color BRIGHT_MAGENTA, BLUE: ? "Bright Magenta on Blue"
    ' ------------------------------------------
    ' color_const.bas - COLOR values for characters and pixels:
    Const BLACK   = 0
    Const BLUE    = 1
    Const GREEN   = 2
    Const CYAN    = 3
    Const RED     = 4
    Const MAGENTA = 5
    Const BROWN   = 6
    Const WHITE   = 7
    Const GRAY    = 8
    Const BRIGHT_BLUE  = 9
    Const BRIGHT_GREEN = 10
    Const BRIGHT_CYAN  = 11
    Const BRIGHT_RED   = 12
    Const BRIGHT_MAGENTA = 13
    Const YELLOW       = 14
    Const BRIGHT_WHITE = 15

+========================================================================================+
|                                   88. (Graphics) DRAW                                  |
+========================================================================================+

DRAW \"commands\"

Draw lines as specified by the given directional commands.

_Graphics Definition Language_ In the movement instructions below, n
specifies a distance to move. The number of pixels moved is equal to n
multiplied by the current scaling factor, which is set by the S command.

  ----- --------------------------------------------------------------------------------------------------------------
  Un    Move up.
  Dn    Move down.
  Ln    Move left.
  Rn    Move right.
  En    Move diagonally up and right.
  Fn    Move diagonally down and right.
  Gn    Move diagonally down and left.
  Hn    Move diagonally up and left.
  Mxy   Move to coordinate x,y. If x is preceded by a + or -, the movement is relative to the last point referenced.
  B     A prefix command. Next movement command moves but doesn’t plot.
  N     A prefix command. Next movement command moves, but returns immediately to previous point.
  ----- --------------------------------------------------------------------------------------------------------------

    COLOR 9:PSET 80,80
    DRAW "R50D70L25U25L15D25NR15"
    DRAW "L10U50E25F25"
    PSET 118,105
    DRAW "R8U16L16D16R8U10NR8U6"
    COLOR 12:PSET 100,117
    INPUT "Who are you"; A$
    ? "Hello, ";A$;"!"

How does S command work? I just tried it in the DRAW example in first
DRAW string and I get error: “DRAW: Command ‘S’ unsupported.” This is
how S command work in QBASIC (quote):


    Sn  Determines the drawing scale by setting the length
         of a unit of cursor movement. The default n is 4,
         which is equivalent to 1 pixel.

So this should work just fine:


    DRAW "S8L10U50E25F25"

But apparently S command is unsupported.

+========================================================================================+
|                                 89. (Graphics) DRAWPOLY                                |
+========================================================================================+

DRAWPOLY array [,x-origin,y-origin [, scalef [, color]]] [COLOR color] [FILLED]
  [FILLED]

Draws a polyline.

If the array does not use points as element arrays, then even elements
for x (starting from 0), odd elements for y

+========================================================================================+
|                                   90. (Graphics) IMAGE                                 |
+========================================================================================+

IMAGE [#handle | fileName | http://path-to-file.png | image-var | array of pixmap data]
  array of pixmap data]

The IMAGE statement provides access to extended support for image
manipulation. There are two supported image formats: PNG and XPM (see
below).

Image access

Create via open file handle

    Open "circle.png" For Output As #1
    i = Image(#1)

Create via file name

    i = Image("circle.png")

Create via URL (note only works with HTTP not HTTPS)

    i = Image("http://pngimg.com/uploads/tesla_car/tesla_car_PNG26.png")

Create via screen scrape (x, y, width, height)

    i = Image(10, 10, 100, 100)

Create via another image variable

    k = Image(...)
    i = Image(k)

Create via 2D array

    dim a(100, 200)
    For y = 0 To Ubound(a, 1)
      For x = 0 To Ubound(a, 2)
        r += 5: g += 10: b += 15
        a(y, x) = rgb(r%255, g%255,b%255)
      Next
    Next
    i = Image(a)

Create via array of X_PixMap data

    im << "16 18 4 1"
    im << "@ c #547B43"
    im << "  c #ffffff"
    im << "+ c none"
    im << "x c #ff0000"
    im << "@@@@@@@+++++++++"
    im << "@    @++++++++++"
    im << "@   @+++++++++++"
    im << "@   @++@++++++++"
    im << "@    @@+++++++++"
    im << "@     @+++@+++++"
    im << "@     @++@@++++@"
    im << "@ xxx  @@  @++@@"
    im << "@  xxx    xx@@ @"
    im << "@   xxx  xxx   @"
    im << "@    xxxxxx    @"
    im << "@     xxxx     @"
    im << "@    xxxxxx    @"
    im << "@   xxx  xxx   @"
    im << "@  xxx    xxx  @"
    im << "@ xxx      xxx @"
    im << "@              @"
    im << "@@@@@@@@@@@@@@@@"
    i = Image(im)

Show command

zIndex controls whether the image will be displayed over or under
another image. Images with higher zIndex values are drawn over the top
of images with lower zIndex values. Opacity controls whether to display
the image as solid or semi-transparent. Opacity values range from 1-100,
with higher opacity values making the image less transparent. The
default is 100 resulting in a solid image.

    i.show([x,y [,zindex [,opacity]]])

Hide command

The hide command hides the image from display

     i.hide()

Save command

The save command saves the image data into the given file handle, file
name or array

    dim png
    i.save(png)

Clip command (console version only)

Reduces the size of the image.

    png.clip(left, top, right, bottom)

Filter command (console version only)

Calls the supplied callback function on each pixel

    func colorToAlpha(x)
      return x
    end
    png.filter(use colorToAlpha(x))

Paste command (console version only)

Paste the given image into this image at the given x, y location

    png2 = Image(w, h)
    png2.paste(png1, x, y)

Example 1

    Const CSI_EL = Chr(27) + "[K"  ' EL - Erase in Line (clear to end of line).
    Sub title(txt) 
      Locate 0, 0: Color 7, 0: ? CSI_EL; txt;
    End Sub

    ' Draw a demo image with text on screen:
    title("Draw a demo image")
    Pset 100, 100
    Circle Step 0, 0, 50 Color 7 Filled
    Circle Step 0, 0, 35 Color 1 Filled
    text = "Hello"
    At Point(0) - Txtw(text) \ 2, Point(1) - (Txth(".") \ 2)
    Color 14, 1: Print text;
    Pause

    title("Create image from screen")
    i = Image(50, 50, 102, 102)  ' Create image from screen (x, y, width, height)
    i.Show(350, 50)              ' Show the image at location (x, y)
    Pause
    title("Hide the image")
    i.Hide()                     ' Hide the image
    Pause

    title("Save the image to 2-D array (y, x) of pixels")
    i.Save(a)                    ' Save the image to 2-D array (y, x) of pixels
    i2 = Image(a)                ' Create a new image from the 2-D array
    i2.Show(200, 90)             ' Show the new image at location (x, y)
    Pause

    title("Modify the colors of the 2-D array (y, x)")
    For y = 0 To Ubound(a, 1)    ' Modify the colors of the 2-D array (y, x)
      For x = 0 To Ubound(a, 2)
        a(y, x) += 100
      Next
    Next
    i2 = Image(a)                ' Create a new image from the modified 2-D array
    i2.Show(350, 50)             ' Show the new image at location (x, y)
    Pause

    title("Copy the top-left of the 2-D array (y, x)")
    half_y = Ubound(a, 1) / 2    ' Copy the top-left of the 2-D array (y, x)
    half_x = Ubound(a, 2) / 2
    Dim a2(half_y, half_x)
    For y = 0 To half_y
      For x = 0 To half_x
        a2(y, x) = a(y, x)
      Next
    Next
    i2 = Image(a2)               ' Create a new image from the top-left 2-D array
    i2.Show(200, 90)             ' Show the new image at location (x, y)
    Pause

    ' Note: 'zindex' is probably order of layers - above/under other image(s).
    title("Show original image using zindex & opacity")
    i.Show(400, 100, 1, 50)      ' Show original image (x, y, zindex, opacity)
    Pause
    i3 = Image(i)                ' Create a new image from original image
    i3.Show(440, 130, 0)         ' Show the new image (x, y, zindex)
    Pause

    ' Note: file name is case sensitive on Linux.
    title("Save & Load original image as a PNG file")
    Open "circle.png" For Output As #1
    i.Save(#1)                   ' Save original image as a PNG file
    Close #1
    Open "circle.png" For Input As #1
    i4 = Image(#1)               ' Load image from a PNG file
    Close #1
    i4.Show(600, 20)             ' Show loaded image (x, y)
    Pause

Example 2


    ' Notes: 
    ' 1. Using POINT and PSET is a much slower option then using:
    '    i = IMAGE(x, y, width, height) and i.Show(x, y) - (See Part-1).
    '
        ' 2. The 2-D array that holds the image, a(y, x), must be equilateral, e.g.
    '    a(2 To 6, 1 To 5), etc; Using a(1 To 5, 1 To 6), for example, is wrong.
    '
    ' 3. It's possible to use POINT or RGB commands (alpha is not supported 
    '    in this case) to create the 2-D array that holds the image, a(y, x).

    Const CSI_EL = Chr(27) + "[K"  ' EL - Erase in Line (clear to end of line).
    Sub title(txt) 
      Locate 0, 0: Color 7, 0: ? CSI_EL; txt;
    End Sub

    ' Draw a demo image with text on screen:
    title("Draw a demo image")
    Pset 100, 100
    Circle Step 0, 0, 50 Color 7 Filled
    Circle Step 0, 0, 35 Color 1 Filled
    text = "Hello"
    At Point(0) - Txtw(text) \ 2, Point(1) - (Txth(".") \ 2)
    Color 14, 1: Print text;
    Pause

    title("Create 2-D image array from screen using POINT")
    Dim a(49 To 152, 48 To 151)  ' Create 2-D image array from screen using POINT
    For y = 49 To 152
      For x = 48 To 151
        a(y, x) = Point(x, y) 
      Next
    Next
    Pause

    title("Show the 2-D array (slow) using PSET")
    For y = 49 To 152            ' Show the 2-D array (slow) using PSET
      For x = 48 To 151
        Pset x + 150, y + 85, a(y, x) 
      Next
    Next
    Pause

    title("Show the image (fast) using SHOW")
    i = Image(a)                 ' Convert the 2-D array (y, x) of pixels to image
    i.Show(350, 230)             ' Show the image (fast) at location (x, y)
    Pause

Example 3


    ' Notes:
    ' 1. You may load an existing XPM image file, the same way you load PNG image
    '    file; Or you may store the XPM data within the source code (DATA keyword
    '    can help with this...).
    '
    ' 2. XPM is a text image file, as opposed to PNG which is a binary image file.
    '    XPM supports high quality images, for more details and options see: 
    '    https://en.wikipedia.org/wiki/X_PixMap

    ' In this example we use the simple and handy XPM2 format (as opposed to the 
    ' latter and more standard C format, XPM3);
    ' Create the XPM image array:
    ' a << "! XPM2"     ' (We Don't use this header line in SmallBASIC 0.12.6)
    a << "110 200 3 1"  ' Width=110, Height=200, Colors=3, Character-Per-Pixel=1
    a << "a c #FF0000"  ' Character "a" is RGB(0xFF, 0x00, 0x00) - RED
    a << "b c NONE"     ' Character "b" is transparency color (NONE)
    a << "c c #0000FF"  ' Character "c" is RGB(0x00, 0x00, 0xFF) - BLUE
    For i = 1 To 200    ' Create an image of exactly 110x200 (x,y) pixels
      a << String(30, "a") + String(50, "b") + String(30, "c")
    Next i
    Color 1, 7: Cls
    i = Image(a)                 ' Convert the XPM array to image
    i.Show(150, 50)              ' Show the image at location (x, y)
    At 150 - 100, 50 - 30 
    Print "This is XPM image with transparency!"
    Pause

    ' More about XPM2 - from https://en.wikipedia.org/wiki/X_PixMap:
    ' --------------------------------------------------------------
    ' XPM2 simplifies the format by removing all C codes. An example:
    ' ! XPM2
    ' 48 4 2 1
    ' a c #FFFFFF
    ' b c #000000
    ' abaabaababaaabaabababaabaabaababaabaaababaabaaab
    ' abaabaababaaabaabababaabaabaababaabaaababaabaaab
    ' abaabaababaaabaabababaabaabaababaabaaababaabaaab
    ' abaabaababaaabaabababaabaabaababaabaaababaabaaab
    ' This is an XPM2 file with width 48, height 4, 2 colors, and 1 character per
    ' pixel.
    ' One tool is known to use only a to p for 16 colors, switching to aa up to dp
    ' for 64 colors, but still reading single character encodings for 64 colors;
    ' compare Base64.
    '
    ' With more colors the codes use more characters, e.g. aa up to pp for
    ' 16 x 16 = 256 colors. This is less useful for text editors, because a string
    ' ab could be actually the middle of two adjacent pixels dabc.
    ' Spaces are allowed as color code, but might be a bad idea depending on the
    ' used text editor.
    ' Without control codes, space, and quote (needed in XPM1 and XPM3)
    ' 128 - 33 - 2 = 93 ASCII characters are available for single character color
    ' codes.
    '
    ' Simplified example: 90 US-ASCII characters could be arranged into nine 
    ' non-overlapping sets of 10 characters. Thus unambiguous strings of nine 
    ' characters could set the color of each pixel by its XPM palette index with 
    ' up to 109 = 1000000000 colors (compare to GIF, which supports only 256).
    ' For XPM2 it is clear how many lines belong to the image - two header lines, 
    ' the second header line announcing the number of color codes (2 lines in the 
    ' example above) and rows (height 4 in the example above), 
    ' e.g. 2 + 2 + 4 = 8 lines.

Example 4


    Color 7, 1: Cls              ' (for recognizing transparency color)
    ' --- [1]
    Restore Demo_XPM_Image       ' Create a demo XPM image array
    For i = 1 To 12
      Read s
      a << s
    Next i
    i = Image(a)                 ' Convert the XPM array to image
    i.Show(10, 10)               ' [1] Show the image at location (x, y)
    Open "SB.png" For Output As #1
      i.Save(#1)                 ' Save XPM image as a PNG file
    Close #1

    ' --- [2]
    i = Image("SB.png")          ' Load image from PNG file, using a "file name"
    i.Show(30, 30)               ' [2] Show loaded image (x, y)

    ' --- [3]
    Open "SB.png" For Input As #1
      i = Image(#1)              ' Load image from PNG file, using a file number
    Close #1
    i.Show(50, 50)               ' [3] Show loaded image (x, y)

    ' --- [4]
    Open "SB.png" For Input As #1  ' Load image from PNG file into 1-D array of
      l = Lof(1)                   '  PNG byte data (integers)
      Dim a(1 To l)                ' (It's much faster to allocate space first)
      For i = 1 To l Do a(i) = Bgetc(1)
    Close #1
    i = Image(a)                 ' Create an image from the 1-D array
    i.Show(80, 80)               ' [4] Show loaded image (x, y)

    ' --- [5]
    Import Base64                ' (See Base64 Encoder/Decoder UNIT above, or
                                 '  in: Home -- Code library -- Units section)
    Restore Base64_encoded_PNG   ' Load image from Base64 encoded PNG data
    s = ""                       '  into 1-D array of PNG byte data (integers)
    For i = 1 To 3
      Read d
      s += d
    Next i
    a = base64.Decode_Base64(s)  ' Decode Base64 PNG string to 1-D array
    i = Image(a)                 ' Create an image from the 1-D array
    i.Show(100, 100)             ' [5] Show loaded image (x, y)

    ' --- [6]
    Restore Demo_XPM_Image       ' Save XPM image array as XPM file
    Dim a(1 To 12)
    For i = 1 To 12 Do Read a(i)
    Tsave "SB.xpm", a
    Tload "SB.xpm", a2           ' Load image from XPM file into array of strings
    i = Image(a2)                ' Convert the XPM array to image
    i.Show(120, 120)             ' [6] Show loaded image (x, y)

    ' --- [7]
    Open "http://smallbasic.sourceforge.net/images/logo.png" For Input As #1
      i = Image(#1)              ' Load PNG image from web (you must be on-line)
    Close #1
    i.Show(150, 150)             ' [7] Show loaded image (x, y)

    Pause
    End

    ' Note: you may use the Base64 Encoder/Decoder UNIT above to convert PNG file
    '       into Base64 encoded string (large file takes time to convert!).
    '       It allows you to store the PNG file within the source code.
    Label Base64_encoded_PNG  ' (With transparency color)
    Data "iVBORw0KGgoAAAANSUhEUgAAABUAAAAJAQAAAAD1eFrbAAAAAnRSTlMAAHaTzTgAAAA"
    Data "oSURBVHgBHcdBAQAwDMJA6qI/LLSOkDU5kzZYXhck8mKPMK3vsvOxe3i6Bu6pAW2gAA"
    Data "AAAElFTkSuQmCC"

    Label Demo_XPM_Image
    Data "21 9 2 1"     ' Width=21, Height=9, Colors=2, Character-Per-Pixel=1
    Data ". c NONE"     ' Character "." is transparency color (known as "NONE")
    Data "o c #FFFFFF"  ' Character "o" is RGB(0xFF, 0xFF, 0xFF) - WHITE
    Data "....................."
    Data "...ooooo...ooooooo..."
    Data "..oo...oo..oo....oo.."
    Data "..oo.......oo....oo.."
    Data "...ooooo...ooooooo..."
    Data ".......oo..oo....oo.."
    Data "..oo...oo..oo....oo.."
    Data "...ooooo...ooooooo..."
    Data "....................."

Example 5


    ' Dedicated to johnno56

    Const CSI_EL = Chr(27) + "[K"  ' EL - Erase in Line (clear to end of line).
    Sub title(txt)
      Locate 0, 0: Color 7, 0: ? CSI_EL; txt;
    End Sub

    ' Draw a demo image with text on screen:
    title("Draw a demo image")
    Pset 100, 100
    Circle Step 0, 0, 50 Color 7 Filled
    Circle Step 0, 0, 35 Color 1 Filled
    text = "Hello"
    At Point(0) - Txtw(text) \ 2, Point(1) - (Txth(".") \ 2)
    Color 14, 1: Print text;
    Pause

    i = Image(50, 50, 102, 102)  ' Create image from screen (x, y, width, height)
    Color 7, 0: Cls              ' Erase the demo image.

    ' Note:
    ' 1. zIndex parameter is used for the IMAGE sub-command SHOW, its syntax is:
    '    SHOW([x,y [,zindex [,opacity]]])
    '
    ' 2. 'zindex' is the order of layers, i.e. under or above other image layers.
    '    I'm not aware of any limits for how many image layers can be used.
    '
    ' 3. Using 'zindex' is simple, for example: layer 0 is above layer -1;
    '    layer -8 is below layer -7; layer 11 is above layer 10; etc.

    ' In this example we show 9 images on different layers:
    Dim i2(1 To 9)
    For layer = 1 To 9
      i2(layer) = Image(i)   ' Copy the demo image to new image
      t = i2(layer)          ' Use temporay variable to hold image (for Show)
      ' Change the 'x' and 'y' properties of t image:
      t.x = 50 + layer * 35
      t.y = 50 + layer * 25
      At t.x + 100, t.y: Color 7, 0  ' (for display text info)
      ' Change the 'zIndex' property of t image:
      Select Case layer
      Case 1: t.zIndex =  0  : ? " Using layer # 0"
      Case 2: t.zIndex = -2  : ? " Using layer # -2 (below layer -1)";
      Case 3: t.zIndex = -1  : ? " Using layer # -1 (below layer 0)";
      Case 4: t.zIndex =  3  : ? " Using layer # 3  (above layer 2)";
      Case 5: t.zIndex =  2  : ? " Using layer # 2  (above layer 1)";
      Case 6: t.zIndex = -9  : ? " Using layer # -9 (below layer -8)";
      Case 7: t.zIndex = -7  : ? " Using layer # -7 (below layer -6)";
      Case 8: t.zIndex = -3  : ? " Using layer # -3 (below layer -2)";
      Case 9: t.zIndex =  4  : ? " Using layer # 4  (above layer 3)";
      End Select
      title("IMAGE # " + layer + ": " + Str(t))  ' Print image properties
      t.Show()   ' Show image (x, y, zindex)
      Pause
    Next layer

Base64 decoder for example 4


    REM Purpose:   A Base64 Encoder/Decoder UNIT.
    REM File name: base64.bas
    REM Unit name: base64
    REM Version:   1.0.1  21/05/2016
    REM Author:    Christian d'Heureuse; shian (See License below)

    ' Notes:
    ' 1. Translated from VBasic to SmallBASIC (shian).
    '
    ' 2. Useful for IMAGE keyword, and for any binary-to-text encoding/decoding.
    '    Base64 is often used to embed binary data in source code.
    '
    ' 3. Since this is a translated code, I did not add much comments about the
    '    encoding/decoding method... So for more details about it see:
    '    https://en.wikipedia.org/wiki/Base64
    '
    ' 4. License:
    '    - A Base64 Encoder/Decoder. This module is used to encode and decode data
    '      in Base64 format as described in RFC 1521.
    '    - Home page: www.source-code.biz.
    '    - Code from: http://www.source-code.biz/snippets/vbasic/12.htm
    '    - License: GNU/LGPL (www.gnu.org/licenses/lgpl.html).
    '    - Copyright 2007: Christian d'Heureuse, Inventec Informatik AG, Switzerland.
    '    - This module is provided "as is" without warranty of any kind.
    '

    ' -- Start Demo code --- --- --- --- --- --- --- --- --- --- ---
    '
    ' Import base64                  ' (Import from another .bas file)
    '
    ' Const FILE = "SB.png"          ' (Change it to any other file name)
    '
    ' ' Example using a "file name":
    ' s = base64.Encode_Base64(FILE) ' Encode 1-D bytes-array to Base64-string
    ' a = base64.Decode_Base64(s)    ' Decode Base64-string to 1-D bytes-array
    '
    ' i = Image(a)                   ' Convert 1-D bytes-array to image
    ' i.Show(10, 10)                 ' Show image at location (x, y)
    ' Showpage
    '
    ' ' Example using a file # (opened for input):
    ' Open FILE For Input As #1
    ' s = base64.Encode_Base64(1)    ' Encode 1-D bytes-array to Base64-string
    ' Close #1
    ' a = base64.Decode_Base64(s)    ' Decode Base64-string to 1-D bytes-array
    '
    ' i = Image(a)                   ' Convert 1-D bytes-array to image
    ' i.Show(30, 30)                 ' Show image at location (x, y)
    ' Showpage
    '
    ' ' Example using 1-D bytes-array (a):
    ' s = base64.Encode_Base64(a)    ' Encode 1-D bytes-array to Base64-string
    ' a = base64.Decode_Base64(s)    ' Decode Base64-string to 1-D bytes-array
    '
    ' i = Image(a)                   ' Convert 1-D bytes-array to image
    ' i.Show(50, 50)                 ' Show image at location (x, y)
    ' Showpage
    '
    ' Pause
    '
    ' -- End Demo code --- --- --- --- --- --- --- --- --- --- --- ---

    Unit base64
    Export Encode_Base64, Decode_Base64

    ' Initialize the helper maps (this code executes only once at load time).
    Dim Map1(0 To 63)
    Dim Map2(0 To 127)
    i = 0
    ' Set Map1
    For c = 65  To  90: Map1(i) = c: i++: Next  ' Asc("A") To Asc("Z")
    For c = 97  To 122: Map1(i) = c: i++: Next  ' Asc("a") To Asc("z")
    For c = 48  To  57: Map1(i) = c: i++: Next  ' Asc("0") To Asc("9")
    Map1(i) = 43 : i++  ' Asc("+")
    Map1(i) = 47 : i++  ' Asc("/")
    ' Set Map2
    For i = 0 To 127 Do Map2(i) = 255
    For i = 0 To  63 Do Map2(Map1(i)) = i

    ' Encodes a 1-D bytes array (integers) into Base64 format string.
    ' No blanks or line breaks are inserted.
    ' Parameters:
    '   InData    1-D bytes array containing the data bytes to be encoded;
    '             or, "File_Name" string to load into 1-D bytes array;
    '             or, File-Number (opened-for-input) to load into 1-D bytes array.
    ' Returns:    a string with the Base64 encoded data (that you can embed in
    '             your source code).
    Func Encode_Base64(InData)
      Local Out                   ' (As Byte)
      Local ODataLen, OLen, ILen  ' (As Long)
      Local ip0, ip, op           ' (As Long)
      Local i0, i1, i2            ' (As Byte)
      Local o0, o1, o2, o3        ' (As Byte)
      Local s, i, fn, f           ' as SmallBASIC...

      If Isarray(InData) Then     ' 1-D bytes array (integers) supplied
        ILen = Len(InData)
      ' Make life easier by loading 1-D bytes array from file:
      Else
        f = Isnumber(InData)      ' Set flag to close file
        If f Then                 ' An opened file # (For Input) supplied
          fn = InData
        Else                      ' A "filename" supplied
          fn = Freefile
          Open InData For Input As #fn
        Fi
        ILen = Lof(fn)
        Dim InData(1 To ILen)     ' (It's much faster to allocate space first!)
        For i = 1 To ILen Do InData(i) = Bgetc(fn)
        If Not f Then Close #fn   ' (Don't close file if File # supplied)
      Fi

      If ILen = 0 Then Encode_Base64 = "": Exit Func
      ODataLen = (ILen * 4 + 2) \ 3   ' Output length without padding
      OLen = ((ILen + 2) \ 3) * 4     ' Output length including padding
      Dim Out(0 To OLen - 1)
      ip0 = LBound(InData)
      ' Encode base64 bytes array (See Wikipedia for this...):
      While ip < ILen
        i0 = InData(ip0 + ip): ip++
        If ip < ILen Then i1 = InData(ip0 + ip): ip++ Else i1 = 0
        If ip < ILen Then i2 = InData(ip0 + ip): ip++ Else i2 = 0
        o0 = i0 \ 4
        o1 = ((i0 Band 3) * 0x10) Bor (i1 \ 0x10)
        o2 = ((i1 Band 0xF) * 4)  Bor (i2 \ 0x40)
        o3 = i2 Band 0x3F
        Out(op) = Map1(o0): op++
        Out(op) = Map1(o1): op++
        Out(op) = Iff(op < ODataLen, Map1(o2), 61): op++  ' 61 is Asc("=")
        Out(op) = Iff(op < ODataLen, Map1(o3), 61): op++  ' 61 is Asc("=")
      Wend
      s = "": For i In Out Do s += Chr(i)  ' Bytes-to-String
      Encode_Base64 = s
    End Func

    ' Decodes a string from Base64 format.
    ' Parameters
    '   s         a Base64 String to be decoded.
    ' Returns:    a 1-D array containing the decoded data bytes (integers).
    Func Decode_Base64(s)
      Local IBuf, Out       ' (As Byte array)
      Local i0, i1, i2, i3  ' (As Byte)
      Local b0, b1, b2, b3  ' (As Byte)
      Local o0, o1, o2      ' (As Byte)
      Local OLen, ip, op    ' (As Long)
      Local ILen = Len(s)   ' (As Long)
      Local i               ' as SmallBASIC...
      If (ILen Mod 4) Or (ILen = 0) Then  ' Data error
        Throw "Length of Base64 encoded input string is not a multiple of 4."
      Fi
      Dim IBuf(0 To ILen - 1)
      For i = 1 To ILen Do IBuf(i - 1) = Asc(Mid(s, i, 1))  ' String-to-Bytes
      While ILen > 0
        If IBuf(ILen - 1) <> 61 Then Exit Loop  ' 61 is Asc("=")
        ILen--
      Wend
      OLen = (ILen * 3) \ 4
      Dim Out(0 To OLen - 1)  ' 1-D bytes array
      ' Decode base64 bytes array (See Wikipedia for this...):
      While ip < ILen
        i0 = IBuf(ip): ip++
        i1 = IBuf(ip): ip++
        If ip < ILen Then i2 = IBuf(ip): ip++ Else i2 = 65  ' 65 is Asc("A")
        If ip < ILen Then i3 = IBuf(ip): ip++ Else i3 = 65  ' 65 is Asc("A")
        If i0 > 127 Or i1 > 127 Or i2 > 127 Or i3 > 127 Then
          Throw "Illegal character in Base64 encoded data."  ' Data error
        Fi
        b0 = Map2(i0)
        b1 = Map2(i1)
        b2 = Map2(i2)
        b3 = Map2(i3)
        If b0 > 63 Or b1 > 63 Or b2 > 63 Or b3 > 63 Then
          Throw "Illegal character in Base64 encoded data."  ' Data error
        Fi
        o0 = (b0 * 4) Bor (b1 \ 0x10)
        o1 = ((b1 Band 0xF) * 0x10) Bor (b2 \ 4)
        o2 = ((b2 Band 3) * 0x40) Bor b3
        Out(op) = o0: op++
        If op < OLen Then Out(op) = o1: op++
        If op < OLen Then Out(op) = o2: op++
      Wend
      Decode_Base64 = Out
    End Func

You may create a PNG image + transparency color with an external image
editor, and then you may also decode it as a Base64 PNG string (to store
it within the source code). Another useful option is to use XPM image
format (See Part-3 above) with transparency color, instead of color
number you just write NONE, like this:

    a << "x c NONE"  ' Character "x" is transparency color

Console version example

The following creates a plist file and composite sprite sheet which can
be used with cocos2d development

    const backgnd = 0xFF5A5D39
    const shadow = 0xFF080c08

    const alpha = 0x5a5d39
    const alphaShadow = 0x80080c08

    dim tileset
    tileset << ["eating e0000.png",       13]
    tileset << ["eating n0000.png",       13]
    tileset << ["eating ne0000.png",      13]
    tileset << ["eating nw0000.png",      13]
    tileset << ["eating s0000.png",       13]
    tileset << ["eating se0000.png",      13]
    tileset << ["eating sw0000.png",      13]
    tileset << ["eating w0000.png",       13]
    tileset << ["headshaking e0000.png",  11]
    tileset << ["headshaking n0000.png",  11]
    tileset << ["headshaking ne0000.png", 11]
    tileset << ["headshaking nw0000.png", 11]
    tileset << ["headshaking s0000.png",  11]
    tileset << ["headshaking se0000.png", 11]
    tileset << ["headshaking sw0000.png", 11]
    tileset << ["headshaking w0000.png",  11]
    tileset << ["running e0000.png",      11]
    tileset << ["running n0000.png",      11]
    tileset << ["running ne0000.png",     11]
    tileset << ["running nw0000.png",     11]
    tileset << ["running s0000.png",      11]
    tileset << ["running se0000.png",     11]
    tileset << ["running sw0000.png",     11]
    tileset << ["running w0000.png",      11]
    tileset << ["stopped0000.png",         7]
    tileset << ["walking e0000.png",      11]
    tileset << ["walking n0000.png",      11]
    tileset << ["walking ne0000.png",     11]
    tileset << ["walking nw0000.png",     11]
    tileset << ["walking s0000.png",      11]
    tileset << ["walking se0000.png",     11]
    tileset << ["walking sw0000.png",     11]
    tileset << ["walking w0000.png",      11]

    func colorToAlpha(x)
      if (x == backgnd) then return alpha
      if (x == shadow) then return alphaShadow
      return x
    end

    sub print_include()
      local j, pattern, count, out, varname
      out << "#pragma once"
      for j = 0 to len(tileset) - 1
        x = 0
        y = 0
        [pattern, count] = tileset[j]
        varname = translate(pattern, "0000.png", "")
        varname = translate(varname, " ", "_")
        varname = upper(varname)
        pattern = translate(pattern, "0000", "%04d")
        out << "const char *" + varname + "_PNG = \"" + pattern + "\";"
        out << "const int   " + varname + "_PNG_SIZE = " + count + ";"
      next j
      tsave "Classes/horse.h", out
    end

    sub print_plist(byref images)
      local plist, i

      dim plist
      plist << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"
      plist << "<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">"
      plist << "<plist version=\"1.0\">"
      plist << "<dict>"
      plist << "  <key>texture</key>"
      plist << "    <dict>"
      plist << "      <key>width</key>"
      plist << "      <integer>" + w + "</integer>"
      plist << "      <key>height</key>"
      plist << "      <integer>" + h + "</integer>"
      plist << "    </dict>"
      plist << "    <key>frames</key>"
      plist << "    <dict>"
      for i = 0 to len(images) - 1
        png = images[i]
        plist << "      <key>" + png.name + "</key>"
        plist << "      <dict>"
        plist << "        <key>x</key>"
        plist << "        <integer>" + png.x + "</integer>"
        plist << "        <key>y</key>"
        plist << "        <integer>" + png.y + "</integer>"
        plist << "        <key>width</key>"
        plist << "        <integer>" + png.width + "</integer>"
        plist << "        <key>height</key>"
        plist << "        <integer>" + png.height + "</integer>"
        plist << "        <key>offsetX</key>"
        plist << "        <real>0</real>"
        plist << "        <key>offsetY</key>"
        plist << "        <real>0</real>"
        plist << "        <key>originalWidth</key>"
        plist << "        <integer>" + png.width + "</integer>"
        plist << "        <key>originalHeight</key>"
        plist << "        <integer>" + png.height + "</integer>"
        plist << "      </dict>"
      next i
      plist << "    </dict>"
      plist << "  </dict>
      plist << "</plist>
      tsave "Resources/horse.plist", plist
      tsave "linux-build/bin/Debug/MobileCup/Resources/horse.plist", plist
    end

    sub main(byref tileset)
      local i, j, x, y, pattern, count, images, composite, width, height
      dim images

      width = 0
      height = 0

      for j = 0 to len(tileset) - 1
        x = 0
        y = 0
        [pattern, count] = tileset[j]
        for i = 0 to count
          png = image("images/horse/" + format(pattern, i))
          png.clip(5, 5, 5, 5)
          png.filter(use colorToAlpha(x))
          png.name = format(pattern, i)
          png.x = x
          png.y = height
          x += png.width + 1
          y = iff(png.height > y, png.height, y)
          images << png
        next i
        width = iff(x > width, x, width)
        height += y
      next j

      composite = image(width, height)
      for i = 0 to len(images) - 1
        png = images[i]
        composite.paste(png, png.x, png.y)
      next i

      composite.save("Resources/horse.png")
      composite.save("linux-build/bin/Debug/MobileCup/Resources/horse.png")
      print_plist(images)
      print_include()
    end

    main(tileset)

+========================================================================================+
|                                   91. (Graphics) LINE                                  |
+========================================================================================+

LINE [STEP] x,y [,|STEP x2,y2] [, color| COLOR color]

Draws a line.

Example:

    line 20,40,140,40 color 2
    line 20,80,140,80 color 2
    line 60,0,60,120 color 2
    line 100,0,100,120 color 2

By default LINE draws with anti-aliasing. For details, see: Xiaolin Wu’s
line algorithm

To turn off anti-aliasing, add this to the start of your program:

     option predef antialias off

+========================================================================================+
|                                   92. (Graphics) PAINT                                 |
+========================================================================================+

PAINT [STEP] x, y [,fill-color [,border-color]]

Fills an enclosed area on the graphics screen with a specific color. x,y
= Screen coordinate (column, row) within the area that is to be filled.

If border-color is specified then PAINT will fill outwards until is
meets the specified border-color - (fill-until, color!=point(x,y)) If
the border-color is NOT specified then PAINT will fill the area with the
same color as the pixel at x,y - (fill-while, color=point(x,y))

+========================================================================================+
|                                    93. (Graphics) PEN                                  |
+========================================================================================+

PEN (0..14)

Returns the PEN/MOUSE data.

Values:

  --- ----------------------------------------------------------------------------------------------------------------
  0   True (non zero) if there is a new pen or mouse event
  1   PEN: last pen down x; MOUSE: last mouse button down x
  2   Same as 1 for y
  3   True if the PEN is down; MOUSE: mouse left button is pressed
  4   PEN: last/current x, MOUSE: the current x position only if the left mouse button is pressed (like PEN is down)
  5   PEN(4) for y
  --- ----------------------------------------------------------------------------------------------------------------

Mouse specific:

  ---- --------------------------------------------
  10   current mouse x pos
  11   current mouse y pos
  12   true if the left mouse button is pressed
  13   true if the right mouse button is pressed
  14   true if the middle mouse button is pressed
  ---- --------------------------------------------

PEN must be enabled prior to use of this function. Pen ON|OFF

    Print "  Move and click the Pen or Mouse [press Esc to stop]..."
    Print
    Pen On
    Print Using " ####x, ####y"; ' format for x,y position
    While Inkey <> Chr(27) Do ' press Esc key to exit loop
      Locate 3, 0
      ? "Pen|Mouse new event:  "; Pen(0)
      ?
      ? "Pen last down|Mouse down:";: ? Usg; Pen(1), Pen(2)
      ?
      ? "Pen down|Mouse Left down:  "; Pen(3)
      ?
      ? "Pen last/current|Mouse Left down:";: ? Usg; Pen(4), Pen(5)
      ?
      ? "Mouse current:";: ? Usg; Pen(10), Pen(11)
      ?
      ? "Mouse Left,Middle,Right down: ", Pen(12), Pen(14), Pen(13);
    Wend

DELAY say 20 ms saves CPU and battery in a loop like the above reply. It
also helps after a mouse click to not over report the same click again
and again.


    rem game loop example
    pen on
    quit=0
    x = pen(4)
    y = pen(5)
    repeat
      if pen(0) then
        rem mouse down - get click coordinates
        x = pen(1)
        y = pen(2)
        logprint "pointer down: x=" + x + " y=" + y
        rem process more events until mouse is released
        mouse_down = true
        while mouse_down
          n = pen(0)
          x_down = pen(4)
          y_down = pen(5)
          if (x_down != -1 && y_down != -1) then
            x = x_down
            y = y_down
            logprint "pointer moved [down]: x=" + x + " y=" + y
          else
            mouse_down = false
          end if
        wend
        logprint "pointer up: x=" + x + " y=" + y
      else
        if (x != pen(4) && x != pen(5)) then
          x = pen(4)
          y = pen(5)
          logprint "pointer moved [up]: x=" + x + " y=" + y
        else
          rem other system event, most likely a keypress
          k = inkey
          if (k > 0) then
            logprint "key event: k=" + k
            if (len(k)=1 and asc(k)=27) or k="q" then quit=1
          end if
        end if
      end if
    until quit
    pen off

+========================================================================================+
|                                   94. (Graphics) PLOT                                  |
+========================================================================================+

PLOT xmin, xmax USE f(x)

Graph of f(x).

PLOT 0, 2*PI USE SIN(x)

Apparently we are now plotting with black dots as default on default
black background, so need a COLOR call to see the dots.


    'plot test.bas from SmallBASIC ie PLOT minx, maxx, use f(x)
    color 0,15:cls  '<=========== plot use to work without need for this
    PLOT 0, 2*PI USE SIN(x)
    PLOT 0, 2*PI USE rnd*sin(x) '<==== this is cool!
    pause

+========================================================================================+
|                                   95. (Graphics) POINT                                 |
+========================================================================================+

POINT (x [, y])

Returns the color of the pixel at x,y.

If the y argument is not specified, x specifies the following info-code:
0 = returns the current X graphics position 1 = returns the current Y
graphics position

This demonstrates saving a screen section and redrawing it at different
places on screen, a tiling and a moving across the screen.


    ' POINT demo.bas  SmallBASIC 0.12.2 [B+=MGA] 2016-03-07
    for objects = 1 to 300
      if rnd>.5 then
        circle rnd*xmax\\1, rnd*ymax\\1, rnd*50\\1, rnd*5, rnd*16/1 
      else
        rect rnd*xmax\\1, rnd*ymax\\1 step rnd*50\\1, rnd*50\\1, rnd*16/1
      end if  
    next
    at 0,ymax-2*txth("Q"):?" press any..."
    showpage
    pause
    xw=350:yh=250
    bottle 0,0,xw,yh
    cls
    for y=0 to ymax step yh
      for x=0 to xmax step xw
        pour x,y,xw,yh
        showpage
      next
    next
    at 0,ymax-2*txth("Q"):?" press any..."
    showpage
    pause
    cls
    for x=0 to xmax step 25
      cls
      pour x,ymax\\2-yh\\2,xw,yh
      showpage
      delay 10
    next
    at 0,ymax-2*txth("Q"):?"done, press any... "
    showpage
    pause 
    sub bottle(xleft,ytop,xwidth,yheight)
      local x,y
      dim screensection(xwidth,yheight)
      for y=ytop to (ytop+yheight-1)
        for x=xleft to (xleft+xwidth-1)
          screensection(x,y)=POINT(x,y)
        next
      next
    end
    sub pour(xoff,yoff,xwidth,yheight)
      local x,y
      for y=0 to yheight
        for x=0 to xwidth
          colr=screensection(x,y)
          pset x+xoff,y+yoff,colr
        next
      next
    end 


    ' Note: POINT(x, y) returns the color of the pixel at x,y. But it's
    '       also possible to use POINT(0) and POINT(1) to return the current
    '       X,Y graphics position...:

    ' Draw a little circle at the current graphics x,y position:
    Sub show_point
      Local x = Point(0) ' This is where the last graphics command left us...
      Local y = Point(1)
      Local c
      c = Point(x, y)    ' Now we know also the color of that point...
      Circle x, y, 3 Color c FILLED ' (CIRCLE does not change current X,Y)
    End Sub

    ' Draw a box and show the corners with a circle:
    Line 50, 50, 360, 50 Color 15:     show_point
    Line STEP 0, +40 Color 14:         show_point
    Line STEP -(360 - 50), 0 Color 15: show_point
    Line STEP 0, -40 Color 14:         show_point
    Showpage

    ' Print text inside the box and change its colors:
    x = Point(0) + 45
    y = Point(1) + 8
    text = "That's the POINT !"
    x_dot = x + Txtw(text) - 6
    y_dot = y + Txth(text) - 5
    For b = 7 To 1 Step -1   ' b = Background color
      c = b Xor (16 - b)     ' c = Reversed Foreground color
      Color c, b: At x, y: Print "That's the POINT !"
      Circle x_dot, y_dot, 3 Color c FILLED ' Print a point under '!'
      Paint x - 2, y - 2, b  ' Paint the rest of the box
      Pause 1
      Showpage
    Next
    Pause

+========================================================================================+
|                                   96. (Graphics) PSET                                  |
+========================================================================================+

PSET [STEP] x,y [, color| COLOR color]

Draw a pixel.


    cx=xmax/2  'center x, xmax is built in constant that returns the screen width
    cy=ymax/2  'center y, ymax is built in constant that returns the screen height
    MyColor=RGB(255,128,0)  'orange?
    PSET cx,cy,MyColor   'draws an orange pixel at center of screen

(see also STEP that works off the last x,y graphic call) for instance
now that one graphic call is made, we can draw a point 50 pixels
directly to the right using STEP PSET STEP 50,0,MyColor Without a color
specified in 3rd argument PSET will use foreground from last COLOR
foreground, background statement. IF that had never been used it will
default to screen printing colors 7,0 (QB scale) for Colors see RGB,
RGBF, and … hmmm do we have a QB color sampler? Here is QB color chart:


    'QB color chart of 16 colors for 0 = black to 15 = bright white
    dy=ymax/16
    for i=0 to 15
      rect 0,i*dy,xmax,i*dy+dy,i filled
      at 0,i*dy:? i;
    next
    pause

Here is PSET with QB red at center screen: PSET xmax/2,ymax/2,12 12 is
QB red, 9 is blue, 14 is yellow, 7 dull white, 0 black, 8 is darker gray
than 7 usually the colors get brighter

+========================================================================================+
|                                   97. (Graphics) RECT                                  |
+========================================================================================+

RECT [STEP] x,y [,|STEP x2,y2] [, color| COLOR color] [FILLED]

Draws a rectangular parallelogram.

+========================================================================================+
|                                    98. (Graphics) RGB                                  |
+========================================================================================+

RGB (r, g, b)

Returns the RGB color codes for the specified values. Takes values
0..255 for each of the color.

The return value is a negative 24bit value to by used by drawing
functions.

See also Colors Tutorial.


    Def txt(t) = "     " + t + "     "
    For c = 0x00 to 0xFF ' 0 to 255 in hexadecimal
      Color 15, Rgb(c,    0x00,  0x00): At 10,   0: ? txt("1. RED");
      Color 15, Rgb(0x00,    c,  0x00): At 10,  30: ? txt("2. GREEN");
      Color 15, Rgb(0x00, 0x00,     c): At 10,  60: ? txt("3. BLUE");
      Color 15, Rgb(0x00,    c,     c): At 10,  90: ? txt("4. CYAN");
      Color 15, Rgb(c,       c,  0x00): At 10, 120: ? txt("5. YELLOW");
      Color 15, Rgb(c,    0x00,     c): At 10, 150: ? txt("6. MAGENTA");
      Color 15, Rgb(c,       c,     c): At 10, 180: ? txt("7. GRAY");
      Color 15, Rgb(c,     c\\2,  0x00): At 10, 210: ? txt("8. ORANGE");
      Color 15, Rgb(c\\2,   c\\2,  0x00): At 10, 240: ? txt("9. OLIVE");
      Color 15, Rgb(c\\2,   c\\4,  0x00): At 10, 270: ? txt("A. BROWN");
      Color 15, Rgb(c,    0x00,   c\\2): At 10, 300: ? txt("B. PINK");
      Color 15, Rgb(0x00, 0x00,   c\\3): At 10, 330: ? txt("C. NAVY");
      Color 15, Rgb(c\\3,   c\\2,     c): At 10, 360: ? txt("D. SKY");
      Delay 20
    Next 


    REM Language:  SmallBASIC 0.12.6 (Linux 32-bit)
    REM Purpose:   Standard CSS (HTML) Color Values By color names;
    REM            From: http://www.w3schools.com/colors/colors_groups.asp
    REM            (All modern browsers support the following 140 color names).
    REM File name: crgb.bas
    REM Unit name: crgb
    REM Version:   1.0.0  22/05/2016
    REM Author:    shian

    ' --- Start demo code ------------------------------------
    '
    ' Import crgb
    '
    ' Color 0, crgb.Lime: Cls
    '
    ' Color 0, crgb.Tomato: ? " Standard CSS Tomato background color "
    '
    ' Color crgb.Black, crgb.LightSteelBlue
    ' ? " Standard CSS LightSteelBlue background color "
    '
    ' --- End demo code ------------------------------------

    Unit crgb  ' (CSS RGB color names)

    ' Pink Colors ---
    Export Pink, LightPink, HotPink, DeepPink, PaleVioletRed, MediumVioletRed
    ' Purple Colors ---
    Export Lavender, Thistle, Plum, Orchid, Violet, Fuchsia, Magenta
    Export MediumOrchid, DarkOrchid, DarkViolet, BlueViolet, DarkMagenta
    Export Purple, MediumPurple, MediumSlateBlue, SlateBlue, DarkSlateBlue
    Export RebeccaPurple, Indigo
    ' Red Colors ---
    Export LightSalmon, Salmon, DarkSalmon, LightCoral, IndianRed
    Export Crimson, Red, FireBrick, DarkRed
    ' Orange Colors ---
    Export Orange, DarkOrange, Coral, Tomato, OrangeRed
    ' Yellow Colors ---
    Export Gold, Yellow, LightYellow, LemonChiffon, LightGoldenRodYellow
    Export PapayaWhip, Moccasin, PeachPuff, PaleGoldenRod, Khaki, DarkKhaki
    ' Green Colors ---
    Export GreenYellow, Chartreuse, LawnGreen, Lime, LimeGreen, PaleGreen
    Export LightGreen, MediumSpringGreen, SpringGreen, MediumSeaGreen
    Export SeaGreen, ForestGreen, Green, DarkGreen, YellowGreen, OliveDrab
    Export DarkOliveGreen, MediumAquaMarine, DarkSeaGreen, LightSeaGreen
    Export DarkCyan, Teal
    ' Cyan Colors ---
    Export Aqua, Cyan, LightCyan, PaleTurquoise, Aquamarine, Turquoise
    Export MediumTurquoise, DarkTurquoise
    ' Blue Colors ---
    Export CadetBlue, SteelBlue, LightSteelBlue, LightBlue, PowderBlue
    Export LightSkyBlue, SkyBlue, CornflowerBlue, DeepSkyBlue, DodgerBlue
    Export RoyalBlue, Blue, MediumBlue, DarkBlue, Navy, MidnightBlue
    ' Brown Colors ---
    Export Cornsilk, BlanchedAlmond, Bisque, NavajoWhite, Wheat, BurlyWood
    Export Tan_, RosyBrown, SandyBrown, GoldenRod, DarkGoldenRod, Peru
    Export Chocolate, Olive, SaddleBrown, Sienna, Brown, Maroon
    ' White Colors ---
    Export White, Snow, HoneyDew, MintCream, Azure, AliceBlue, GhostWhite
    Export WhiteSmoke, SeaShell, Beige, OldLace, FloralWhite, Ivory
    Export AntiqueWhite, Linen, LavenderBlush, MistyRose
    ' Grey Colors ---
    Export Gainsboro, LightGray, Silver, DarkGray, DimGray, Gray
    Export LightSlateGray, SlateGray, DarkSlateGray, Black

    ' Color Names Sorted by Color Groups:
    ' Pink Colors ---
    Const Pink            = -16761035 ' Rgb(0xFF, 0xC0, 0xCB) ' 0xFFC0CB
    Const LightPink       = -16758465 ' Rgb(0xFF, 0xB6, 0xC1) ' 0xFFB6C1
    Const HotPink         = -16738740 ' Rgb(0xFF, 0x69, 0xB4) ' 0xFF69B4
    Const DeepPink        = -16716947 ' Rgb(0xFF, 0x14, 0x93) ' 0xFF1493
    Const PaleVioletRed   = -14381203 ' Rgb(0xDB, 0x70, 0x93) ' 0xDB7093
    Const MediumVioletRed = -13047173 ' Rgb(0xC7, 0x15, 0x85) ' 0xC71585
    ' Purple Colors ---
    Const Lavender        = -15132410 ' Rgb(0xE6, 0xE6, 0xFA) ' 0xE6E6FA
    Const Thistle         = -14204888 ' Rgb(0xD8, 0xBF, 0xD8) ' 0xD8BFD8
    Const Plum            = -14524637 ' Rgb(0xDD, 0xA0, 0xDD) ' 0xDDA0DD
    Const Orchid          = -14315734 ' Rgb(0xDA, 0x70, 0xD6) ' 0xDA70D6
    Const Violet          = -15631086 ' Rgb(0xEE, 0x82, 0xEE) ' 0xEE82EE
    Const Fuchsia         = -16711935 ' Rgb(0xFF, 0x00, 0xFF) ' 0xFF00FF
    Const Magenta         = -16711935 ' Rgb(0xFF, 0x00, 0xFF) ' 0xFF00FF
    Const MediumOrchid    = -12211667 ' Rgb(0xBA, 0x55, 0xD3) ' 0xBA55D3
    Const DarkOrchid      = -10040012 ' Rgb(0x99, 0x32, 0xCC) ' 0x9932CC
    Const DarkViolet      = -9699539  ' Rgb(0x94, 0x00, 0xD3) ' 0x9400D3
    Const BlueViolet      = -9055202  ' Rgb(0x8A, 0x2B, 0xE2) ' 0x8A2BE2
    Const DarkMagenta     = -9109643  ' Rgb(0x8B, 0x00, 0x8B) ' 0x8B008B
    Const Purple          = -8388736  ' Rgb(0x80, 0x00, 0x80) ' 0x800080
    Const MediumPurple    = -9662683  ' Rgb(0x93, 0x70, 0xDB) ' 0x9370DB
    Const MediumSlateBlue = -8087790  ' Rgb(0x7B, 0x68, 0xEE) ' 0x7B68EE
    Const SlateBlue       = -6970061  ' Rgb(0x6A, 0x5A, 0xCD) ' 0x6A5ACD
    Const DarkSlateBlue   = -4734347  ' Rgb(0x48, 0x3D, 0x8B) ' 0x483D8B
    Const RebeccaPurple   = -6697881  ' Rgb(0x66, 0x33, 0x99) ' 0x663399
    Const Indigo          = -4915330  ' Rgb(0x4B, 0x00, 0x82) ' 0x4B0082
    ' Red Colors ---
    Const LightSalmon = -16752762 ' Rgb(0xFF, 0xA0, 0x7A) ' 0xFFA07A
    Const Salmon      = -16416882 ' Rgb(0xFA, 0x80, 0x72) ' 0xFA8072
    Const DarkSalmon  = -15308410 ' Rgb(0xE9, 0x96, 0x7A) ' 0xE9967A
    Const LightCoral  = -15761536 ' Rgb(0xF0, 0x80, 0x80) ' 0xF08080
    Const IndianRed   = -13458524 ' Rgb(0xCD, 0x5C, 0x5C) ' 0xCD5C5C
    Const Crimson     = -14423100 ' Rgb(0xDC, 0x14, 0x3C) ' 0xDC143C
    Const Red         = -16711680 ' Rgb(0xFF, 0x00, 0x00) ' 0xFF0000
    Const FireBrick   = -11674146 ' Rgb(0xB2, 0x22, 0x22) ' 0xB22222
    Const DarkRed     = -9109504  ' Rgb(0x8B, 0x00, 0x00) ' 0x8B0000
    ' Orange Colors ---
    Const Orange     = -16753920 ' Rgb(0xFF, 0xA5, 0x00) ' 0xFFA500
    Const DarkOrange = -16747520 ' Rgb(0xFF, 0x8C, 0x00) ' 0xFF8C00
    Const Coral      = -16744272 ' Rgb(0xFF, 0x7F, 0x50) ' 0xFF7F50
    Const Tomato     = -16737095 ' Rgb(0xFF, 0x63, 0x47) ' 0xFF6347
    Const OrangeRed  = -16729344 ' Rgb(0xFF, 0x45, 0x00) ' 0xFF4500
    ' Yellow Colors ---
    Const Gold                 = -16766720 ' Rgb(0xFF, 0xD7, 0x00) ' 0xFFD700
    Const Yellow               = -16776960 ' Rgb(0xFF, 0xFF, 0x00) ' 0xFFFF00
    Const LightYellow          = -16777184 ' Rgb(0xFF, 0xFF, 0xE0) ' 0xFFFFE0
    Const LemonChiffon         = -16775885 ' Rgb(0xFF, 0xFA, 0xCD) ' 0xFFFACD
    Const LightGoldenRodYellow = -16448210 ' Rgb(0xFA, 0xFA, 0xD2) ' 0xFAFAD2
    Const PapayaWhip           = -16773077 ' Rgb(0xFF, 0xEF, 0xD5) ' 0xFFEFD5
    Const Moccasin             = -16770229 ' Rgb(0xFF, 0xE4, 0xB5) ' 0xFFE4B5
    Const PeachPuff            = -16767673 ' Rgb(0xFF, 0xDA, 0xB9) ' 0xFFDAB9
    Const PaleGoldenRod        = -15657130 ' Rgb(0xEE, 0xE8, 0xAA) ' 0xEEE8AA
    Const Khaki                = -15787660 ' Rgb(0xF0, 0xE6, 0x8C) ' 0xF0E68C
    Const DarkKhaki            = -12433259 ' Rgb(0xBD, 0xB7, 0x6B) ' 0xBDB76B
    ' Green Colors ---
    Const GreenYellow       = -11403055 ' Rgb(0xAD, 0xFF, 0x2F) ' 0xADFF2F
    Const Chartreuse        = -8388352  ' Rgb(0x7F, 0xFF, 0x00) ' 0x7FFF00
    Const LawnGreen         = -8190976  ' Rgb(0x7C, 0xFC, 0x00) ' 0x7CFC00
    Const Lime              = -65280    ' Rgb(0x00, 0xFF, 0x00) ' 0x00FF00
    Const LimeGreen         = -3329330  ' Rgb(0x32, 0xCD, 0x32) ' 0x32CD32
    Const PaleGreen         = -10025880 ' Rgb(0x98, 0xFB, 0x98) ' 0x98FB98
    Const LightGreen        = -9498256  ' Rgb(0x90, 0xEE, 0x90) ' 0x90EE90
    Const MediumSpringGreen = -64154    ' Rgb(0x00, 0xFA, 0x9A) ' 0x00FA9A
    Const SpringGreen       = -65407    ' Rgb(0x00, 0xFF, 0x7F) ' 0x00FF7F
    Const MediumSeaGreen    = -3978097  ' Rgb(0x3C, 0xB3, 0x71) ' 0x3CB371
    Const SeaGreen          = -3050327  ' Rgb(0x2E, 0x8B, 0x57) ' 0x2E8B57
    Const ForestGreen       = -2263842  ' Rgb(0x22, 0x8B, 0x22) ' 0x228B22
    Const Green             = -32768    ' Rgb(0x00, 0x80, 0x00) ' 0x008000
    Const DarkGreen         = -25600    ' Rgb(0x00, 0x64, 0x00) ' 0x006400
    Const YellowGreen       = -10145074 ' Rgb(0x9A, 0xCD, 0x32) ' 0x9ACD32
    Const OliveDrab         = -7048739  ' Rgb(0x6B, 0x8E, 0x23) ' 0x6B8E23
    Const DarkOliveGreen    = -5597999  ' Rgb(0x55, 0x6B, 0x2F) ' 0x556B2F
    Const MediumAquaMarine  = -6737322  ' Rgb(0x66, 0xCD, 0xAA) ' 0x66CDAA
    Const DarkSeaGreen      = -9419919  ' Rgb(0x8F, 0xBC, 0x8F) ' 0x8FBC8F
    Const LightSeaGreen     = -2142890  ' Rgb(0x20, 0xB2, 0xAA) ' 0x20B2AA
    Const DarkCyan          = -35723    ' Rgb(0x00, 0x8B, 0x8B) ' 0x008B8B
    Const Teal              = -32896    ' Rgb(0x00, 0x80, 0x80) ' 0x008080
    ' Cyan Colors ---
    Const Aqua            = -65535    ' Rgb(0x00, 0xFF, 0xFF) ' 0x00FFFF
    Const Cyan            = -65535    ' Rgb(0x00, 0xFF, 0xFF) ' 0x00FFFF
    Const LightCyan       = -14745599 ' Rgb(0xE0, 0xFF, 0xFF) ' 0xE0FFFF
    Const PaleTurquoise   = -11529966 ' Rgb(0xAF, 0xEE, 0xEE) ' 0xAFEEEE
    Const Aquamarine      = -8388564  ' Rgb(0x7F, 0xFF, 0xD4) ' 0x7FFFD4
    Const Turquoise       = -4251856  ' Rgb(0x40, 0xE0, 0xD0) ' 0x40E0D0
    Const MediumTurquoise = -4772300  ' Rgb(0x48, 0xD1, 0xCC) ' 0x48D1CC
    Const DarkTurquoise   = -52945    ' Rgb(0x00, 0xCE, 0xD1) ' 0x00CED1
    ' Blue Colors ---
    Const CadetBlue      = -6266528  ' Rgb(0x5F, 0x9E, 0xA0) ' 0x5F9EA0
    Const SteelBlue      = -4620980  ' Rgb(0x46, 0x82, 0xB4) ' 0x4682B4
    Const LightSteelBlue = -11584734 ' Rgb(0xB0, 0xC4, 0xDE) ' 0xB0C4DE
    Const LightBlue      = -11393254 ' Rgb(0xAD, 0xD8, 0xE6) ' 0xADD8E6
    Const PowderBlue     = -11591910 ' Rgb(0xB0, 0xE0, 0xE6) ' 0xB0E0E6
    Const LightSkyBlue   = -8900346  ' Rgb(0x87, 0xCE, 0xFA) ' 0x87CEFA
    Const SkyBlue        = -8900331  ' Rgb(0x87, 0xCE, 0xEB) ' 0x87CEEB
    Const CornflowerBlue = -6591981  ' Rgb(0x64, 0x95, 0xED) ' 0x6495ED
    Const DeepSkyBlue    = -49151    ' Rgb(0x00, 0xBF, 0xFF) ' 0x00BFFF
    Const DodgerBlue     = -2003199  ' Rgb(0x1E, 0x90, 0xFF) ' 0x1E90FF
    Const RoyalBlue      = -4286945  ' Rgb(0x41, 0x69, 0xE1) ' 0x4169E1
    Const Blue           = -255      ' Rgb(0x00, 0x00, 0xFF) ' 0x0000FF
    Const MediumBlue     = -205      ' Rgb(0x00, 0x00, 0xCD) ' 0x0000CD
    Const DarkBlue       = -139      ' Rgb(0x00, 0x00, 0x8B) ' 0x00008B
    Const Navy           = -128      ' Rgb(0x00, 0x00, 0x80) ' 0x000080
    Const MidnightBlue   = -1644912  ' Rgb(0x19, 0x19, 0x70) ' 0x191970
    ' Brown Colors ---
    Const Cornsilk       = -16775388 ' Rgb(0xFF, 0xF8, 0xDC) ' 0xFFF8DC
    Const BlanchedAlmond = -16772045 ' Rgb(0xFF, 0xEB, 0xCD) ' 0xFFEBCD
    Const Bisque         = -16770244 ' Rgb(0xFF, 0xE4, 0xC4) ' 0xFFE4C4
    Const NavajoWhite    = -16768685 ' Rgb(0xFF, 0xDE, 0xAD) ' 0xFFDEAD
    Const Wheat          = -16113331 ' Rgb(0xF5, 0xDE, 0xB3) ' 0xF5DEB3
    Const BurlyWood      = -14596231 ' Rgb(0xDE, 0xB8, 0x87) ' 0xDEB887
    Const Tan_           = -13808780 ' Rgb(0xD2, 0xB4, 0x8C) ' 0xD2B48C
    Const RosyBrown      = -12357519 ' Rgb(0xBC, 0x8F, 0x8F) ' 0xBC8F8F
    Const SandyBrown     = -16032864 ' Rgb(0xF4, 0xA4, 0x60) ' 0xF4A460
    Const GoldenRod      = -14329120 ' Rgb(0xDA, 0xA5, 0x20) ' 0xDAA520
    Const DarkGoldenRod  = -12092939 ' Rgb(0xB8, 0x86, 0x0B) ' 0xB8860B
    Const Peru           = -13468991 ' Rgb(0xCD, 0x85, 0x3F) ' 0xCD853F
    Const Chocolate      = -13789470 ' Rgb(0xD2, 0x69, 0x1E) ' 0xD2691E
    Const Olive          = -8421376  ' Rgb(0x80, 0x80, 0x00) ' 0x808000
    Const SaddleBrown    = -9127187  ' Rgb(0x8B, 0x45, 0x13) ' 0x8B4513
    Const Sienna         = -10506797 ' Rgb(0xA0, 0x52, 0x2D) ' 0xA0522D
    Const Brown          = -10824234 ' Rgb(0xA5, 0x2A, 0x2A) ' 0xA52A2A
    Const Maroon         = -8388608  ' Rgb(0x80, 0x00, 0x00) ' 0x800000
    ' White Colors ---
    Const White         = -16777215 ' Rgb(0xFF, 0xFF, 0xFF) ' 0xFFFFFF
    Const Snow          = -16775930 ' Rgb(0xFF, 0xFA, 0xFA) ' 0xFFFAFA
    Const HoneyDew      = -15794160 ' Rgb(0xF0, 0xFF, 0xF0) ' 0xF0FFF0
    Const MintCream     = -16121850 ' Rgb(0xF5, 0xFF, 0xFA) ' 0xF5FFFA
    Const Azure         = -15794175 ' Rgb(0xF0, 0xFF, 0xFF) ' 0xF0FFFF
    Const AliceBlue     = -15792383 ' Rgb(0xF0, 0xF8, 0xFF) ' 0xF0F8FF
    Const GhostWhite    = -16316671 ' Rgb(0xF8, 0xF8, 0xFF) ' 0xF8F8FF
    Const WhiteSmoke    = -16119285 ' Rgb(0xF5, 0xF5, 0xF5) ' 0xF5F5F5
    Const SeaShell      = -16774638 ' Rgb(0xFF, 0xF5, 0xEE) ' 0xFFF5EE
    Const Beige         = -16119260 ' Rgb(0xF5, 0xF5, 0xDC) ' 0xF5F5DC
    Const OldLace       = -16643558 ' Rgb(0xFD, 0xF5, 0xE6) ' 0xFDF5E6
    Const FloralWhite   = -16775920 ' Rgb(0xFF, 0xFA, 0xF0) ' 0xFFFAF0
    Const Ivory         = -16777200 ' Rgb(0xFF, 0xFF, 0xF0) ' 0xFFFFF0
    Const AntiqueWhite  = -16444375 ' Rgb(0xFA, 0xEB, 0xD7) ' 0xFAEBD7
    Const Linen         = -16445670 ' Rgb(0xFA, 0xF0, 0xE6) ' 0xFAF0E6
    Const LavenderBlush = -16773365 ' Rgb(0xFF, 0xF0, 0xF5) ' 0xFFF0F5
    Const MistyRose     = -16770273 ' Rgb(0xFF, 0xE4, 0xE1) ' 0xFFE4E1
    ' Grey Colors ---
    Const Gainsboro      = -14474460 ' Rgb(0xDC, 0xDC, 0xDC) ' 0xDCDCDC
    Const LightGray      = -13882323 ' Rgb(0xD3, 0xD3, 0xD3) ' 0xD3D3D3
    Const Silver         = -12632256 ' Rgb(0xC0, 0xC0, 0xC0) ' 0xC0C0C0
    Const DarkGray       = -11119017 ' Rgb(0xA9, 0xA9, 0xA9) ' 0xA9A9A9
    Const DimGray        = -6908265  ' Rgb(0x69, 0x69, 0x69) ' 0x696969
    Const Gray           = -8421504  ' Rgb(0x80, 0x80, 0x80) ' 0x808080
    Const LightSlateGray = -7833753  ' Rgb(0x77, 0x88, 0x99) ' 0x778899
    Const SlateGray      = -7372944  ' Rgb(0x70, 0x80, 0x90) ' 0x708090
    Const DarkSlateGray  = -3100495  ' Rgb(0x2F, 0x4F, 0x4F) ' 0x2F4F4F
    Const Black          = 0         ' Rgb(0x00, 0x00, 0x00) ' 0x000000

RGB does convert into integers all but 255 + ( < 256) ’this is why you
can’t use x = rnd * 256 as an RGB argument ’because you are sure to get
something over 255 but under 256 ’maybe (rnd * 256) \ 1 (yes OK)


    OK = rgb((255.0001)\\1, 255, 0)
    color OK, 0 ' <=== yes OK
    myError = rgb(255.00001, 255, 255)
    color myError, 0  '<=== Invalid parameter

+========================================================================================+
|                                   99. (Graphics) RGBF                                  |
+========================================================================================+

RGBF (r, g, b)

Returns the RGB color codes for the specified values. Takes values 0..1
for each of the color.

The return value is a negative 24bit value to by used by drawing
functions.

    ' gray() accepts the same values as Rgb(), i.e. 0..255:
    Func gray(r, g, b)
      Local Const RGBF_SCALE = 1 / 255
      Local n

      n = Sum(r * 0.30, g * 0.59, b * 0.11) ' gray=(30% red + 59% green + 11% blue)
      n *= RGBF_SCALE ' scale 0..255 palette to 0..1 (for Rgbf)
      gray = Rgbf(n, n, n)
    End

    Print "An example for printing colors in gray-scale:"
    Print
    For i = 0 To 255 Step 15 Do
      r = 90: g = i: b = i
      Color   Rgb(r, g, b): Print " Color -> ";
      Color gray(r, g, b): Print " in Gray  "
    Next
    Pause

Hi shian, I am curious why the percents are 30% red, 59% green, 11 %
blue. I see that they have to add to 100% but why not 33% on each of
RGB. Is it something to do with green and yellow appearing lighter than
the other colors and that yellow is created by mixing red and green.
This calls for an experiment. Hi MGA, This is simply how the BIOS
Interrupt 0x10, Function 0x10, Subfunction 0x1B, sets gray-scale values
for the 256 colors palette, in MCGA and VGA monitors. I just use the
same formula of that interrupt. Therefore, the actual mystery remains
unsolved. But that’s the formula I use to program for DOS.

I feel like Thomas Edison testing light bulbs only 995 to go! My
findings according to my eye and Windows laptop coloring system reverses
the percents for red and blue. Check it out:


    ' gray() accepts the same values as Rgb(), i.e. 0..255:
    Func gray(r, g, b)
      Local Const RGBF_SCALE = 1 / 255
      Local n

      n = Sum(r * 0.30, g * 0.59, b * 0.11) ' gray=(30% red + 59% green + 11% blue)
      ' original yes on my screen blue is way too dark

      'n = Sum(r * 0.4, g * 0.4, b * 0.2)
      '1st experiment yes on my screen this is better but blue still too dark and red and purple  not enough

      'n = Sum(r * 0.3, g * 0.4, b * 0.3)
      '2nd experiment  well red green  blue are the same almost blue still doesn't look bright enough

      'n = Sum(r * 0.33, g * 0.34, b * 0.33)
      '3rd No green too dark

      'n = Sum(r * 0.25, g * 0.4, b * 0.35)
      '4th  more darker red lighter blue nice purple, green still too dark

      'n = Sum(r * 0.15, g * 0.55, b * 0.3)
      '5th yeah here !!!! it kind of reverses red/blue in original (Windows laptop)

      n *= RGBF_SCALE ' scale 0..255 palette to 0..1 (for Rgbf)

      gray = Rgbf(n, n, n)
    End
    sub ball(x,y,cx)
       local r,sc,start, ym2
       ym2=ymax*.75
       sc=32/radi:start=int(32/sc)-2
       for r=start to 0 step -1
          if cx ="R" then
             circle x,y,r,1,rgb(255-6*r*sc,0,0) filled
             circle x,ym2,r,1,gray(255-6*r*sc,0,0) filled
          elif cx="B"
             circle x,y,r,1,rgb(0,0,255-6*r*sc) filled
             circle x,ym2,r,1,gray(0,0,255-6*r*sc) filled
          elif cx="G"
             circle x,y,r,1,rgb(0,220-6*r*sc,0) filled
             circle x,ym2,r,1,gray(0,220-6*r*sc,0) filled
          elif cx="O"
             circle x,y,r,1,rgb(255-3*r*sc,150-3*r*sc,0) filled
             circle x,ym2,r,1,gray(255-3*r*sc,150-3*r*sc,0) filled
          elif cx="Y"
             circle x,y,r,1,rgb(255-4*r*sc,255-4*r*sc,0) filled
             circle x,ym2,r,1,gray(255-4*r*sc,255-4*r*sc,0) filled
          elif cx="P"
             circle x,y,r,1,rgb(255-7*r*sc,0,130-2*r*sc) filled
             circle x,ym2,r,1,gray(255-6*r*sc,0,0) filled
           fi
       next
    end

    radi=xmax/7/2-2
    Print "An example gray-scale graphics:"
    Print
    For i = 1 to 6
      cc=mid("RGBYOP",i,1)
      bx=xmax/7*i
      ball bx,.25*ymax,cc
    Next
    Pause

Append: added to on-line samples, I switched back to original formula
because on Android NOOK the blue IS lighter than red. In both versions,
the red and purple are awful dark. Nice graphix.. I guess that on BIOS
screen text mode 3 or pixel mode 18 it looks much better. However, try
to start from

    gray(50,50,255)

instead of

    gray(0,0,255)

It might work better for modern SVGA modes with high resolution and LCD
screens. I’m not aware of new formula for these kind of screens…

+========================================================================================+
|                                 100. (Graphics) SHOWPAGE                               |
+========================================================================================+

SHOWPAGE

This command is used to display pending graphics operations allowing for
smooth animations.

+========================================================================================+
|                                101. (Graphics) TEXTHEIGHT                              |
+========================================================================================+

TEXTHEIGHT (s)

Returns the text height of string s in pixels. See TXTH.

+========================================================================================+
|                                102. (Graphics) TEXTWIDTH                               |
+========================================================================================+

TEXTWIDTH (s)

Returns the text width of string s in pixels. See TXTW.

+========================================================================================+
|                                   103. (Graphics) TXTH                                 |
+========================================================================================+

TXTH (s)

Returns the text height of string s in pixels. See TEXTHEIGHT.

+========================================================================================+
|                                   104. (Graphics) TXTW                                 |
+========================================================================================+

TXTW (s)

Returns the text width of string s in pixels. See TEXTWIDTH.

+========================================================================================+
|                                   105. (Graphics) VIEW                                 |
+========================================================================================+

VIEW [x1,y1,x2,y2 [,color [,border-color]]]

Defines a viewport. The viewport defined by VIEW is disabled by a VIEW
command with no parameters.

-   x1,y1,x2,y2 - Corner coordinates of the viewport.
-   color If included, fills the viewport with the specified color.
-   border-color If included, draws a border, in a specified color,
    around the defined viewport.

+========================================================================================+
|                                  106. (Graphics) WINDOW                                |
+========================================================================================+

WINDOW [x1,y1,x2,y2]

Specifies “world” coordinates for the screen.

The WINDOW command allows you to redefine the corners of the display
screen as a pair of “world” coordinates.

The world space defined by WINDOW is disabled by a WINDOW command with
no parameters.

Note: the unusal coordinates are intended for Quick BASIC compatibility
(possible bug).

    window 1, 320, 320, 1
    rect 0, 0, 160, 160, 1 filled
    rect 160, 160, 320, 320, 2 filled
    rect 160, 0, 320, 160, 3 filled
    rect 0, 160, 160, 320, 4 filled


WINDOW sub-commands (non-standard)

WINDOW is also overloaded as a function, returning a system object which
provides access to the following sub-commands.

alert(message, title)

Display an alert message.

    w = window()
    w.alert("This is an alert", "title")

ask(message, title)

Display a prompt to retrieve a user selection.

    w = window()
    w.ask("Yes or no?", "Question")
    if w.answer == 0 then
      w.alert("Yes!", "Answer")
    else 
      w.alert("No", "Answer")
    endif

graphicsScreen1(), graphicsScreen2()

Select graphics mode screen 1 or 2 for output.

    dim v(30)
    for i = 0 to 30
      v[i] = rnd
    next i

    sub draw_chart(n,s)
      color 1,15: cls
      chart n, v, s, 1, 1, xmax-2, ymax-2
    end

    w = window()
    w.graphicsScreen2(): draw_chart(1, 5)
    w.graphicsScreen1(): draw_chart(2, 3)

    while 1
      b = !b
      if b then w.graphicsScreen1() else w.graphicsscreen2()
      pause
    wend

insetTextScreen(x, y, w, h)

    w = window()
    ? "How does this look?"
    w.insetTextScreen(5,10,90,90)
    for i = 0 to 200
      ? "This is in the text screen"
    next i
    pause

menu(option1, option2…)

Displays a popup menu. The user response is available via INKEY.

    w = window()
    w.menu("option1", "option2", "option3")
    select case asc(inkey)
    case 0
      print "one"
    case 1
      print "two"
    case 2
      print "three"
    case else
      print "unk"
    end select

message(str)

Displays a status message at the bottom of the screen.

    w = window()
    w.message("Click to continue. ")

setFont(size, unit, bold, italic)

Sets the font to be double in size with bold and italic.

“Unit” can be set to “em” to make size relative to the existing size,
any other value will cause size to be avaluated as pixels.

    w = window()
    dim buf

    sub text(s)
      local x, y, j, size, width, height
      buf << s
      y = ymax / 2
      cls
      size = 30
      for j = len(buf) - 1 to 0 step - 1
        size -= 2
        w.setFont(size, "px", 0, 1)
        width = txtw(buf[j])
        height = txth(buf[j])
        x = (xmax - width) / 2
        y -= height
        at x, y: print buf[j]
      next j
      delay 1200
    end

    text "A long time ago, in a galaxy far, far away..."
    text "It is a period of civil war. Rebel"
    text "spaceships, striking from a hidden"
    text "base, have won their first victory"
    text "against the evil Galactic Empire."
    text "During the battle, Rebel spies managed"
    text "to steal secret plans to the Empire's"
    text "ultimate weapon, the Death Star, an"
    text "armored space station with enough"
    text "power to destroy an entire planet."
    text "Pursued by the Empire's sinister agents,"
    text "Princess Leia races home aboard her"
    text "starship, custodian of the stolen plans"
    text "that can save her people and restore"
    text "freedom to the galaxy...."

setSize(w, h)

Sets the width and height of the SmallBASIC window.

    w = window()
    w.setSize(800, 680)

showKeypad()

Raises the virtual keypad on android.

textScreen()

Select the text mode for output. Text mode can display more text but is
slow.

    w = window()
    w.textScreen()
    for i = 0 to 1000
      ? "hello " + i
    next for

theme

Returns the active window colour theme.

    w = window()
    const theme = w.theme
    const colBkGnd = theme.background
    const colText  = theme.text5
    const colFile  = theme.text2
    const colDir   = theme.text3
    const colText2 = theme.text4
    const colNav   = theme.text1
    const colNav2  = theme.text6

+========================================================================================+
|                                   107. (Graphics) XMAX                                 |
+========================================================================================+

XMAX

Holds the screen width in pixels

+========================================================================================+
|                                   108. (Graphics) XPOS                                 |
+========================================================================================+

XPOS

Returns the current X position of the cursor in “characters”.

+========================================================================================+
|                                   109. (Graphics) YMAX                                 |
+========================================================================================+

YMAX

Holds the screen height in pixels.

+========================================================================================+
|                                   110. (Graphics) YPOS                                 |
+========================================================================================+

YPOS

Returns the current Y position of the cursor in “characters”.

+========================================================================================+
|                                   111. (Language) AND                                  |
+========================================================================================+

a AND b

Logical AND. Right side is not evaluated if left side evaluates to
False.

The Sign-Bit Bug (part 2): Ways to workaround this bug:

1)  It is Safe to manipulate the lower bits, 0 to 30. If your program
    don’t need to manipulate whole 32-bits of integer, then you can
    safely BAND numbers with 0x7FFFFFFF to create 31-bit unsigned
    integers (bit-31+ are cleared). But you must make sure when using
    math functions or bitwise NOT (~) that the sign bit (bit-31) always
    remains intact, i.e. = 0.

2)  A slower way, but safe, is to manipulate 32 bits using BIN()
    function. In this way you can temporarily convert a number to binary
    string of 32-bits, manipulate whole 32 bits using regular string
    manipulation, and then convert the binary string back to number, for
    example: assuming that BIN() returns 32-bits binary string (as it
    should):

    s = Bin(number)         ' convert number to binary string
    s = Replace(s, 1, "1")  ' set bit-31
    s = Replace(s, 32, "0") ' reset bit-0
    number = Val(s)         ' convert binary string back to number

This code will work the same way on both 64-bit and 32-bit systems. It
allows you to Shift/Rotate 32-bit numbers safely. So if you don’t need
the speed of bitwise operators, then this is easy and safe way.

3)  If you still need to manipulate whole 32 bits, using fast bitwise
    operators, in a safe way that will give the same results on 32-bit
    and 64-bit systems, then it’s possible. Just be aware of the
    following:

-   Never change the sign bit (bit-31 of integer) by using Math
    operators or function; or by using bitwise NOT (~). This leads to
    arithmetic result as opposed to bitwise result.

-   Trim double number to integer using ‘n = n BAND 0xFFFFFFFF’; save
    the sign-bit using ‘save_sign = n BAND 0x80000000’; then mask the
    lower 31 bits using ‘n = n BAND 0x7FFFFFFF’; then manipulate Only
    these 31 bits; then restore the sign-bit using ‘n = n BOR
    save_sign’.

-   To shift bits left: clear the upper bits including the sign bit;
    then multiply by POW(2, bits) to shift left Only bits-0..30; then
    set the sign bit (bit-31) using ‘n = n BOR bit’.

-   To shift bits right: clear the upper bits including the sign bit;
    then divide by POW(2, bits).

-   Unverified: use CDBL to avoid saving, clearing, restoring bit-31.
    Finally, debug your code on both 32-bit and 64-bit systems.

    ? " < SmallBASIC - Truth Table > "
    ?
    ? "                          OUTPUTS (0=False, 1=True)                       "
    ? "           +---------------+---------------------------------------------+"
    ? "           |  Logical (per |                  Bitwise                    |"
    ? "   INPUTS  |   expression) |         (for each bit in result)            |"
    ? " +---------+---------------+---------------------------------------------+"
    ? " |  a   b  | AND  OR NOT(b)| BAND BOR ~(b) NAND NOR  XOR  XNOR EQV  IMP  |"
    ? " +---------+---------------+---------------------------------------------+"
    ' Display table (0 and 1 equivalent to 0b0 and 0b1):
    For a = 0 To 1
      For b = 0 To 1
        ? Usg " |  0   0  |"; a, b;
        ? Usg "  0  ";
        ' Logical (result compared to False):
        ? Usg; (a AND b) <> 0;
        ? Usg; (a OR  b) <> 0;
        ? Usg; (  NOT b) <> 0;
        ? "|";
        ' Bitwise (result is in bit-0):
        ? Usg; (a BAND b) Band 1;
        ? Usg; (a BOR  b) Band 1;
        ? Usg; (  ~    b) Band 1;
        ? Usg; (a NAND b) Band 1;
        ? Usg; (a NOR  b) Band 1;
        ? Usg; (a XOR  b) Band 1;
        ? Usg; (a XNOR b) Band 1;
        ? Usg; (a EQV  b) Band 1;
        ? Usg; (a IMP  b) Band 1;
        ? "|"
      Next b
    Next a
    ? " +---------+---------------+---------------------------------------------+"
    ? " * For Logical operators 0 is False and any other value is True."
    ? " * NOT, ~ (Bitwise NOT), operators using only right side value/expression."
    ? " * XNOR and EQV is the same gate (both return the same result)."
    ? " * Note: in SB 0.12.2 XNOR, EQV, IMP return wrong result (see bug report)."
    Pause

I am trying to figure out what Usg is and found out USING isn’t listed
either. Ah ha: SB ref txt: The symbol ? can be used instead of keyword
PRINT You can use ‘USG’ instead of ‘USING’. > I have not seen USING used
in this way before, but I am a bit behind. shian, you must be working
with assembler or electronic boards like Raspberry Pi (or both). I found
another keyword which is not listed (I don’t remember which); I found
that keyword only through pressing F1 in SmallBASIC editor. I also found
wrong/unclear syntax, such as

    a NOT b

in the reference. As far as I know and understand NOT takes only the
right-side argument, i.e.

    NOT expr

And I found lots and lots of partial descriptions as well, which may
lead to frustration until you figure it out by your self… That’s why I
wish to write more short examples for each command, to clarify its use.
But certainly, the terse description of each command is very
intimidating for a novice user.

… I used to program industrial PLCs and controllers, and programs for
customers, usually for free, but my jobs were always simple physical
jobs - not intellectual.

SmallBASIC is much more fun then the popular languages, where you have
to read a manual for 2 days just to be able to use a single object. For
popular languages, such as Java, you better be a clerk - since there is
not much to program - it’s more about searching in a hug library what
you need for specific task… Language reference is perfect place to
create extended definitions and examples of keywords and their use. They
are most useful when short and focused on the keyword. Or, like here,
when the keyword is put into perspective with a slew of other keywords.
Using the search feature is very time consuming and often fruitless,
some code examples are outdated (if you can even find the keyword buried
in the code).

Terseness is crucial in Help from built in editor but as you say
frustrating if you are unfamiliar with keyword and usage. In other
words, the built in Help makes for excellent cheat sheet to remind of
spelling/meaning and parameter order.

I remember stumbling upon one of the constants xmax or ymax, trying to
reassign the value of one of these built in constants. They are very
handy but should also be included in language reference so one doesn’t
try and use them for variables.

I agree with what you say. Unlike other popular languages, with 50,000
or more “members”, i.e. keywords, objects, constants, and other esoteric
and mystical structures of bits and bytes - SmallBASIC has a very small
and quite standard vocabulary that needs to be documented.

Keyword’s documentation must include:

1.  Syntax (any formal syntax and abbreviation)
2.  Description (exact behaviour, constants)
3.  Comments (stuff you better know)
4.  Example(s) (short, clear, useful)
5.  See also (the actual keyword you were looking for…)

Usually programmers dislike documentation; so this work should be done
by another positive soul, who knows the language well enough, and with a
bit of discipline and consistency in semantic.

The built-in help (F1) must be terse; yet the online help (F2) should
include the above 5 sections, again, straight to the point and not too
wordy. p.s. the SmallBASIC editor tells you that you “Cannot change a
constant” when running

    xmax = 4

hich is great, yet built-in constants must be included in the language
reference, since these are actually keywords (hopefully there aren’t too
many, in that case just add them to a separate section).

    REM SmallBASIC
    REM created: 11/03/2016
    REM I'm using smallbasic_0.12.2, 32-bit and 64-bit versions for Linux.
    ' The Sign-Bit Bug:
    ' -----------------
    ' The Sign Bit, (or the "Most Significant Bit", or the "Leftmost Bit",
    ' or bit-31 of SmallBASIC integer) - is a bit in a signed number that
    ' indicates the sign of a number.
    ' If you write a Bit Manipulation code, be aware that SmallBASIC is
    ' interpreting your code differnetly on 32-bit or 64-bit system:
    ' For example, run the following code on 32-bit and 64-bit systems:
    ? "Assigning hexadecimal number to variable or constant:"
    n = 0xFFFFFFFF
    ? n
    ' On 32-bit system n is: -1
    ' On 64-bit system n is: 4294967295
    ?
    ? "Bitwise NOT (~) a number:"
    n = ~0xFFFFFFFF
    ? Bin(n)
    ' On 32-bit system n is: 00000000000000000000000000000000
    ' On 64-bit system n is: 10000000000000000000000000000000
    ?
    ? "Raising to power of 32+ bit number:"
    n = Pow(2, 32) - 1
    ? Bin(n)
    ' On 32-bit system n is: 10000000000000000000000000000000
    ' On 64-bit system n is: 11111111111111111111111111111111
    ?
    ? "Using 64-bit double number instead of 32-bit integer:"
    n = Cdbl(0xFFFFFFFF)
    ? Bin(n)
    '  The same result on both systems:
    ' On 32-bit system n is: 11111111111111111111111111111111
    ' On 64-bit system n is: 11111111111111111111111111111111
    ?
    ? "Using hexadecimal number *in-line*:"
    n = 0xFFFFFFFF Band 0x7FFFFFFF
    ? n
    '  The same result on both systems:
    ' On 32-bit system n is: 2147483647
    ' On 64-bit system n is: 2147483647

The code above produces different results on 32-bit and 64-bit systems;
Therefore it leads to subtle bug with no run-time error, and no other
indication.

The reason for this inconsistency is the fact that SamllBASIC determine
the type of variables on the fly. And while the sign bit in a 64-bits
register is bit-63 - in a 32-bits register is bit-31.

SmallBASIC integers are 32-bit signed integers. The sign bit of
SmallBASIC integer is bit-31 (base 0). It is Safe to manipulate only
bits 0 to 30, on both 64-bit and 32-bit systems. But it is Not safe to
manipulate the sign bit, bit-31.

It would be easier if SmallBASIC would have used double numbers (not
integers) for bitwise operators. In that case bit-31 would have been a
regular bit (not sign bit). But integer manipulation is faster then
double number manipulation.

It’s interesting…

I know at least one language that solved this conflict internally:
Instead of using 32-Bit signed integers, it uses virtual 31-Bit signed
integers. It allows that programming language to avoid any conflicts
with the sign bit-31; i.e. whenever the number is too big to fit into 31
bits integer, it’s converted to double; so bitwise operators are using
31-bit integers (which are Actually unsigned) Or double.

This internal solution is hidden from the users of the language,
i.e. they continue to use the language as usual; but at the same time it
solves lots of bit-level conflicts between 32-bit systems and 64-bit
systems.

+========================================================================================+
|                                    112. (Language) AS                                  |
+========================================================================================+

AS #fileN

See: OPEN

+========================================================================================+
|                                   113. (Language) BAND                                 |
+========================================================================================+

a BAND b

Bitwise AND.


    Def shl(n, c) = n * Pow(2, c) ' shift-left c bits in n
    Def shr(n, c) = n \\ Pow(2, c) ' shift-right c bits in n
    Def mask(c) = Pow(2, c) - 1   ' return a mask of c bits
    ' get the current date as three integers:
    now = Date ' now is "dd/mm/yyyy"
    day = Left(now, 2) * 1
    month = Mid(now, 4, 2) * 1
    year = Right(now, 4) * 1
    ' pack the date in one integer:
    p = day ' packing 5 bits (days 1..31)
    p = shl(p, 4) Bor month ' packing 4 bits (months 1..12)
    p = shl(p, 12) Bor year ' packing 12 bits (years 0..4095)
    Print Using "The current date : 00/00/0000"; day, month, year;
    Print " -> Packed as: "; p; " (0x"; Hex(p); ")"
    ' unpack the date from one integer:
    p_day = shr(p, 12 + 4) ' packed in bits 16..20
    p_month = shr(p, 12) Band mask(4) ' packed in bits 12..15
    p_year = p Band mask(12) ' packed in bits 0..11
    Print Using "The Unpacked date: 00/00/0000"; p_day, p_month, p_year;
    Pause

+========================================================================================+
|                                    114. (Language) BG                                  |
+========================================================================================+

SOUND frq, dur [, vol] [BG]

Play sound in the background. This prevent the program from blocking
while the sound plays.

+========================================================================================+
|                                   115. (Language) BOR                                  |
+========================================================================================+

a BOR b

Bitwise OR.

+========================================================================================+
|                                  116. (Language) BYREF                                 |
+========================================================================================+

BYREF

Sub/func argument declaration. Changes to the variable will be passed
back to the caller. Equivalent syntax to the @ character.

+========================================================================================+
|                                   117. (Language) CALL                                 |
+========================================================================================+

CALL (fp)

Invoke a sub or func by address pointer.

+========================================================================================+
|                                   118. (Language) CASE                                 |
+========================================================================================+

CASE expr

Branch condition for a SELECT statement.


    ' * See also IF...THEN...ELSE keywords.
    ' * Currently CASE is not supporting QB style expressions (e.g. CASE IS > 1).
     
    x = 0 ' try using different values for x, such as 1, 2, "1", "ABC", etc
    Select Case x
    Case 0: Print "x = 0"
    Case Len("a"): Print "x = 1"
    Case 2, 3: Print "x = 2 or x = 3"
    Case 4, 5, 6: Print "x >= 4 and x <= 6"
    Case Else
      Print "Else: x = "; x
    End Select

+========================================================================================+
|                                  119. (Language) CATCH                                 |
+========================================================================================+

CATCH [var | expr]

The CATCH statement is used to CATCH an run-time error.

This is typically used with errors raised when calling a file system
command that cannot be completed, for example attempting to open a
non-existent file.

The CATCH statement has two modes. You can supply a variable argument to
store the error string. Alternatively you can supply an expression.

When the raised error matches the (String) expression, the error will be
caught. When using the expression mode, you can supply a succession of
CATCH statements to handle various error messages separately.

+========================================================================================+
|                                  120. (Language) CONST                                 |
+========================================================================================+

CONST name = expr

Declare a variable who’s value does not change during program execution.

-   name - An identifier that follows the rules for naming BASIC
    variables.
-   expr - An expression consisting of literals, with or without
    operators, only. COSNT G = 6.67259E-11

+========================================================================================+
|                                 121. (Language) DECLARE                                |
+========================================================================================+

DECLARE FUNC xxx

Forward declare SUB or FUNC. Obsolete QB compatibility

+========================================================================================+
|                                   122. (Language) DEF                                  |
+========================================================================================+

DEF name[(par1[,...])] = expression

Defines a single line function. eg, DEF MySin(x) = SIN(x): ? MySin(pi/2)

This might come in handy sometime.


    ' RND - returns a number from 0 to almost 1
    ' DEF - one line function definition
    'A function for random numbers (integers) between low and high (inclusive)
    'here is that function
    DEF rand(lo,hi)=(RND*(hi-lo+1))\\1+lo '<======================= RND and DEF
    'test the distribution of these numbers with 1000 trials
    low=1100:high=1150
    DIM a(low-1 TO high+1)
    FOR i=1 to 1000
      index=rand(low,high)
      a(index)++
    NEXT
    total=0
    FOR i=low-1 TO high+1
      ? i;":";a(i);", ";
      total+=a(i)
      IF i MOD 10=9 THEN ?
    NEXT
    ?:? "total trials=";total
    'result: pretty even spread between two numbers inclusive.
    PAUSE


    ' DEF and LOCAL.bas  SmallBASIC 0.12.2 [B+=MGA] 2016-04-06
    'can I use DEF locally in a sub without interfering with main variable or DEF names
    def aboutMe() = "I am texting from main code."
    ? "Hi, ";aboutMe
    mySub
    ? "Goodbye, ";aboutMe
    pause
    sub mySub()
      'local def aboutMe() = "I am texting from mySub." '<=== note: this did not work 
      local aboutMe
      def aboutMe() = "I am texting from mySub."
    ? "Hi, ";aboutMe
    end

+========================================================================================+
|                                    123. (Language) DO                                  |
+========================================================================================+

DO

FOR f IN files("*.txt") DO PRINT f

+========================================================================================+
|                                   124. (Language) ELIF                                 |
+========================================================================================+

ELIF

foo = 2: if foo==1: ? “one”: ELIF foo==2: ? “two”: fi

+========================================================================================+
|                                   125. (Language) ELSE                                 |
+========================================================================================+

ELSE

foo = 2: if foo==1: ? “one”: ELSE: ? “not one”: fi

+========================================================================================+
|                                  126. (Language) ELSEIF                                |
+========================================================================================+

ELSEIF

foo = 2: if foo==1: ? “one”: ELSEIF foo==2: ? “two”: fi

+========================================================================================+
|                                   127. (Language) END                                  |
+========================================================================================+

END

Declares the END of a SUB or FUNC.

+========================================================================================+
|                                 128. (Language) END TRY                                |
+========================================================================================+

END TRY

The END TRY statement marks the end of a TRY/CATCH block.

+========================================================================================+
|                                  129. (Language) ENDIF                                 |
+========================================================================================+

ENDIF

foo = 1: if foo==1: ? “one”: ENDIF

+========================================================================================+
|                                   130. (Language) EQV                                  |
+========================================================================================+

a EQV b

Bitwise equivalence.

EQV and IMP manipulating only the lower 4 bits

+========================================================================================+
|                                   131. (Language) EXIT                                 |
+========================================================================================+

EXIT [FOR|LOOP|SUB|FUNC]

Exits a multi line function definition, a loop, or a subprogram. By
default (if no parameter is specified) exits from last command block
(loop, for-loop or routine).

-   FOR - Exit from the last FOR-NEXT loop
-   LOOP - Exit from the last WHILE-WEND or REPEAT-UNTIL loop
-   SUB - Return from the current routine
-   FUNC - Return from the current function

+========================================================================================+
|                                  132. (Language) FALSE                                 |
+========================================================================================+

FALSE

FALSE

+========================================================================================+
|                                    133. (Language) FI                                  |
+========================================================================================+

FI

Declares the end of an IF statement. Same as ENDIF.

+========================================================================================+
|                                   134. (Language) FOR                                  |
+========================================================================================+

FOR expr

Defines a FOR/NEXT loop. FOR counter = start TO end [STEP incr] … NEXT.
FOR element IN array (or map) … NEXT.

Begins the definition of a FOR/NEXT loop. * counter - A numeric variable
to be used as the loop counter. * start - A numeric expression; the
starting value of counter. * end - A numeric expression; the ending
value of counter. * incr - A numeric expression; the value by which
counter is incremented or decremented with each iteration of the loo The
default value is +1.

SmallBASIC begins processing of the FOR/NEXT block by setting counter
equal to start. Then, if ‘incr’ is positive and counter is not greater
than end, the commands between the FOR and the NEXT are executed.

When the NEXT is encountered, counter is increased by ‘incr’, and the
process is repeated. Execution passes to the command following the NEXT
if counter is greater than end.

If increment is negative, execution of the FOR/NEXT loop is terminated
whenever counter becomes less than end. FOR/NEXT loops may be nested to
any level of complexity, but there must be a NEXT for each FOR.


    FOR C=1 TO 9
        PRINT C
    NEXT

_Statement FOR element IN array … NEXT_ Begins the definition of a
FOR/NEXT loop. * element - A variable to be used as the copy of the
current element. * array - An array expression The commands-block will
repeated for LEN(array) times. Each time the ‘element’ will holds the
value of the current element of the array. FOR/NEXT loops may be nested
to any level of complexity, but there must be a NEXT for each FOR.


    A=[1,2,3]
    FOR E IN A
        PRINT E
    NEXT
    ...
    ' This is the same with that
    A=[1,2,3]
    FOR I=LBOUND(A) TO UBOUND(A)
        E=A(I)
        PRINT E
    NEXT

+========================================================================================+
|                                   135. (Language) FUNC                                 |
+========================================================================================+

FUNC foo (a, b)

Declares a function. Return a value by assigning a ‘variable’ with the
same name as the function.

+========================================================================================+
|                                  136. (Language) GOSUB                                 |
+========================================================================================+

GOSUB label

Causes program execution to branch to the specified label; when the
RETURN command is encountered, execution branches to the command
immediately following the most recent GOSUB command.


    ' Note: using SUB instead of GOSUB is much more easy and modular.
      
    x = 50
    Gosub routine1 ' prints 100
    Print x        ' prints 50
    routine2 x     ' prints -50
    Print x        ' prints 50
    ' Using GOSUB inside SUB:
    Sub routine2(x)
      Gosub routine3
      Exit Sub
      
    Label routine3
      x = -x
      Print x      
    Return
    End Sub
    Pause
    End ' End of program
    ' Using GOSUB with LOCAL variables:
    Label routine1
      Local x = 100
      Print x
    Return

+========================================================================================+
|                                   137. (Language) GOTO                                 |
+========================================================================================+

GOTO label

Causes program execution to branch to a specified position (label).


    ' Note: GOTO is known to create "spaghetti code", i.e. winding code which is
    '       hard to follow, to understand, and to maintain.
    '       IF...THEN, SELELCT CASE, SUB, FUNC and DEF are much better ways to
    '       write branching code.
             
    While True 
      x = Rnd
      tries += 1
      While True
        If x < 0.05 Then 
          Print "x < 0.05 (after "; tries; " tries)."
          Goto exitLoops ' here we exit all loops unconditionally.
        Elif tries = 10 Then
          Print "missed! (after "; tries; " tries)."
          Goto exitLoops ' here we exit all loops unconditionally.
        Else
          Exit Loop ' here we exit only the inner WHILE loop
        Fi
      Wend
    Wend
    Label exitLoops
    Print
    Print "Out of loops now."
    Pause

GOTO loop jumping is surest way to stack overflow error! Modular coding
and GOTO do not mix well. Use GOTO with extreme caution within code
blocks if you must. You probably should mean “GOSUB stack overflow
error”; GOTO is a freelancer freak (like me…), he can change direction
at any time. (unless you try to GOTO Label inside a sub routine, which
is insane anyway). Only GOSUB must have obligations, and as human being,
it leads to nervous breakdown… P.S. In Euphoria programming language the
stack dynamically expends and shrinks forever.

Hi shian, Well memory might be playing tricks with me because I don’t
use GOSUB or GOTO that often except translating old code. It could very
well be GOSUB I am remembering or any GOTO into or out of a subroutine.
In your large industrial programs how many times do use GOTO and are
confident you have written the best code possible? I never use GOTO. The
best code is always relative to schedule. At certain moment the program
must be finished, and sometimes you know very well that you could do
MUCH better work if only you had more time… life.

+========================================================================================+
|                                    138. (Language) IF                                  |
+========================================================================================+

IF expr

Tests the expression and IF it evaluates to a non-zero value program
flow will resume after the following THEN statement.

    IF expression1 [THEN]
        .
        . [commands]
        .
    [ [ELSEIF| ELIF] expression2 [THEN]
        .
        . [commands]
        .
    ]
    [ELSE
        .
        . [commands]
        .
    ]
    ENDIF| FI

Block-style IF. Causes SmallBASIC to make a decision based on the value
of an expression.

-   expression - An expression; 0 is equivalent to FALSE, while all
    other values are equivalent to TRUE.
-   commands - One or more commands.

Each expression in the IF/ELSEIF construct is tested in order. As soon
as an expression is found to be TRUE, then its corresponding commands
are executed. If no expressions are TRUE, then the commands following
the ELSE keyword are executed. If ELSE is not specified, then execution
continues with the command following the ENDIF.

IF, ELSE, ELSEIF, and ENDIF must all be the first keywords on their
respective lines.

THEN is optional, but if its defined it must be the last keyword on its
line; if anything other than a comment follows on the same line with
THEN, BASIC thinks it’s reading a single-line IF/THEN/ELSE construct. IF
blocks may be nested.

    x=1
    IF x=1 THEN
        PRINT "true"
    ELSE
        PRINT "false"
    ENDIF
    ...
    ' Alternate syntax:
    x=1
    IF x=1
        PRINT "true"
    ELSE
        PRINT "false"
    FI

SINGLE-LINE IF

    IF expression THEN [num-label]|[command] [ELSE [num-label]|[command]]

Causes SmallBASIC to make a decision based on the value of an
expression.

-   expression - An expression; 0 is equivalent to FALSE, while all
    other values are equivalent to TRUE.
-   command - Any legal command or a numeric label. If a number is
    specified, it is equivalent to a GOTO command with the specified
    numeric-label.

    ' Single-line IF
    x=1
    IF x=1 THEN PRINT "true" ELSE PRINT "false"
    ...
    IF x=1 THEN 1000
    ...
    1000 PRINT "true"

+========================================================================================+
|                                   139. (Language) IFF                                  |
+========================================================================================+

IFF expr

Inline version of IF. eg,
animal = "cat": fur = IFF( animal = "cat", "yes", "no"): ? fur

animal=IFF(HasFur=1,"Cat","Fish") or
? IFF(animal="cat"," has fur.", " might not have fur.")

    ' RND - returns a number from 0 to almost 1
    ' IFF - IFF(conditional statement to evaluate, return this if evaluates true, returns this if evaluates false)
    FOR i=1 TO 20 'need a random true/false, subst 0 or 1 (or -1)  ;)
      ? IFF(rnd<.5,"True ","False ");   '<======================== RND and IFF
    next
    ?:?
    FOR i=1 TO 10  'need a random direction back and forth
      dir=IFF(RND<.5,-360*RND,360*RND)  '<======================== RND and IFF
      ? USING " ####.0000"; dir;
    NEXT
    ?:?
    PAUSE

+========================================================================================+
|                                   140. (Language) IMP                                  |
+========================================================================================+

a IMP b

Used to perform a logical implication on two expressions.

EQV and IMP manipulating only the lower 4 bits:

+========================================================================================+
|                                    141. (Language) IN                                  |
+========================================================================================+

a IN b

Returns an index (1 Based) to the matching element when b is an array.
Returns TRUE if the value is contained within b as a string.


    ' IN language ref.bas  SmallBASIC 0.12.2 [B+=MGA] 2016-04-01
    'IN may be used in a couple of ways:
    '1) It can be used to access elements of an array: FOR i IN array 
    '   without needing to know upper or lower bounds of the array
    '   FOR i IN array will cycle through all elements of array, i is variable for element
    '   example to follow...
    '2) It can be used to report whether a string is within a string
    '   also in example...
    'FILES(wildcard) - will create an array of files that have wildcard pattern
    ' myFiles=FILES("*.*")
    ' pathTXTFiles=FILES(path+"/*.txt")
    myFiles=FILES("*.*")
    for fl IN myFiles
      if ".bas" IN fl then ? fl
    next
    pause


    ' See also: Home -- Articles -- Welcome to SmallBASIC -- The operator IN

    ' IN keyword is 1-Based, so using "Option Base 1" makes code more consistent:
    Option Base 1
    Def q(text) = " " + Enclose(text) + " "  ' Enclose text with quotation marks, ""
    Def rev(text) = Cat(3) + text + Cat(-3)  ' reverse colors of text
    Sub title(text)
      Color 14: Print text: Color 7  ' print title in color
    End Sub

    title "Use IN to check if sub-string exists within string (see also INSTR):"
    s = "Hello 5"
    ? rev(" s =" + q(s))
    ? q("ll") + "In s? "; "ll" In s,, ' (0=FALSE; 1=TRUE)
    ? q("LL") + "In s? "; "LL" In s
    ? q("l") + " In s? ";  "l" In s,,
    ? "  5   In s? ";        5 In s

    title "Use IN to return the index of matching element in array (1-Based):"
    Dim a()
    a << "Hello" ' append (<<) three elements to a array
    a << "World"
    a << 123
    'a << [4,"x",6] ' nested array conflicts with the other types.
    ? rev(" a = " + Str(a) + " ")
    ? q("Hello") + "In a: "; "Hello" In a,,
    ? q("ello") + " In a: ";  "ello" In a
    ? q("HELLO") + "In a: "; "HELLO" In a,,
    ? q("World") + "In a: "; "World" In a
    ? "  123    In a: ";         123 In a,,
    ? "  12     In a: ";         12  In a
    '? "[4,\\"x\\",6] In a: "; [4,"x",6] In a ' (nested array)

    title "Use IN to flatten multi-dimension array:"
    a = [1, 2, 3; 4, 5, 6; 7, 8, 9, 10, 11; "Hello", "World"]
    ? rev(" a = " + Str(a) + " ")
    For i In a
      ? i; ", "; ' i is used as pointer to a array element inside FOR loop
    Next
    ?
    title "Use IN to print nested arrays:"
    a = [[1, 2, 3], [4, 5, 6], [7, 8, 9, 10, 11], ["Hello", "World"]]
    ? rev(" a = " + Str(a) + " ")
    For i In a
      ? i; ", "; ' i is used as pointer to a(i) inside FOR loop
    Next
    ?
    title "Use IN to print map array:"
    a = Array("{x:100, y:300, point:Top-Left}")
    ? rev(" a = " + Str(a) + " ")
    For i In a
      ? i; ":"; a(i); ", "; ' i is used as pointer inside FOR loop
    Next
    ?
    title "Use IN to test equality of numbers:"
    n = 10.5
    ? rev(" n = 10.5 ")
    ? "n In 10   : "; n In 10    ' (0=FALSE; 1=TRUE)
    ? "n In 10.5 : "; n In 10.5
    Pause

+========================================================================================+
|                                  142. (Language) LABEL                                 |
+========================================================================================+

LABEL name

Defines a label. A label marks a position in the code.

There are two kinds of labels, ‘numeric’ and ‘alphanumeric’. Unlike
‘alphanumeric’ labels, ‘Numeric’ labels do not require the keyword LABEL

    1000 ? "Hello"
    ...
    LABEL AlphaLabel: ? "Hello"
    ...
    GOTO 1000
    GOTO AlphaLabel

+========================================================================================+
|                                   143. (Language) LET                                  |
+========================================================================================+

LET var=expr

Assigns a value to the variable.

-   var - A valid variable name.
-   expr - The value assigned to variable.

    LET x = 4
    x = 1               ' Without the LET keyword
    z = "String data"   ' Assign string
    ...
    DIM v(4)
    z=v                 ' Assign array (z = clone of v)

+========================================================================================+
|                                   144. (Language) LIKE                                 |
+========================================================================================+

a LIKE b

Regular-expression operator. Compares the left part of the expression
with the right side regex pattern.


    ' From  Home -- Articles -- Welcome to SmallBASIC -- The operator LIKE :
    ' LIKE is a regular-expression operator. It is compares the left part of the
    ' expression with the pattern (right part).
    '
    ' Since the original regular expression code is too big (for handhelds),
    ' I use only a subset of it, based on an excellent old stuff by J. Kercheval
    ' (match.c, public-domain, 1991).
    ' But there is an option to use PCRE (Perl-Compatible Regular Expression
    ' library) on systems that is supported (Linux); ( see OPTION:
    '
    '    Statement OPTION MATCH PCRE [CASELESS]|SIMPLE
    '
    '     Sets as default matching algorithm to (P)erl-(C)ompatible (R)egular
    '     (E)xpressions library or back to simple one.
    '     Matching-algorithm is used in LIKE and FILES.
    '
    '     PRCE works only in systems with this library and it must be linked with.
    '     Also, there is no extra code on compiler which means that SB compiles
    '     the pattern every time it is used. ).
    '
    ' The same code is used for filenames (FILES, DIRWALK) too.
    ' In the pattern string:
    '
    '  *    matches any sequence of characters (zero or more)
    '  ?    matches any character
    '  [SET]    matches any character in the specified set,
    '  [!SET] or [^SET]     matches any character not in the specified set.
    '
    ' A set is composed of characters or ranges; a range looks like character
    ' hyphen character (as in 0-9 or A-Z). [0-9a-zA-Z_] is the minimal set of
    ' characters allowed in the [..] pattern construct.
    '
    ' To suppress the special syntactic significance of any of "[]*?!^-\\",
    ' and match the character exactly, precede it with a  '\\'.
    ? "Hello" LIKE "*[oO]" : REM TRUE
    ? "Hello" LIKE "He??o" : REM TRUE
    ? "Hello" LIKE "hello" : REM FALSE
    ? "Hello" LIKE "[Hh]*" : REM TRUE
    ' Few more...
    ?
    ? "-[Hello]-" Like "\\-\\[?*\\]\\-" ' True
    ? Cbs("\\nFiles which start with Capital letter or _:\\n"); Files("[A-Z_]*")
    ? Cbs("\\nFiles which are NOT .bas or .BAS files:\\n"); Files("*[!.bas][!.BAS]")
    If "It wasn't> me!" Like "*<[!/]?*>*</?*>*" Then
      ? Cbs("\\nTrue, someone is using HTML tag...!")
    Fi
    link = "See also: http://www.regular-expressions.info/examples.html for demos."
    If link Like "*http*://?*.?*" Then
      ? Cbs("\\nTrue, someone is advertising on our site...!")
    Fi
    Pause

+========================================================================================+
|                                  145. (Language) LOCAL                                 |
+========================================================================================+

LOCAL

Declare local variables inside a SUB or FUNC. Local variables no longer
exist once the SUB or FUNC has returned.


    ' LOCAL.bas  SmallBASIC 0.12.2 [B+=MGA] 2016-03-30
    'with the LOCAL keyword varaibles are treated separately 
    'from those in main code with the same name even in a GOSUB
    var=1
    ? "var before GOSUB gs1000 ";var
    GOSUB gs1000
    ? "var after return from GOSUB gs1000 ";var
    ?
    var=1
    ? "var before GOSUB LOCAL_gs1000 ";var
    GOSUB LOCAL_gs1000
    ? "var after return from GOSUB LOCAL_gs1000 ";var
    pause
    end
    label gs1000
    var=1000
    return
    label LOCAL_gs1000
    local var
    var=1000
    return


    ' DEF and LOCAL.bas  SmallBASIC 0.12.2 [B+=MGA] 2016-04-06
    'can I use DEF locally in a sub without interfering with main variable or DEF names
    def aboutMe() = "I am texting from main code."
    ? "Hi, ";aboutMe
    mySub
    ? "Goodbye, ";aboutMe
    pause
    sub mySub()
      'local def aboutMe() = "I am texting from mySub." '<=== note: this did not work 
      local aboutMe
      def aboutMe() = "I am texting from mySub."
    ? "Hi, ";aboutMe
    end

+========================================================================================+
|                                  146. (Language) LSHIFT                                |
+========================================================================================+

result = LSHIFT number, amount

Performs an arithmetic left shift on a bit pattern.


    ' Tested on 32-bit system (I'm not sure yet about the result on 64-bit system):
    x = 1                 ' x = 1 (0b1)
    ? Bin(x)
    ?
    x = x Lshift 1        ' Shift-Left x by 1
    ? Bin(x)
    x = x Lshift 30       ' Shift-Left x again by 30
    ? Bin(x)
    ?
    x = 1 Lshift 33        ' The same as: x = 1 Lshift (33 Mod 32)
    ? Bin(x)
    ?
    x = 0b1111 Lshift 30   ' The two upper bits are lost (on 32-bit system)
    ? Bin(x)
    ? x                    ' x is -1073741824  (on 32-bit system)

+========================================================================================+
|                                   147. (Language) MDL                                  |
+========================================================================================+

MDL

Modulus.

+========================================================================================+
|                                   148. (Language) MOD                                  |
+========================================================================================+

a MOD b

Modulus. Equivalent syntax to the percent character, eg a % b


    ' LOCATE MOD CHR ASC.bas  SmallBASIC 0.12.2 [B+=MGA] 2016-03-23
    ' LOCATE row, column - sets the next print location on screen, rows down, columns across
    ' a MOD b - returns the remainder of a/b as integer 0 to b-1
    '           for example odd number n mod 2 returns 1, while even number n mod 2 returns 0
    '           n mod 10 returns 0,1,2,3,4,5,6,7,8 or 9  we will use this is demo
    ' CHR - returns the CHaRracter for the ASC number, for demo we will print a chart of CHR for ASC numbers 32-128
    ' ASC(Character) - is a number code for a print characters, 32 is the code for a space
    ' ? - is shortcut for PRINT
    ' RIGHT(string,n) - returns right most n characters of string
    ' STR(n) - returns a number in string form
    ' : - code statement seperator often used with LOCATE row, column : ? string
    ' PAUSE optional-number-of-secs - waits for key press or mouse click and/or for a number seconds 
    ' so lets user decide how long to wait
    LOCATE 1,16 : ? "ASC Table 30-129:"  ' locate print spot, print title for our app
    FOR column=0 to 9 'print a header, 10 numbers plus + (to add to row value)
      LOCATE 2,column*5+4 : ? "+";column
    NEXT
    FOR row=3 to 12
      LOCATE row,0 : ? RIGHT(" "+STR(row*10)+":",4)
    NEXT
    'main table
    FOR ASCnumber=30 to 129   'note ASC(32) = space so wont see anything in Table
      row=ASCnumber\\10 ' \\ rounds division down to integer
      column=(ASCnumber MOD 10)*5+5  'times 5 to space out the characters printed plus 5 for column labels
      LOCATE row,column : ? CHR(ASCnumber)
    NEXT
    PAUSE


    ' more MOD.bas  SmallBASIC 0.12.2 [B+=MGA] 2016-03-23
    ' n MOD m - returns the remainder of n divided by m, if 0 then m divides n perfectly
    ' another way to do MOD in SmallBASIC is to use symbol %, n%m is same as n MOD m
    ' MOD is great to tell if a number is divisible by another (leaves no remainders)
    ' a number not divisible by any number less to it other than 1, is called a prime number
    ' here we will list first 100 numbers and tell if prime or give the lowest divisor
    'table setup: title header and row labels
    LOCATE 0,0 : ? "P=Prime or Lowest Divisor Table"
    FOR column=0 to 9 'print a header, 10 numbers plus + (to add to row value)
      LOCATE 2,column*2+7 : ? "+";column
    NEXT
    FOR row=3 to 12
      LOCATE row,0 : ? RIGHT("    "+STR(row*10-30)+":",6)
    NEXT
    'main table data
    FOR n=1 to 99
      IF n=1 THEN 
        report=" O" 'one is one, neither prime nor not prime
      ELSE
        report=" P" 'letter code for Prime
        FOR i=2 TO n-1
          IF n%i=0 THEN  '<== if n MOD i=0 or n%i=0, THEN i divides n perfectly
            report=" "+STR(i):EXIT  'we found lowest divisor get out of loop
          END IF  
        NEXT
      END IF
      row=n\\10+3 'n\\10 is our number divided by 10 and rounded down, 
      'call it the tens row offset 3 rows down for title and header and blank line
      column=n%10*2+7 '<== use MOD to LOCATE the column (*2 column width + 7 row label offset) 
      LOCATE row,column :? report   '? short for print
    NEXT
    ?:?"O=one is neither prime nor not" '  ?:?"..." print blank line first
    PAUSE

+========================================================================================+
|                                   149. (Language) NAND                                 |
+========================================================================================+

a NAND b

Bitwise exclusive NOT AND.


    ' Two's complement is the standard way of representing negative integers in binary. 
    ' The sign is changed by inverting all of the bits and adding one.
    Def invsgn(n) = ((n Nand n) + 1) - Frac(n) ' invert the sign of n
    While True Do
      Input "Enter a number (Enter empty to stop) : ", n
      If Isstring(n) Then
        Stop
      Endif
      
      Print "This is the number with inverted sign: "; invsgn(n)
      Print
    Wend

+========================================================================================+
|                                   150. (Language) NEXT                                 |
+========================================================================================+

NEXT

See FOR.

+========================================================================================+
|                                   151. (Language) NOR                                  |
+========================================================================================+

a NOR b

Bitwise NOT OR.


    ' Bnot inverts all bits in n (it's very useful for inverting a mask).
    Def Bnot(n) = n Nor n
    Def mask(i) = Pow(2, i) ' return a mask of only bit-i set (base 0)
    Def set_bit(n, i) = n Bor mask(i) ' set bit-i in n (base 0)
    Def reset_bit(n, i) = n Band Bnot(mask(i)) ' reset bit-i in n (base 0)
    Def get_bit(n, i) = (n Band mask(i)) <> 0 ' return bit-i status: 0 or 1
     
    'demo: 
    While True Do
      Color 7, 0: Cls
      Print
      Print "* Set/Reset bit is useful for storing boolean data efficiently."
      Print "* The rightmost bit of binary number is bit-0, then bit-1, etc."
      Print "* This SB version supports "; Len(Bin(0)); " bits binary numbers."
      Print
      Input " Enter a number (Enter empty to stop): ", n
      If isstring(n) Then
        Stop
      Endif
      
      Print
      Color 14, 0: Print " In Binary is: "; Bin(n)
      Color  7, 0: Print " Bit-3 status: "; get_bit(n, 3)
      If get_bit(n, 3) Then
        Color 11, 0: Print " Reset bit-3:  "; Bin(reset_bit(n, 3))
      Else
        Color 15, 0: Print " Set bit-3:    "; Bin(set_bit(n, 3))
      Endif
      Pause
    Wend

+========================================================================================+
|                                   152. (Language) NOT                                  |
+========================================================================================+

a NOT b

Invert expression result. Equivalent syntax to the exclamation
character, eg a ! b

NOT and ! take only the right side argument: NOT b ! b It’s wrong to
think that the left side argument (a) is part of the result. And in some
cases it leads to an error, for example:

    PRINT  BIN(1 Not 1) ' <-- this is error

Binary operators work on 2 arguments a,b: +,-,*,/^ are all binary
operators needing 2 arguments to do their thing. shian is saying NOT or
! is NOT Binary but Unary using only 1 argument located at right of NOT
or ! So it is very misleading to show a NOT b If you actually try to
print that you will get an error using (a not b) and gobbley-gook for ?
a not b

    'NOT is a Unary operator.bas   SmallBASIC 0.12.2 [B+=MGA] 2016-03-13
    'it makes anything true > false = 0
    'it makes the one false=0 > true (and in SmallBASIC returns 1 as C developer would have it)
    ? !true      'returns 0
    ? NOT false  'returns 1
    b=45
    ? b;"=b" '45 of course
    ? !b;"=!b"  '<===========  important one, normal use of ! or NOT output is 0
    a=20
    ? a;"=a" '20 of course
    'uncomment next line to see error,
    '? (a NOT b);" (a!b) should error because ! only works on b" '(EXPR): Missing ')'
    pause

Thanks shian, on my own I would never have noticed this. to be precise:
NOT is not Bitwise operator, it is a logical operator.

There are two versions of NOT: NOT, which is logical not, ~, which is
bitwise not.

Both are using only the right side expression: NOT(b), ~(b) NOT inverts
the expression b (e.g. true –> false) ~ inverts each bit in b
(e.g. 01011 –> 10100)

+========================================================================================+
|                                    153. (Language) ON                                  |
+========================================================================================+

ON GOTO|GOSUB label1 [, ..., labelN]

Causes a branch to one of a list of labels.

A numeric expression in the range 0 to 255. Upon execution of the
ON…GOTO command (or ON…GOSUB), BASIC branches to the nth item in the
list of labels that follows the keyword GOTO (or GOSUB).

+========================================================================================+
|                                    154. (Language) OR                                  |
+========================================================================================+

a OR b

Logical OR. Right side is not evaluated if left side evaluates to True.

+========================================================================================+
|                                   155. (Language) REM                                  |
+========================================================================================+

REM comment

Code comments. Comments can also be introduced using # and single quote
character.

The # character can only be used as remarks if it is the first character
of the line.

    ' That text-line is just a few remarks
    ...
    REM another comment
    ...
    # one more comment

    ' Few ways to comment your code in SmallBASIC:
    ' This is the most easy way to add a comment:
    x = 1 + 1
    x = 1 + 1 ' Or like this...
    Rem And this is the most traditional way to add remark:
    x = 1 + 1
    x = 1 + 1: Rem Or like this...
    # And finally, this, is also a comment:
    x = 1 + 1
    x = 1 + 1: # Or like this...
    ' Now, Who and Why needs a comment?
    ' To answer this question allow me to analyze MGA's "Curlie borealis.bas"
    ' program; "Curlie borealis" has only one comment on top, which includes the
    ' standard info: Name of Program, Programming Language, Author and Date.
    ' Now, can you tell what "Curlie borealis" does? And how it does it? well,
    ' without additional comments it's not going to be easy. Look at the code:

    ' --- Start of "Curlie borealis.bas":
    'Curlie borealis.bas for SmallBASIC 0.12.2 [B+=MGA] 2016-04-23
    randomize
    ff = 440.03:maxi=25000:maxi2=maxi\\2:b=rgb(40,20,30)
    color 0,b:cls
    while 1
      ff += 9.444
      for i=0 to maxi
        f += ff
        x = min(xmax, -x + cos(f*i))
        y = min(ymax, -y + sin(f*i))
        if cc%6=0 then
          if i< maxi2 then c=rgb(255-255*i\\maxi2,255*i\\maxi2,0) else c=rgb(0,255-255*(i-maxi2)\\maxi2,255*(i-maxi2)\\maxi2)
        else
          c=b
        fi
        pset x, y, c
        if (i%5000==0) then showpage
      next
      cc++
    wend
    ' --- End of "Curlie borealis.bas"

    ' Now, although the code is very short (less then thousands of lines...), it's
    ' almost impossible to decode it... - That's why comments are so useful:
    ' to remind *yourself* and others what you did and why.
    ' Let's try to analyze "Curlie borealis.bas" code and add few comments to it:

    ' --- Start of "Curlie borealis.bas" + Comments:
    ' Initialize variables for the main loop:
    Randomize           ' - I'm not sure why do we need it here... (MGA?)
    ff = 440.03         ' Factor for defining x,y location to draw point
    maxi = 25000        ' Maximum points to draw in each shape
    maxi2 = maxi \\ 2    ' Factor for defining two different color schemes in shape
    b = Rgb(40, 20, 30) ' Background color
    Color 0, b
    Cls
    ' Run program in an endless loop (Press Ctrl+B or Ctrl+C to stop):
    While 1
      ff += 9.444 ' Move the next shape to different x,y location

      ' Draw a single shape using two color schemes, or draw an invisible shape:
      For i = 0 To maxi
        ' Define location (x,y) to draw a single point:
        f += ff
        x = Min(xmax, -x + Cos(f * i)) ' (MIN makes sure location is within screen)
        y = Min(ymax, -y + Sin(f * i))

        ' Define nice color to draw a point:
        If cc Mod 6 = 0 Then
          If i < maxi2 Then ' One color scheme
            c = Rgb(255 - 255 * i \\ maxi2, 255 * i \\ maxi2, 0)
          Else              ' Second color scheme
            c = Rgb(0, 255 - 255 * (i - maxi2) \\ maxi2, 255 * (i - maxi2) \\ maxi2)
          Fi
        Else
          c = b ' Use background color to draw invisible shape
        Fi

        ' Draw a single point (pixel):
        Pset x, y, c
        If i Mod 5000 = 0 Then Showpage ' Update screen each 5000 points (smoother)
      Next
      cc++ ' Counter for drawing invisible shape (using background color)
    Wend
    ' --- End of "Curlie borealis.bas" + Comments

    ' To sum up:
    ' Whether you write a short program or long, comments will help you
    ' and others to understand, debug and improve your program later on; i.e.
    ' comments make your code useful!
    REM "Curlie borealis.bas" code example taken from:
    REM http://smallbasic.sourceforge.net/?q=comment/1184#comment-1184
    REM Without explicit permission from MGA...

+========================================================================================+
|                                  156. (Language) REPEAT                                |
+========================================================================================+

REPEAT ... UNTIL expr

Begins the definition of a REPEAT/UNTIL loop.

SmallBASIC starts executing the commands between the REPEAT and UNTIL
commands. When SmallBASIC encounters the UNTIL command, it evaluates the
expression parameter. If that parameter is zero (false), the process
will be repeated; otherwise, execution continues at the next command.

REPEAT/UNTIL loops may be nested to any level of complexity, but there
must be an UNTIL for each REPEAT.


    C=1
    REPEAT
        PRINT C
        C=C+1
    UNTIL C=10
    ...
    ' This is the same with that
    FOR C=1 TO 9
        PRINT C
    NEXT

+========================================================================================+
|                                  157. (Language) RETURN                                |
+========================================================================================+

RETURN

Execution branches to the command immediately following the most recent
GOSUB command.

    ...
    GOSUB my_routine
    PRINT "RETURN sent me here"
    ...
    LABEL my_routine
    PRINT "I am in my routine"
    RETURN

+========================================================================================+
|                                  158. (Language) RSHIFT                                |
+========================================================================================+

result = RSHIFT number, amount

Performs an arithmetic right shift on a bit pattern.


    ' Tested on 32-bit system (I'm not sure yet about the result on 64-bit system);
    ' On 32-bit system RSHIFT cannot manipulate correctly bit-31 (leftmost bit).
    x = Pow(2, 30)          ' x = 0b 0100 0000 0000 0000 0000 0000 0000 0000
    ? Bin(x)
    ?
    x = x Rshift 1          ' Shift-Right x by 1
    ? Bin(x)
    x = x Rshift 29         ' Shift-Right x again by 29
    ? Bin(x)
    ?
    x = Pow(2, 30)          ' x = 0b 0100 0000 0000 0000 0000 0000 0000 0000
    x = x Rshift 33         ' The same as: x = x Rshift (33 Mod 32)
    ? Bin(x)
    ?
    x = 0b1111 * Pow(2, 27) ' x = 0b 0111 1000 0000 0000 0000 0000 0000 0000
    x = x Rshift 29         ' The two lower (11) bits are lost
    ? Bin(x)
    ? x                      ' x is 3

+========================================================================================+
|                                  159. (Language) SELECT                                |
+========================================================================================+

SELECT CASE expr

Perform multiple tests on the expression. Offers a more concise syntax
to writing successive IF tests.

(see also CASE and the alternate IF THEN ELIF ELSE FI structure) just
one example:


    x = 17
    select case x
    case is < 10
    ? "x is less than 10"
    case 12
    ? "x is 12"
    case 13,14,15
    ? "x is 13,14,or 15"
    case 16 to 20
    ? "x is between 16 and 20"
    end select

There are no error messages, but nothing is printed. It has been my
experience that Select Case does not work well with ranges and multiple
conditions. In my opinion, it is only helpful for single case items.
Here is same code in at least a concise form as SELECT CASE using IF
THEN ELIF ELSE FI code block structure:


    x = 17
    if x<10 then
      ? "x is less than 10"
    elif x=12
      ? "x is 12"
    elif x=13 or x=14 or x=15
      ? "x is 13,14,or 15"
    elif x>=16 and x<=20
    ? "x is between 16 and 20"
    else
      ? "didn't catch x"
    fi
    pause

SELECT/CASE was originally intended for single values, but the
multi-item syntax was recently added: case 13,14,15 These lines from
your example are not (yet) supported: case is < 10 case 16 to 20 I think
the ‘is’, ‘<’ and ‘to’ symbols are being incorrectly evaluated as
multi-term elements, so there is no error reported. The case item can be
any expression that evaluates to a single term, for example: (this is
example that Chris found later for work around to extend range in one
case):


    How about this:
    for x = 0 to 20
    ? x;
    select case x
    case iff(x >= 1 AND x <= 5, x, x+1)   '<=== checks several values, a range from 1 to 5
    ? " = 1-5"
    case 5+1
    ? " = 6"
    case 5+2
    ? " = 7"
    case 13,14,15,16,17
    ? " = 13,14,15,16,17"
    case else
    ? " = other"
    end select
    next x
    pause

This will work too for work around to add range to a CASE block:


    const notlikelyever=-9999999.1234
    def ao(a,o,x)=iff(x>a and x<=o,x,notlikelyever)
    'I call the alpha omega function ao.
    for i=1 to 20
      x=int(rnd*60)-10
      ? x;
      select case x
      case ao(-100,0,x)
        ? " x is >-100 and <=0"
      case ao(0,10,x)
        ? " x is >0 and <=10"
      case ao(10,20,x)
        ? " x is >10 and <=20"
      case ao(20,30,x)
        ? " x is >20 and <=30"
      case ao(30,40,x)
        ? " x is >30 and <=40"
      case else
        ? " did not catch x"
      end select
    next
    pause

+========================================================================================+
|                                   160. (Language) STEP                                 |
+========================================================================================+

FOR t = 1 TO 10 STEP 2

Specifies the loop counter increment in a FOR loop

+========================================================================================+
|                                   161. (Language) STOP                                 |
+========================================================================================+

STOP [error]

Terminates execution of a program, closes all files opened by the
program, and returns control to the operating system.

error - A numeric expression.

The error is the value which will returned to operating system; if not
specified SmallBASIC returns 0.

On Windows, The ‘error’ value is known as ERRORLEVEL

+========================================================================================+
|                                   162. (Language) SUB                                  |
+========================================================================================+

SUB foo (a, b)

Declare a sub procedure. Sub’s do not return a value but can return
argument values when declared as BYREF.


    ' Notes: Using SUB is much more easy and modular then using GOSUB.
    '        With SUB (and FUNC) you can divide your program into many logical and
    '        independent blocks, instead of writing a long "spaghetti code"...
    ' See also: Home -- Articles -- Welcome to SmallBASIC -- 
    '           Syntax of procedure (SUB) statements & 
    '           Syntax of function (FUNC) statements.
    x = 9
    routine1 x ' prints 9 (Passing 'x' by value)
    Print x    ' prints 9
    routine2 x ' prints 9 (Passing 'x' by reference)
    Print x    ' prints 10
    routine3 x ' prints 10 (Passing 'x' by reference)
    Print x    ' prints 11 
    routine4 x ' prints 11 (Use the LOCAL keyword for local variables)
    Print x    ' prints 11
    routine5 x ' prints 100 (Passing 'x' by value to nested procedures)
    Print x    ' prints 11
    Pause

    ' Passing 'x' by value (default):
    Sub routine1(x)
      Print x
    End Sub
    ' Passing 'x' by reference (BYREF x):
    Sub routine2(Byref x)
      Print x
      x = 10
    End Sub
    ' Passing 'x' by reference (@x is same as BYREF x):
    Sub routine3(@x)
      Print x
      x = 11
    End Sub
    ' Use the LOCAL keyword for local variables:
    Sub routine4(y)
      Local x
      Print y
      x = 12
    End Sub
    ' Passing 'x' by value to nested procedures:
    Sub routine5(x)
      x = 100
      routine6 x
      Sub routine6(x)
        Print x
      End Sub
    End Sub

+========================================================================================+
|                                   163. (Language) THEN                                 |
+========================================================================================+

THEN

foo = 1: if foo==1 THEN: ? “one”: fi

THEN needed for one liner IF… THEN… [ELSE]… (no FI) (without :’s that
create multi-line block on one line) THEN not needed for multi-line
block.

+========================================================================================+
|                                  164. (Language) THROW                                 |
+========================================================================================+

THROW [info [, ...]]

The THROW command (previously known as RTE) is used to initiate a
catch-able error. If there is no surrounding TRY/CATCH block, THROW can
be used to abort the program.

_Summary_ TRY/CATCH is used to trap errors allowing a program to recover
without having to be restarted.

    TRY

The TRY statement introduces a TRY/CATCH BLOCK.

    CATCH [var | expr]

The CATCH statement is used to CATCH an run-time error. This is
typically used with errors raised when calling a file system command
that cannot be completed, for example attempting to open a non-existent
file.

The CATCH statement has two modes. You can supply a variable argument to
store the error string. Alternatively you can supply an expression. When
the raised error matches the (String) expression, the error will be
caught.

When using the expression mode, you can supply a succession of CATCH
statements to handle various error messages separately. END TRY

The END TRY statement marks the end of a TRY/CATCH block.

    THROW

The THROW command (previously known as RTE) is used to initiate a
catch-able error. If there is no surrounding TRY/CATCH block, THROW can
be used to abort the program.

Example


    try
     open "com2000:" AS #1
    catch err
      ? "in catch: open failed";err
    end try

+========================================================================================+
|                                    165. (Language) TO                                  |
+========================================================================================+

FOR t = 1 TO 10

Specifies the loop counter end in a FOR loop

+========================================================================================+
|                                   166. (Language) TRUE                                 |
+========================================================================================+

TRUE

TRUE

+========================================================================================+
|                                   167. (Language) TRY                                  |
+========================================================================================+

TRY

The TRY statement introduces a TRY/CATCH BLOCK

Note: If this demo program crashes… then run it again. It seems that TRY
/ CATCH block might be unstable within a function or sub… (?)


    ' See also: Home -- Articles -- TRY / CATCH
    Const FILE_NAME = "try demo.tmp" ' -- DON'T use existing file for demo.
    ' OPEN file or device safely:
    Func opens(filename, mode)
      Local fn = Freefile
      Try
        Select Case Lcase(mode)
        Case "input" : Open filename For Input  As #fn
        Case "output": Open filename For Output As #fn
        Case "append": Open filename For Append As #fn
        Case Else: ? "opens(): Bad open mode at line " + Progline: Pause: Stop
        End Select
        opens = fn ' file opened, return file-handle (integer 1 to 256)
      Catch err
        ? err; " ";
        opens = 0  ' cannot open file, return 0 (FALSE)
      End Try
    End Func

    ' helper for demo:
    Func demo(demo_number, open_mode)
      Local fn
      Color 14
      ?: ? Using " Demo #: "; demo_number;
      Color 7
      fn = opens(FILE_NAME, open_mode) ' Open file safely
      If fn Then ? "File-handle is: "; fn; " ";
      demo = fn ' return file-handle or 0 if error.
    End Func

    Kill FILE_NAME ' delete file before demo
    fn = demo(1, "INPUT")
    If fn Then Close #fn
    fn = demo(2, "OUTPUT")
    If fn Then
      ? #fn, "Demo 2 Works!"
      Close #fn
    Fi
    fn = demo(3, "APPEND")
    If fn Then
      ? #fn, "Demo 3 Works!"
      Close #fn
    Fi
    fn = demo(4, "APPEND")
    If fn Then
      lines = ["Demo 4 Works!"]
      Tsave #fn, lines
      Close #fn
    Fi
    fn = demo(5, "INPUT")
    If fn Then
      Tload #fn, lines
      ? lines;
      Close #fn
    Fi
    fn = demo(6, "INPUTX")
    If fn Then
      Tload #fn, lines
      ? lines;
      Close #fn
    Fi
    Pause

+========================================================================================+
|                                  168. (Language) UNTIL                                 |
+========================================================================================+

UNTIL

    a = 0: repeat: a++: ? a: UNTIL a = 10

+========================================================================================+
|                                   169. (Language) USE                                  |
+========================================================================================+

USE

Used with various commands for passing a user-defined expression. eg
SPLIT s," ",v USE TRIM(x). Trim each element of v.

+========================================================================================+
|                                   170. (Language) USG                                  |
+========================================================================================+

PRINT USG

Synonym for USING

+========================================================================================+
|                                  171. (Language) USING                                 |
+========================================================================================+

PRINT USING

See PRINT, SPRINT

+========================================================================================+
|                                   172. (Language) WEND                                 |
+========================================================================================+

WEND

Go back to the start of a WHILE statement.

+========================================================================================+
|                                  173. (Language) WHILE                                 |
+========================================================================================+

WHILE expr

Loop while a test condition evaluates to true.

SmallBASIC starts by evaluating expression. If expression is nonzero
(true), the next command is executed. If expression is zero (false),
control passes to the first command following the next WEND command.

When SmallBASIC encounters the WEND command, it reevaluates the
expression parameter to the most recent WHILE. If that parameter is
still nonzero (true), the process is repeated; otherwise, execution
continues at the next command.

WHILE/WEND loops may be nested to any level of complexity, but there
must be a WEND for each WHILE.


    C=1
    WHILE C<10
        PRINT C
        C=C+1
    WEND
    ...
    ' This is the same with that
    FOR C=1 TO 9
        PRINT C
    NEXT

+========================================================================================+
|                                   174. (Language) XNOR                                 |
+========================================================================================+

a XNOR b

Bitwise exclusive NOT OR.

see Forum> Bug Reports >(same title) for details but XNOR is returning
same as NOR

+========================================================================================+
|                                   175. (Language) XOR                                  |
+========================================================================================+

a XOR b

Bitwise exclusive OR. Equivalent syntax to: a ~ b


    ' return true if n is ASCII code of letter (A-Z|a-z); e.g. ? isAbc(Asc("z"))
    Def isAbc(n) = ((n >= 65 And n <= 90) Or (n >= 97 And n <= 122))

    ' change case of string s; mode is -1, 0, 1 (lower, invert, upper). 
    Func ccase(s, mode)
      Local i, n
      
      For i = 1 To Len(s)
        n = Asc(Mid(s, i, 1))
        If isAbc(n) Then
          Select Case mode
            Case -1: n = n Bor  0b00100000 ' set bit-5 to lower case
            Case  0: n = n Xor  0b00100000 ' invert bit-5 to invert case
            Case  1: n = n Band 0b11011111 ' reset bit-5 to upper case 
          End Select
          s = Replace(s, i, Chr(n))
        Endif
      Next
      ccase = s
    End

    ' run demo:
    Repeat
      Cls
      Input "Enter a string (Enter empty to stop): ", s
      
      Print
      Print "  Upper case: "; ccase(s, 1)
      Print "  Lower case: "; ccase(s, -1)
      Print " Invert case: "; ccase(s, 0)
      Pause
    Until s = ""

XOR is Not equivalent syntax to: a ~ b
    is bitwise NOT, for example: ~b

+========================================================================================+
|                                     176. (Math) ABS                                    |
+========================================================================================+

ABS (x)

Returns the absolute value of x.

+========================================================================================+
|                                    177. (Math) ABSMAX                                  |
+========================================================================================+

ABSMAX (...)

Returns the absolute max value of x.

+========================================================================================+
|                                    178. (Math) ABSMIN                                  |
+========================================================================================+

ABSMIN (...)

Returns the absolute min value of x.

+========================================================================================+
|                                     179. (Math) ACOS                                   |
+========================================================================================+

ACOS (x)

Inverse cosine.

+========================================================================================+
|                                    180. (Math) ACOSH                                   |
+========================================================================================+

ACOSH (x)

Inverse cosine.

+========================================================================================+
|                                     181. (Math) ACOT                                   |
+========================================================================================+

ACOT (x)

Inverse cotangent.

+========================================================================================+
|                                    182. (Math) ACOTH                                   |
+========================================================================================+

ACOTH (x)

Inverse cotangent.

+========================================================================================+
|                                     183. (Math) ACSC                                   |
+========================================================================================+

ACSC (x)

Inverse co secant.

+========================================================================================+
|                                    184. (Math) ACSCH                                   |
+========================================================================================+

ACSCH (x)

Inverse co secant.

+========================================================================================+
|                                     185. (Math) ASEC                                   |
+========================================================================================+

ASEC (x)

Inverse secant.

+========================================================================================+
|                                    186. (Math) ASECH                                   |
+========================================================================================+

ASECH (x)

Inverse secant.

+========================================================================================+
|                                     187. (Math) ASIN                                   |
+========================================================================================+

ASIN (x)

Inverse sine.

+========================================================================================+
|                                    188. (Math) ASINH                                   |
+========================================================================================+

ASINH (x)

Inverse sine.

+========================================================================================+
|                                     189. (Math) ATAN                                   |
+========================================================================================+

ATAN (x)

Inverse tangent.

Trig lesson two in TAN offers a lead in to this little demo:


    ' pin the tail.bas  SmallBASIC 0.12.2 [B+=MGA] 2016-03-13
    ' look how simple ATAN returns an angle from a ratio y/x 
     
    tw=txtw(string(22,"W")):xlimit=xmax-tw
    th=txth("Q"):ylim=ymax-2*th
    maxdistance=(xmax^2+ylim^2)^.5
    winner=0 : windistance=maxdistance
    for i=1400 to 0 step -100 ' draw target
      if i mod 200=0 then cc=12 else cc=15 'alt red/white
      circle 0,0,i,1,cc filled
    next
    color 14,4
    for player=1 to 12
      xtail=rnd*xlimit 'keeps the player tail in one line on the screen, hopefully
      ytail=rnd*ylim   'keeps the player on the screen and screen from scrolling, hopefully
      angle=deg(atan(ytail/xtail))\\1 '<====== notice no angle involved with atan we feed it a ratio
                                                      ' DEG converts the angle to degrees from radians
      distance=((xtail^2+ytail^2)^.5)\\1
      tail="^<"+str(player)+" deg:"+str(angle)+" dist:"+str(distance)
      at xtail,ytail:? tail
      if distance < windistance then windistance=distance:winner=player
      pause
    next
    color 15,0 'cause a screen scroll on purpose
    at 0,ymax-th: ? "The winner is "+str(winner)+" at "+str(windistance)+" press any..."
    pause

+========================================================================================+
|                                    190. (Math) ATAN2                                   |
+========================================================================================+

ATAN2 (x, y)

Inverse tangent (x,y).


    'Both atan(n) and atan2(y, x) return an angle measured in radians.
    'The return measure is from -pi to pi. In demo below it is converted
    'to angle between 0 and 360 degrees.
    'atan2 is better for detecting angle's quardrant because 
    'x and y are given separartely.
    'y the vertical change is given first.
    centerX = xmax / 2 : centerY = ymax / 2
    pen on
    while asc(inkey) <> 27
      cls
      locate 0,20: ? "ATAN2 demo, used to detect angle of mouse to screen center."
      line centerX, centerY, centerX + 200, centerY
      at centerX + 210, centerY - 10 : ? "0 degrees (or radians)"
      mouseX = pen(4) 
      mouseY = pen(5)
      line centerX, centerY, mouseX, mouseY, 15 'draw line from center to mouse
      differenceX = mouseX - centerX
      differenceY = mouseY - centerY 
      a = atan2(differenceY, differenceX) '< notice y difference is listed first
      
      'VVVVVVVVVVVVVVVVVVVVVVVV  atan2 returns neg number for angles > 180
      if a < 0 then a += 2 * pi  
      '^^^^^^^^^^^^^^^^^^^^^^^^  if want a = 0 to 2*pi, instead of -pi to pi
      
      arc centerX, centerY, 100, 0, a 'draw the arc from 0 to angle
      s = "Angle of mouse to center of screen ~ "+deg(a)\\1+" degrees"
      locate 30, 20 : ? s
      showpage
      delay 10
    wend

+========================================================================================+
|                                    191. (Math) ATANH                                   |
+========================================================================================+

ATANH (x)

Inverse tangent.

+========================================================================================+
|                                     192. (Math) ATN                                    |
+========================================================================================+

ATN (x)

Inverse tangent.

+========================================================================================+
|                                     193. (Math) CEIL                                   |
+========================================================================================+

CEIL (x)

Smallest integral value not less than x.

+========================================================================================+
|                                     194. (Math) COS                                    |
+========================================================================================+

COS (x)

Cosine.


    'TRIG lesson one.bas  SmallBASIC 0.12.2 [B+=MGA] 2016-03-12
    'note: the lines in the diagram have been thickened to help see and identify the color
    const green=rgb(0,128,0) 'never liked QB color for green
    sub drawTRIGtri
    '3 points make a triangle, one point requires an x,y coordinate
    xp1=xmax-100-.25*ymax : yp1=ymax-100 'bottom left angle of triangle
    xp2=xmax-100 : yp2=ymax-100 'bottom right corner with right angle
    xp3=xmax-100 : yp3=ymax-100-.433*ymax 'upper corner
    'green botton line is called side adjacent the yellow angle at the base of this triangle (not the 90 degree right angle)
    line xp1,yp1,xp2,yp2,green
    line xp1-1,yp1+1,xp2+1,yp2+1,green
    line xp1-2,yp1+2,xp2+2,yp2+2,green

    'blue vertical line is call side opposite the yellow angle at the base of this triangle (not the 90 degree right angle)
    line xp2,yp2,xp3,yp3,9
    line xp2+1,yp2+1,xp3+1,yp3-1,9
    line xp2+2,yp2+2,xp3+2,yp3-2,9   
    'red diagonal line always the longest of a right triangle is called the hypotenuse
    for i=0 to 6
      line xp1,yp1+.5*i,xp3,yp3+i,12
    next
    'mark the 90 degree angel
    rect xp2-50,yp2-50 step 48,48,15 
    at xp2-50+10,yp2-50+15:?"90"
    'the yellow angle: ARC x,y,r, start radians, stop radians[, aspect [, color]] note: start clockwise to stop radians
    arc xp1,yp1,.2*ymax/2,2*pi-pi/3,0,1,14
    arc xp1,yp1,.18*ymax/2,2*pi-pi/3,0,1,14
    'note: here 0 degrees is due east and the angle advances clockwise
    end
    while 1
    cls
    drawTRIGtri
    at 0,0
    ?"A man put up a pole (blue) and attached a 100 foot wire (red)"
    ?"from top to ground. Now he needs to know the height of the"
    ?"pole. He doesn't have a ladder nearly that high but he"
    ?"can use a first lesson in trignometry to get the height of"
    ?"the pole."
    ?
    ?"Trignometry means right triangles. A right triangle is one
    ?"that contains a 90 degree angle, the same angle a proper 
    ?"pole makes with the ground."
    ?
    ?"Trig has made a study of right triangles and made one big
    ?"discovery: The RATIO of the sides of a right triangle are 
    ?"always the same if the ANGLES of the sides (AKA legs and 
    ?"hypotenuse) are the same." 
    ?"That is trig in a nutshell. Notice I said RATIO of lengths."
    ?
    ?"press any when ready...
    pause
    cls
    drawTRIGtri
    at 0,0
    ?"The two main RATIOs of Trig are SIN and COS."
    ?"COS (AKA COSINE) is the RATIO of the green side (next to"
    ?"the yellow ANGLE) to the hypotenuse (red diagonal) AKA"  
    ?"(adjacent leg) / (hypotenuse)  shortened to (adj/hyp)"
    ?"or here (green line length) / (red line length)."
    ?"That's it!  COS is the leg length next to the angle in"
    ?"question divided by the diagonal length."
    ?
    ?"So the man measures the distance from the pole to where"
    ?"the wire meets the gound and gets 50 feet. This is the"
    ?"green leg next to the angle we want to figure out for the"
    ?"COS RATIO (adj/hyp). In this case it is 50 ft along the" 
    ?"ground divided by 100 ft the diagonal red wire, 50/100=.5" 
    ?"So that means COS of the angle is .5 the man says."
    ?
    ?"So the man goes to some trig tables and finds what angle"
    ?"makes a COS ratio of .5, he is looking up the Arc COS of"
    ?"the ratio(.5) = the angle whose adj-leg/hypotenuse is .5" 
    ?"Oh! he says that is a 60 degree angle the wire is making"
    ?"with the ground, the yellow angle is 60 degrees."
    ?
    ?"Press any key when ready..."
    Pause
    cls
    drawTRIGtri
    at 0,0
    ?"Now that he knows the angle is 60 degrees he can use the"
    ?"SIN ratio to calculate the height of the pole. The SIN"
    ?"RATIO is opp/hyp, the (opposite leg length)/(hypotenuse)"
    ?"The pole/wire = SIN of 60 degrees = .8660"
    ?"or pole/wire=.866."
    ?
    ?"Multiply both sides of this equation by wire length and" 
    ?"get pole=.866*wire."
    ?"Since the wire is 100, pole = .866*100 = 86.6 feet."
    ?
    ?"press any for first screen again..."
    pause
    wend

At an angle around a given point, SIN and COS and radius (or distance)
can locate the absolute screen x,y coordinate:


    ''' Diagrammed SIN and COS.bas  SmallBASIC 0.12.2 [B+=MGA] 2016-03-16
    ''' ah finally got diagramed analysis built into single quote commented code!!!
    ''' the color codes match original Trig lesson one
    '''reminder XMAX, YMAX and PI are built in constants
    CONST green =RGB(0,128,0)
    ''' a central point cx,cy around which to draw 
    cx=XMAX/2:cy=YMAX/2 'again cx,cy can be anywhere on screen so dont make them constant
    '''highlight center
    CIRCLE cx,cy,2,1,15
    r=200 'the radius or distance in pixels from cx,cy desired
    CIRCLE cx,cy,r,1,8  'we want a point somewhere on this circle, radius = constant distance away from point
    '''      locate point 30 degrees and r distance from cx,cy       30 degrees = PI/6 radians
    ''' here is 30 degrees in tiny purple circle around x=r*cos(rad(30),y=r*sin(rad(30)
    CIRCLE cx + r*COS(RAD(30)), cy + r*SIN(RAD(30)), 3, 1, 13   'x,y,r=3,aspect=1,color 13
    ''' uncomment single comment lines for analysis
    'legend
    'LINE cx,cy,cx+r*COS(RAD(30)),cy,green 'adjacent leg in red
    'LINE cx+r*COS(RAD(30)),cy,cx+r*COS(RAD(30)),cy + r*SIN(RAD(30)),9 'leg opposite in blue
    'LINE cx,cy,cx+r*COS(RAD(30)),cy + r*SIN(RAD(30)),12
    'RECT cx+r*COS(RAD(30))-11,cy+2 step 9,9,15
    ''''             V there are 12, 30 degree angles in circle (2*PI) so 2*PI/12 or PI/6
    'ARC cx,cy,30,0,PI/6,1,14
    'ARC cx,cy,35,0,RAD(30),1,14

    '''                Another example at 240 degrees = 4*PI/3 radians
    ''' here is 60+180=240 degrees in yellow both x and y are neg in relation to cx,cy
    'CIRCLE cx + r*COS(RAD(240)), cy + r*SIN(RAD(240)), 3, 1, 14  'yellow
    '''uncomment single comment lines for analysis
    'legend
    'LINE cx,cy,cx+r*COS(RAD(240)),cy,green 'adjacent leg in red
    'LINE cx+r*COS(RAD(240)),cy,cx+r*COS(RAD(240)),cy + r*SIN(RAD(240)),9 'leg opposite in blue
    'LINE cx,cy,cx+r*COS(RAD(240)),cy + r*SIN(RAD(240)),12
    'RECT cx+r*COS(RAD(240))+2,cy-11 step 9,9,15
    '''240 degrees =180 + 60 = PI + 2*PI/6 = PI+PI/3 = 4*PI/3 radians
    '''               V end angle for arc in radians = RAD(240) or 4*PI/3 radians
    'ARC cx,cy,15,0,4*PI/3,1,14
    'ARC cx,cy,10,0,RAD(240),1,14
    PAUSE
    sub legend
      at 0,0
      ?"green = leg adj, blue =leg opp, red = hypotenuse = radius"
      ?"white square is where the right angle is, yellow arcs mark angle in question
      ?"COS(yellow) = adj/hyp = green/red, red is radius of circle
      ?"SIN(yellow) = opp/hyp =  blue/red, red is radius of circle
    end 

+========================================================================================+
|                                     195. (Math) COSH                                   |
+========================================================================================+

COSH (x)

Cosine.

+========================================================================================+
|                                     196. (Math) COT                                    |
+========================================================================================+

COT (x)

Cotangent.

+========================================================================================+
|                                     197. (Math) COTH                                   |
+========================================================================================+

COTH (x)

Cotangent.

+========================================================================================+
|                                     198. (Math) CSC                                    |
+========================================================================================+

CSC (x)

Co secant.

+========================================================================================+
|                                     199. (Math) CSCH                                   |
+========================================================================================+

CSCH (x)

Co secant.

+========================================================================================+
|                                     200. (Math) DEG                                    |
+========================================================================================+

DEG (x)

Radians to degrees.

+========================================================================================+
|                                    201. (Math) DERIV                                   |
+========================================================================================+

DERIV x, maxtries, maxerr, BYREF result, BYREF errcode USE expr

Calculation of derivative. errcode = 0 for success; otherwise
calculation error.

-   x value of x
-   maxtries maximum number of retries
-   maxerr tolerance
-   errcode 0 for success; otherwise calculation error
-   result the result

+========================================================================================+
|                                    202. (Math) DETERM                                  |
+========================================================================================+

DETERM (A[, toler])

Determinant of A. toler = tolerance number. the absolute value of the
lowest acceptable number. default = 0.

+========================================================================================+
|                                   203. (Math) DIFFEQN                                  |
+========================================================================================+

DIFFEQN x0, y0, xf, maxseg, maxerr, BYREF yf, BYREF errcode USE expr

Differential equation - Runge-Kutta method. x0 = initial x,y, xf = x
final. errcode = 0 for success; otherwise calculation error. yf =
result.

+========================================================================================+
|                                     204. (Math) EXP                                    |
+========================================================================================+

EXP (x)

Returns the value of e raised to the power of x.

+========================================================================================+
|                                   205. (Math) EXPRSEQ                                  |
+========================================================================================+

EXPRSEQ BYREF array, xmin, xmax, count USE expression

Returns an array with ‘count’ elements. Each element had the ‘y’ value
of its position as it is returned by the expression.

    REM same as v=SEQ(0,1,11)
    EXPRSEQ v, 0, 1, 11 USE x

+========================================================================================+
|                                     206. (Math) FIX                                    |
+========================================================================================+

FIX (x)

Rounds x upwards to the nearest integer.

+========================================================================================+
|                                    207. (Math) FLOOR                                   |
+========================================================================================+

FLOOR (x)

Largest integer value not greater than x.

+========================================================================================+
|                                     208. (Math) FRAC                                   |
+========================================================================================+

FRAC (x)

Fractional part of x.

+========================================================================================+
|                                     209. (Math) INT                                    |
+========================================================================================+

INT (x)

Rounds x downwards to the nearest integer.

I think /1 will convert a number to an integer in less keystrokes than
INT, they both round down for positives and up for negatives. In other
words, they both drop the fractional part of the number.


    'INT or alternate.bas 2016-03-06 SmallBASIC 0.12.2 [B+=MGA]
    'I think number\\1 is eqivalent to INT(number) in less keystrokes
    ' both of these convert a number to an integer and both round down to do it.
    for i = 1 to 20
      'which coin should I use
      if rnd<.5 then TF=int(rnd*2) else TF=rnd*2\\1
      ? TF,
      if TF then ? "It is true now."; else ? "Now it's false.";
      ?spc(3)+"press a key or click for next..."
    next
    for i=0 to -10 step -1 'they seem to behave the same for negatives too
      test=i+rnd
      ? "test = ";test
      ? "test\\1 " ;test\\1
      ? "int(test) ";int(test)
      ?
    next
    pause

+========================================================================================+
|                                  210. (Math) INTERSECT                                 |
+========================================================================================+

INTERSECT Ax, Ay, Bx, By, Cx, Cy, Dx, Dy, BYREF type, BYREF Rx, BYREF Ry
  Ry

Calculates the intersection of the two line segments A-B and C-D.
Returns: Rx,Ry = cross.

type = cross-type:

-   0 No cross (R = external cross)
-   1 One cross
-   2 Parallel
-   3 Parallel (many crosses)
-   4 The cross is one of the line segments edges.

+========================================================================================+
|                                   211. (Math) INVERSE                                  |
+========================================================================================+

INVERSE (A)

Returns the inverse matrix of A.

+========================================================================================+
|                                    212. (Math) LINEQN                                  |
+========================================================================================+

LINEQN (a, b [, toler])

Returns an array with the values of the unknowns. This function solves
equations using the Gauss-Jordan method.

-   b equations
-   b results
-   toler tolerance number. (the absolute value of the lowest acceptable
    number) default = 0 = none…

    |x| <= toler : x = 0

The result is a matrix Nx1. The array is two-dimension array.

+========================================================================================+
|                                     213. (Math) LOG                                    |
+========================================================================================+

LOG (x)

Returns the natural logarithm of x.

+========================================================================================+
|                                    214. (Math) LOG10                                   |
+========================================================================================+

LOG10 (x)

Returns the base-10 logarithm of x.

+========================================================================================+
|                                   215. (Math) M3APPLY                                  |
+========================================================================================+

M3APPLY m3x3, BYREF poly

Apply matrix to poly-line.

    |  1  0  0|
    |  0 -1  0| = reflection on x
    |  0  0  1|

    | -1  0  0|
    |  0  1  0| = reflection on y
    |  0  0  1|

3D-Graphics Matrices:

    |  1  0  0 Tx|
    |  0  1  0 Ty| = translation
    |  0  0  1 Tz|
    |  0  0  0  1|

    | Sx  0  0  0|
    |  0 Sy  0  0| = scaling
    |  0  0 Sz  0|
    |  0  0  0  1|

    |  1  0  0  0|
    |  0  c -s  0| = rotation on x
    |  0  s  c  0|
    |  0  0  0  1|

    |  c  0  s  0|
    |  0  1  0  0| = rotation on y
    | -s  0  c  0|
    |  0  0  0  1|

    |  c -s  0  0|
    |  s  c  0  0| = rotation on z
    |  0  0  1  0|
    |  0  0  0  1|

Any change to matrix will combined with its previous value.

    DIM poly(24)
    DIM M(2,2)
    ...
    M3IDENT M
    M3ROTATE M, pi/2, 0, 0
    M3SCALE M, 0, 0, 1.24, 1.24
    ...
    ' Draw the original polyline
    DRAWPOLY poly
    ...
    ' Draw the polyline
    ' rotated by pi/2 from 0,0 and scaled by 1.24
    M3APPLY M, poly
    DRAWPOLY poly

+========================================================================================+
|                                   216. (Math) M3IDENT                                  |
+========================================================================================+

M3IDENT BYREF m3x3

Resets matrix (Identity).

    |1  0  0|
    |0  1  0|
    |0  0  1|

+========================================================================================+
|                                   217. (Math) M3ROTATE                                 |
+========================================================================================+

M3ROTATE BYREF m3x3, angle [, x, y]

Rotate by angle with center x,y.

    |  c  s  0|
    --------- 
    -s  c  0
    *  *  1
    --------- 

+========================================================================================+
|                                   218. (Math) M3SCALE                                  |
+========================================================================================+

M3SCALE BYREF m3x3, x, y, Sx, Sy

Scale matrix.

    | Sx  0  0|
    | 0  Sy  0|
    | *   *  1|

+========================================================================================+
|                                   219. (Math) M3TRANS                                  |
+========================================================================================+

M3TRANS BYREF m3x3, Tx, Ty

Matrix translation.

    |  1  0  0|
    |  0  1  0|
    | Tx Ty  1|

+========================================================================================+
|                                     220. (Math) MAX                                    |
+========================================================================================+

MAX (...)

Maximum value of parameters.

    ? MAX(3,4,8)
    ? MIN(array(),2,3)
    ? MAX("abc","def")

+========================================================================================+
|                                     221. (Math) MIN                                    |
+========================================================================================+

MIN (...)

Minimum value of parameters. Parameters can be anything (arrays, ints,
reals, strings).

+========================================================================================+
|                                   222. (Math) POLYAREA                                 |
+========================================================================================+

POLYAREA (poly)

Returns the area of the polyline poly.

+========================================================================================+
|                                   223. (Math) POLYCENT                                 |
+========================================================================================+

POLYCENT

Polycent.

+========================================================================================+
|                                   224. (Math) POLYEXT                                  |
+========================================================================================+

POLYEXT poly(), BYREF xmin, BYREF ymin, BYREF xmax, BYREF ymax

Returns the polyline’s extents.

+========================================================================================+
|                                     225. (Math) POW                                    |
+========================================================================================+

POW (x, y)

x raised to power of y.

+========================================================================================+
|                                   226. (Math) PTDISTLN                                 |
+========================================================================================+

PTDISTLN (Bx,By,Cx,Cy,Ax,Ay)

Distance of point A from line B, C.

+========================================================================================+
|                                  227. (Math) PTDISTSEG                                 |
+========================================================================================+

PTDISTSEG (Bx,By,Cx,Cy,Ax,Ay)

Distance of point A from line segment B-C.

+========================================================================================+
|                                    228. (Math) PTSIGN                                  |
+========================================================================================+

PTSIGN (Ax,Ay,Bx,By,Qx,Qy)

The sign of point Q from line segment A->B.

+========================================================================================+
|                                     229. (Math) RAD                                    |
+========================================================================================+

RAD (x)

Degrees to radians.

+========================================================================================+
|                                     230. (Math) RND                                    |
+========================================================================================+

RND

Returns a random number from the range 0 to 1.


    ' RND IFF and DEF.bas  SmallBASIC 0.12.2 [B+=MGA] 2016-03-24
    ' RND - returns a number from 0 to almost 1
    ' IFF - IFF(conditional statement to evaluate, return this if evaluates true, returns this if evaluates false) 
    ' DEF - one line function definition
    FOR i=1 TO 20 'need a random true/false, subst 0 or 1 (or -1)  ;)
      ? IFF(rnd<.5,"True ","False ");   '<======================== RND and IFF
    next
    ?:?
    FOR i=1 TO 10  'need a random direction back and forth
      dir=IFF(RND<.5,-360*RND,360*RND)  '<======================== RND and IFF
      ? USING " ####.0000"; dir;
    NEXT
    ?:?
    'check distribution of random numbers between low and high (inclusive)
    'here is that function
    DEF rand(lo,hi)=(RND*(hi-lo+1))\\1+lo '<======================= RND and DEF
    low=1100:high=1150
    DIM a(low-1 TO high+1)
    FOR i=1 to 1000
      index=rand(low,high)
      a(index)++
    NEXT
    total=0
    FOR i=low-1 TO high+1
      ? i;":";a(i);", ";
      total+=a(i)
      IF i MOD 10=9 THEN ?
    NEXT
    ?:? "total trials=";total
    'result: pretty even spread between two numbers inclusive.
    PAUSE

+========================================================================================+
|                                     231. (Math) ROOT                                   |
+========================================================================================+

ROOT low, high, segs, maxerr, BYREF result, BYREF errcode USE expr

Roots of F(x).

-   low the lower limit
-   high the upper limit
-   segs the number of segments (spaces)
-   maxerr tolerance (IF ABS(F(x)) < maxerr THEN OK)
-   errcode 0 for success; otherwise calculation error
-   result the result

    FUNC F(x)
     F = SIN(x)
    END
    ...
    ROOT 1, 5, 500, 0.00001, result, errcode USE F(x)

+========================================================================================+
|                                    232. (Math) ROUND                                   |
+========================================================================================+

ROUND (x [, decs])

Rounds the x to the nearest integer or number with ‘decs’ decimal
digits.

+========================================================================================+
|                                     233. (Math) SEC                                    |
+========================================================================================+

SEC (x)

Secant.

+========================================================================================+
|                                     234. (Math) SECH                                   |
+========================================================================================+

SECH (x)

Secant.

+========================================================================================+
|                                    235. (Math) SEGCOS                                  |
+========================================================================================+

SEGCOS (Ax,Ay,Bx,By,Cx,Cy,Dx,Dy)

Cosine of 2 line segments (A->B, C->D).

+========================================================================================+
|                                    236. (Math) SEGLEN                                  |
+========================================================================================+

SEGLEN (Ax,Ay,Bx,By)

Length of line segment.

+========================================================================================+
|                                    237. (Math) SEGSIN                                  |
+========================================================================================+

SEGSIN (Ax,Ay,Bx,By,Cx,Cy,Dx,Dy)

Sinus of 2 line segments (A->B, C->D).

+========================================================================================+
|                                     238. (Math) SEQ                                    |
+========================================================================================+

SEQ (xmin, xmax, count)

Returns an array with ‘count’ elements. Each element has the x value of
its position.

+========================================================================================+
|                                     239. (Math) SGN                                    |
+========================================================================================+

SGN (x)

Sign of x (+1 for positive, -1 for negative and 0 for zero).

    Built-in:    SGN
    Syntax:      SGN(numeric-expression)
    Description: SGN returns a value indicating the sign of a numeric expression (1 if the
                 expression is positive, 0 if it is zero, or -1 if it is negative).
    Comment:     SGN cannot accept a numeric string, such as "24", as an argument.
    Example:
                 PRINT SGN(1), SGN(-1), SGN(0)  ' Output is:  1  -1  0
                 PRINT SGN(CINT("-2"))          ' Output is:  -1
                 PRINT SGN("2 + 1")             ' Error
    See Also:    ABS, ABSMAX, ABSMIN, CINT

+========================================================================================+
|                                     240. (Math) SIN                                    |
+========================================================================================+

SIN (x)

First off, Trig lessons started in COS comments of this Language
reference, check that for some remarks about trig functions.

2nd, SIN and COS use radians for angle measure, just use the RAD
function to convert an angle in degrees to radians. Radians are circle
measures based on pi instead of degrees.

    2*pi = one circle 360 degrees
        pi = 180 degrees half a circle
     pi/2 = 90   degrees 1/4 circle
     pi/4 = 45   degrees 1/8 circle
     pi/6 = 60   degrees 1/6 circle
    pi/12= 30   degree s 1/12 circle
    3rd, Here is a demo of cool stuff you can do with SIN and COS:

    'Drawing spiral around point.bas SmallBASIC 0.12.2 [B+=MGA] 2016-03-13
    'using SIN and COS in a most common situation drawing at an angle from a point
    cx=xmax\\2:cy=ymax\\2
    for degree=0 to 360 step 10   'zero is due East
      line cx,cy step 10*(degree^.5)*cos(rad(degree)),10*(degree^.5)*sin(rad(degree)),rgb(0,0,degree\\360*128+127)
      at 0,0: ?spc(100)
      at 0,0
      if degree=0 then
        ? " 0 degrees don't worry, you haven't seen nothing yet! press any...
      else
        ? degree;" degrees press any..."
      end if
    pause
    next
    ? "Notice how the the drawing started due East for 0 degrees and"
    ? "as the angle increased the drawing went around clock-wise."
    pause
    cls
    'now I am doing a LOGO like program and I want 0 degrees to be due North
    'due North is -90 degrees for clock-wise rotation so subtract 90 from degrees
    for degree=0 to 360 step 10
      line cx,cy step 10*(degree^.5)*cos(rad(degree-90)),10*(degree^.5)*sin(rad(degree-90)),rgb(0,0,degree\\360*128+127)
      at 0,0: ?spc(100)
      at 0,0
      if degree=0 then
        ? " 0 degrees don't worry, you haven't seen nothing yet! press any..."
      else
        ? degree;" degrees press any..."
      end if
    pause
    next
    ? "Notice how the drawing started due North because of the -90 adjustment made in SIN and COS calls"
    ?:? "press any to end..."
    pause

this is the crucial line:


    line cx,cy step 10*(degree^.5)*cos(rad(degree)),10*(degree^.5)*sin(rad(degree)),rgb(0,0,degree\\360*128+127)

The multiple 10*(degree^.5) to both SIN and COS controls how far the
extension of the line will be from point cx,cy “origin” here as the
degrees increase so did the extension out which cause the spiral effect.

The COS calculation was used for x “the run” or horizontal component and
the SIN calculation was used for y “the rise” or vertical component.

This is really, really important to use and play with even if you don’t
understand all the details, the code will serve you well.

Still I did my best to explain how this works, so it is a bit wordy…

    ' sin and cos use.bas  SmallBASIC 0.12.2 [B+=MGA] 2016-03-15
    '                    SIN and COS work as a team
    'SIN and COS are used most for drawing points in circle around a central point.
    'Here we are going to divide a circle into n sections to draw an n sided polygon,
    'for instance, divide a circle into 3 equal parts and you get equilateral triangle (all sides =)
    'divide by 4 and get a square, by 5 a pentagon, 6 a hexagon.... all equal sides
    'I have to spend some time explaining why this works and a triangle diagram is really needed
    'but here goes, imagine a pie sitting on top of a given center point cx,cy
    'it is cut into n equal slices each piece has a central angle of 360/n or in radians 2*pi/n
    'a polygon just cuts the round parts off with straight lines to each end at outer edge.
    'remember COS is the leg adjacent to the angle in question divide by hypotenuse
    'or COS(inner angle) = adj/hyp
    'x is the adjacent side, the hypotenuse is the radius
    'so COS(inner angle) = x/radius
    'or radius * COS(angle) = x  multiple each side by radius
    'x = radius * COS(angle)
    'but remember this is distance relative to center point not a screen coordinate
    'to make absolute screen point it is: x = cx + radius*COS(angle)
    'SIN works out similar
    'SIN(inner angle) = opposite/hyp
    'and again y is opposite side (of inner angle) and the hypotenuse is the radius of circle
    'SIN(angle) = y/radius    multiply each side by radius
    'radius*SIN(angle) = y
    'y = radius * SIN(angle)
    'to make absolute screen point it is y = cy + radius*SIN(angle)
    'So going around a central point x=cx+radius*COS(angle),y=cy+radius*SIN(angle)
    'will locate points equal distance from center for equal sided polygon
    cx=xmax/2 : cy=ymax/2 'here's our center move it anywhere on screen
    'cx=100 : cy = 500 '<== try different center points
    'radius=100 'draw points in a radius of 100 around cx,cy
    radius=150 'fits center text better
    while 1
      cls
      circle cx,cy,3,1,14 'this shows the central point in small yellow circle

      'what polygon shall we draw?
      ?"A regular polygon is a many sided figure with equal sides."
      ?"A triangle is a 3 sided polygon, a square 4, a pentagon 5..."
      input "(<=2 quits) Enter the number of sides for a polygon to draw ";n
      if n<3 then end  'need at least 3 sides

      'make the first point 0 degrees or directly East of center point (offset 0)
      'you can off set the first point by some degree amount to spin the polygon by the offset
      offset=0
      'offset=pi/10  'pi/18 = 10 degrees, pi/36 = 5 degrees... play with this to spin polygon
      for centralAngle=0+offset to 2*pi+offset step 2*pi/n
        '2*pi is a circle (360 degrees) divide by n get inner angles of pie slices that's our step

        'radius * cos(centralAngle) = our needed x coordinate to center point so add cx for absolute screen coordinate
        'radius * sin(centralAngle) = our needed y coordinate to center point so add cy for absolute screen coordinate
        if centralAngle=0+offset then  'first point location
          xstart=cx+radius*cos(centralAngle)
          ystart=cy+radius*sin(centralAngle) 'get the ball rolling by recording first point
        else
          line xstart,ystart,cx+radius*cos(centralAngle),cy+radius*sin(centralAngle)
          xstart=cx+radius*cos(centralAngle)
          ystart=cy+radius*sin(centralAngle)
        end if
        delay 300 'to show the progress of draw
      next
      s="press any..."
      at cx-txtw(s)/2,cy-txth(s)/2:?s  'this puts cue right where you will see it
      pause
    wend
    'you are just a few simple steps away from spinning these polygons!

Perfect.

1.  All elementary information in a single place.
2.  Documented very well (even I understand, at least how to use it).
3.  Simple, short, and practical demo code.

As far as I concerned: they may shut down Wikipedia right now.

Thanks! By the way… Is it possible to accurately> calculate the Length>
of an Arc (segment of an ellipse)? Can I get the length of an Arc in
let’s say millimetres? As if it was a regular line?

(arc length discussion picked up on forum) Here is graph of the three
main Trig ratios:

    ' sin-cos-tan.bas from FLTK samples
    cls
    at 0,ymax/2+txth("Q")
    color 1: ? "sin(x)":
    color 8: ? "cos(x)":
    color 12: ? "tan(x)"
    line 0,ymax/2,xmax,ymax/2  'central or x axis, ymax/4 is multiplier scaled to 1/4 of ymax
    for i=0 to xmax
    pset i,ymax/2-sin(i*2*pi/ymax)*ymax/4  color 1
    pset i,ymax/2-cos(i*2*pi/ymax)*ymax/4 color 8
    pset i,ymax/2-tan(i*2*pi/ymax)*ymax/4 color 12
    next
    pause

+========================================================================================+
|                                     241. (Math) SINH                                   |
+========================================================================================+

SINH (x)

Sine.

+========================================================================================+
|                                     242. (Math) SQR                                    |
+========================================================================================+

SQR (x)

Square root of x.

+========================================================================================+
|                                   243. (Math) STATMEAN                                 |
+========================================================================================+

STATMEAN (...)

Arithmetical mean.

+========================================================================================+
|                                 244. (Math) STATMEANDEV                                |
+========================================================================================+

STATMEANDEV (...)

Mean deviation.

+========================================================================================+
|                                 245. (Math) STATSPREADP                                |
+========================================================================================+

STATSPREADS (...)

Sample spread.

+========================================================================================+
|                                 246. (Math) STATSPREADS                                |
+========================================================================================+

STATSPREADP (...)

Population spread.

+========================================================================================+
|                                     247. (Math) SUM                                    |
+========================================================================================+

SUM (...)

Sum of value.

+========================================================================================+
|                                    248. (Math) SUMSQ                                   |
+========================================================================================+

SUMSQ (...)

Sum of square value.

+========================================================================================+
|                                     249. (Math) TAN                                    |
+========================================================================================+

TAN (x)

see COS for Trig lesson one see ATAN for a maybe fun demo involving TAN
and ATAN

Trigonometry lesson two. We will try this from a txt file instead.

Review:

Trigonometry is the study of right triangles, those that have one 90
degree angle AKA Pi/2 in radians. These right triangles are infinite in
a rectilinear coordinate system with x,y referring to screen position in
relation to an origin point (0,0).

In SmallBASIC the y axis increases from top to bottom and in SmallBASIC
the angle measures used for arguments to SIN and COS and the other Trig
Angles are expected to be in radian measure as opposed to degree
measure.

This is a standard conflict and source of confusion from what you might
learn in math class and doing stuff on a computer. For all triangles
that have all 3 angles the same, their legs will have exactly the same
ratios between themselves.

Feed a trig function an angle and it will return the special ratio
between the sides of the triangle that is universal to all triangles
that have the same equal angle measures. Feed the COS function an angle
and it will return the universal ratio for the leg adjacent divided by
the hypotenuse. ( Adjacent means next to or attached in the case of
angles.)

Some more information gained from study or right angles: The COS for one
acute angle in a right triangle is the SIN for the other acute angle.
For 45 degree angle (Pi/4 radians) the two legs are the same therefore
SIN(RAD(45 degrees)) = COS(RAD(45 degrees)) = .7071… notice if that is
squared =.5 exactly 1-COS(angle)^(2=SIN(angle))2 As the angle size
approaches 0, COS(angle) > 1 and SIN(angle) >0 At angle = 0 you have
more a line segment than a triangle.

Similarly as angle approaches 90 degrees = Pi/2 radians, the COS(angle)
ratio approaches> 0 and SIN(angle) >1 Trig functions are Unary
Operators, they take one argument, an angle expressed in Radians, and
return to you the ratio of the triangle sides involved.

The COS returns the ratio of the leg adjacent the angle divided by the
hypotenuse. adj/hyp The SIN function returns the leg opposite the angle
fed the function divided by the hypotenuse. opp/hyp The third main trig
function is TAN, tangent. opp/adj The TAN(angle in radians) returns the
ratio of the opp side divided by the adjacent side.

In SmallBASIC this is very handy because side opposite/ side adjacent is
the same as y/x the same two items that define a point location! Can you
see what this means? Does a chill of revelation run up and down your
spine? Oh! that means for any point x,y on the screen, I can find the
angle it is from the origin!

It is the ATAN(y/x) We are almost ready now to play pin the tail on the
donkey! Hang in there… The A before the TAN, the A before the SIN, COS…
means ARC ATAN is pronounced ARC TANGENT ACOS is pronounced ARC COSINE
ASIN is pronounced ARC SIN

In each the ARC means The Angle whose Trig Ratio is: (ratio of two
sides) so ATAN is the Angle whose TAN ratio is (opp leg lentgh/adj leg
length) We feed ATAN a leg ratio argument and it tells what angle that
ratio came from. ARC in the Language reference is referred to as “the
inverse” If TAN( an angle) = ratio then ATAN( ratio=opp/adj ) = an angle
(in radians) DEG(ATAN(opp/adj) = an angle in degrees You can think or
the A in front of TAN or COS or SIN as give me “An Angle” without the A
you get side ratios.

A donkey is mounted on the SmallBASIC screen so that it’s tail should be
pinned at 0,0 …. see ATAN for “pin the tail.bas”

This information is unavailable elsewhere.

Wikipedia gives you formulas that look like ancient Egyptian glyph.
Others, explain what is TAN - but don’t even mention a single word about
Arc TAN (as if there is absolutely no relation). This is really a
valuable and practical information. (an extra VERY SHORT DEMO for this
info would be even more astonishing). Thanks again. Edit: by SHORT DEMO
I just mean few lines of code that illustrate how it’s written in
SmallBASiC, for creating the most simple shape… (you know, chunk by
chunk… it’s really a new world for me and maybe for some others). Like
this? It would have been in 3 lines but it seems print usg needs it’s
own line TAN used in a short code example:

    ' TAN use.bas  SmallBASIC 0.12.2 [B+=MGA] 2016-03-14
    for degrees = 0 to 360 step 15
    ? "For angle (degrees) = ";
    ? usg "###";degrees;
    ?" (or ";
    ? usg "#.00";rad(degrees);
    ?" radians ) the TANgent is ";
    ? usg "#####.0000";tan(rad(degrees))  '<== typical to convert degrees to radians (with RAD) before TAN call
    next
    ?:?"As the TANgent approaches 90 or 270 degrees the TANgent becomes 1/0 which is undefined."
    pause

I should make clear, TAN is not used directly for drawing on screen but
indirectly it helps by calculating angles and lengths which is needed
for drawing point to point or step drawing from last drawing x,y point.

Yes, short example like this, or with one single shape on screen, is
very very useful. For instance, I can show an example program of using
bitwise XOR in calculating CRC-32 checksum, which is very useful code.
But nobody will understand anything, because CRC-32 is complicated
algorithm by itself. And it’s very hard to understand how XOR is used in
this algorithm unless you already very experienced with bit
manipulation.

It’s useful to give a short and clear examples, something like: “How can
I draw a line from point (x1,y1) to (x2,y2) using TAN.” Later, if I know
how to draw one line with TAN, then I will be able to draw a 3D box
(maybe..). Small chunks…

TAN use again in a few lines of code but I have to try and explain what
is going on or it would be void of meaning.

    'Short TAN use.bas   SmallBASIC 0.12.2 [B+=MGA] 2016-03-14
    'in the following example it is important to keep in mind
    'x,y when used in TAN are relative positions to x1,y1 and not
    'absolute screen coordinates
    'you can move x1,y1 anywhere on screen!!!!
    x1=250:y1=150 'x,y of point 1 we will mark with yellow circle
    circle x1,y1,2,1,14 'highlight start point in yellow radius 2
    'circle x,y,r,aspect,c   'aspect 1 is circle, !1=ellipse
    'say you want to make a line 60 degrees from x1,y1  and
    'you need the x2 100 greater than x1 or x2 = x1+100
    'since we know TAN=y/x (though you need a diagram to see it)
    'then TAN(RAD(60)) = y/100
    'then 100*TAN(rad(60) = y   by algebraic mult 100 both sides
    'so  y2=y1+100*TAN(rad(60)
    line x1,y1,x1+100,y1+100*TAN(RAD(60))  '<== HERE IS TAN
    'so here we used TAN to calculate the y change in height
    'from y1 to create a 60 angle from point x1,y1 and x2,y2 AND
    'AND make it so x2=100 more than x1
    'check draw arc at x1,y1 with 100 radius
    'for 0 degrees start to 60=2*pi/6 radians end arc, 1=aspect
    arc x1,y1,100,0,2*pi/6,1,14 '14=color yellow
    pause

SUPREME; BRILLIANT; WELL DOCUMENTED; PRACTICAL; USEFUL; MERCIFUL, KNOCKS
OUT.

And the final jump back spinning kick (AKA jump hook kick): EVEN ME CAN
UNDERSTAND IT AND PRACTICALLY USE IT !> I could never grasp those holy
Aztec keywords… TAN, ASIN… and with H !!! ASINH… Mercy!.

Please continue this way… Gravely.

P.S. sorry for starting a new “comment” - my screen is so small that I
cannot see the message by using “reply”.

I guess I hit the spot. :)) I drew your cube just by defining 4 points
for one square face and then using this code for the back 4 points.

But I didn’t stop there. I turned TAN(RAD(60) to TAN(RAD(angle) and put
an angle increase in a loop and when… … well, I spent the night bouncing
and spinning and growing/shrinking the cube. ;)

You certainly hit the spot. “… well, I spent the night bouncing and
spinning and growing/shrinking the cube. ;)”>

I know holistic therapist who cured other programmers… Look, I’ve made
an example program for CIRCLE, using your TAN lesson! But I only changed
the TAN with SIN, and it works…. Now please, repeat that same lesson of
TAN - for SIN. So I’ll understand why and how it works (just copy the
TAN lesson “TAN use again” and update it to explain how SIN works).

+========================================================================================+
|                                     250. (Math) TANH                                   |
+========================================================================================+

TANH (x)

Tangent.

+========================================================================================+
|                                    251. (String) ASC                                   |
+========================================================================================+

ASC (s)

Returns the ASCII code of first character of the string s.

Also see CHR


    ' LOCATE MOD CHR ASC.bas  SmallBASIC 0.12.2 [B+=MGA] 2016-03-23
    ' LOCATE row, column - sets the next print location on screen, rows down, columns across
    ' a MOD b - returns the remainder of a/b as integer 0 to b-1
    '           for example odd number n mod 2 returns 1, while even number n mod 2 returns 0
    '           n mod 10 returns 0,1,2,3,4,5,6,7,8 or 9  we will use this is demo
    ' CHR - returns the CHaRracter for the ASC number, for demo we will print a chart of CHR for ASC numbers 32-128
    ' ASC(Character) - is a number code for a print characters, 32 is the code for a space
    ' ? - is shortcut for PRINT
    ' RIGHT(string,n) - returns right most n characters of string
    ' STR(n) - returns a number in string form
    ' : - code statement seperator often used with LOCATE row, column : ? string
    ' PAUSE optional-number-of-secs - waits for key press or mouse click and/or for a number seconds 
    ' so lets user decide how long to wait
    LOCATE 1,16 : ? "ASC Table 30-129:"  ' locate print spot, print title for our app
    FOR column=0 to 9 'print a header, 10 numbers plus + (to add to row value)
      LOCATE 2,column*5+4 : ? "+";column
    NEXT
    FOR row=3 to 12
      LOCATE row,0 : ? RIGHT(" "+STR(row*10)+":",4)
    NEXT
    'main table
    FOR ASCnumber=30 to 129   'note ASC(32) = space so wont see anything in Table
      row=ASCnumber\\10 ' \\ rounds division down to integer
      column=(ASCnumber MOD 10)*5+5  'times 5 to space out the characters printed plus 5 for column labels
      LOCATE row,column : ? CHR(ASCnumber)
    NEXT
    PAUSE

+========================================================================================+
|                                    252. (String) BCS                                   |
+========================================================================================+

BCS (s)

Converts (B)ASIC-style strings to (C)-style (S)trings.


    ' Note: BCS allows to save special formatting characters as a regular text (or
    '       you could directly use C-Style formatting without using BCS at all).
    ' --- Formatting strings/characters/functions:
    ' " and \\ are common to SB and C - so to avoid problems use C-Style directly:
    Const DQM = "\\x22" ' " character as C-Style string (Double Quotation Mark)
    Const BKS = "\\x5C" ' \\ character as C-Style string (Back Slash)
    ' CHR(0) signals the End-Of-String in C-String (Null-Terminated-String):
    Const NTS = "\\0"   
    ' Special formating strings:
    Const CSI = Chr(27) + "["      ' Control Sequence Introducer
    Const CSI_NORMAL = CSI + "0m"  ' Reset all terminal attributes
    Const CSI_YELLOW = CSI + "33m" ' Supported foreground colors (30m-37m)
    Const CSI_CYAN   = CSI + "36m"
    Const CSI_WHITE  = CSI + "37m"
    Const CSI_BOLD   = CSI + "1m"  ' = Cat(1)
    Const CSI_ULINE  = CSI + "4m"  ' = Cat(2)
    ' Special formating characters:
    Const C0_HT = Chr(9)           ' HT  - Horizontal Tabulation (tab) (-C- \\t)
    Const C0_LF = Chr(10)          ' LF  - Line Feed (-C- \\n)
    Const C0_FF = Chr(12)          ' FF  - Form Feed (clear screen) (-C- \\f)
    Const C0_CR = Chr(13)          ' CR  - Carriage Return (-C- \\r)
    Const C0_NL = C0_CR + C0_LF    ' CNL - Cursor Next Line (Windows style for \\n)
    Def tb(n) = String(n, C0_HT)   ' few tabs (HT)
    Def nl(n) = String(n, C0_NL)   ' few New lines (CNL)
    ' Headings text formats:
    Const NEW_PAGE = Bcs(CSI_NORMAL + C0_FF)
    Def H1(s) = Bcs(nl(2) + tb(5) + CSI_BOLD + CSI_WHITE + s + CSI_NORMAL + nl(1))
    Def H2(s) = Bcs(nl(1) + tb(1) + CSI_ULINE + CSI_YELLOW + s + CSI_NORMAL + nl(1))
    Def H3(s) = Bcs(nl(1) + tb(2) + CSI_ULINE + CSI_CYAN + s + CSI_NORMAL + nl(1))
    ' Normal text formats:
    Func T2(s) = Bcs(tb(1) + s)
    Func T3(s) = Bcs(tb(2) + s)

    ' --- Start demo:
    ' Convert some text to C-Style strings, and append to t array:
    t << NEW_PAGE
    t << H1("Main Title")
    t << H2("Sub Title")
    t << T2("Some " + DQM + "text" + DQM + " in English,")
    t << T2("Some " + BKS + "more text" + BKS + " in English -")
    t << T2("And even more text in English.")
    t << H3("Sub-Sub Title")
    t << T3("And again! text in English;")
    t << T3("That's it." + NTS + "This text is hidden from C ... :)")
    ' Save t array in a Regular text file (as C-Style strings):
    Tsave "demo-doc.txt", t
    ' Load lines from text file into a array:
    Tload "demo-doc.txt", a 
    ' Convert C-Style strings back to Basic-Style strings and print them:
    For i in a
      ? Cbs(i)
    Next
    Pause
    ' "demo-doc.txt" file will contain these lines:
    ' ---------------------------------------------
    ' \\e[0m\\f
    ' \\r\\n\\r\\n\\t\\t\\t\\t\\t\\e[1m\\e[37mMain Title\\e[0m\\r\\n
    ' \\r\\n\\t\\e[4m\\e[33mSub Title\\e[0m\\r\\n
    ' \\tSome \\x22text\\x22 in English,
    ' \\tSome \\x5Cmore text\\x5C in English -
    ' \\tAnd even more text in English.
    ' \\r\\n\\t\\t\\e[4m\\e[36mSub-Sub Title\\e[0m\\r\\n
    ' \\t\\tAnd again! text in English;
    ' \\t\\tThat's it.\\0This text is hidden from C ... :)

+========================================================================================+
|                                    253. (String) BIN                                   |
+========================================================================================+

BIN (x)

Returns the binary value of x as string.

+========================================================================================+
|                                    254. (String) CBS                                   |
+========================================================================================+

CBS (s)

Converts (C)-style strings to (B)ASIC-style (S)trings.


    ' See 'C - Strings' (http://www.tutorialspoint.com/cprogramming/c_strings.htm)
    ' to learn about strings in C language.
    ' See 'Escape sequences in C' (https://en.wikipedia.org/wiki/Escape_sequences_in_C)
    ' for "Table of escape sequences".

    ' --- Compare C string to SmallBASIC string (code...):
     ' C string (very compact):
    ? Cbs("         \\r\\n\\n\\t\\x22No \\tmore \\tCoffee...??!\\x22\\a")
    Pause
    ' The equivalent SmallBASIC string (code): 
    ? "         ";
    Locate Ypos, 0: ?: ?: ? ,; ' \\r\\n\\n\\t
    ? Chr(34); "No ", "more", "Coffee...??!" + Chr(34) + Chr(7) ' \\x22No \\tmore \\tCoffee...??!\\x22\\a"
    Pause

    ' --- Print few demo strings as SmallBASIC and C: 
    Def cs(s) = Cat(3) + Cbs(s) + Cat(-3) ' C string in reverse color
    Const SP = " <--> "
    ' "SmallBASIC string" <--> "C string":
    ? "Hello\\f World!"; SP; cs("Hello\\f World!")  ' \\f = Formfeed (clear screen)
    ? "Hello\\0 World!"; SP; cs("Hello\\0 World!")  ' \\0 = null-terminated string
    ? "\\tHello World!"; SP; cs("\\tHello World!")  ' \\t = Horizontal Tab
    ? "Hello\\n World!"; SP; cs("Hello\\n World!")  ' \\n = Newline
    ? "Hello World\\r!"; SP; cs("Hello World\\r!")  ' \\r = Carriage Return (home pos)
    ? "Hello World\\a!"; SP; cs("Hello World\\a!")  ' \\a = Alarm (Beep, Bell)
    ? "Hello \\x22World!\\x22"; SP; cs("Hello \\x22World!\\x22")  ' \\xhh char as hexadecimal number
    Pause 

+========================================================================================+
|                                    255. (String) CHOP                                  |
+========================================================================================+

CHOP (source)

Chops off the last character of the string ‘source’ and returns the
result.

+========================================================================================+
|                                    256. (String) CHR                                   |
+========================================================================================+

CHR (x)

Returns one-char string of character with ASCII code x.

The CHR command is useful for obtaining and printing the escape
character (ASCII 27) For example:

    10 PRINT CHR(27) + "[1mTHIS IS BOLD" + CHR(27) + "[0m"
    20 PRINT CHR(27) + "[3mThis is italic" + CHR(27) + "[0m"
    30 PRINT CHR(27) + "[4mThis is underline"

    rem display the ASCII and the extended tables
    For n = 0 To 255
      If n = 0 Then
        Color 15, 0: Locate 1, 1
        Print "Standard 7-bit ASCII table (character codes 0 - 127):";
      Elseif n = 128 Then
        Pause
        Color 15, 0: Cls: Locate 1, 1
        Print "Nonstandard 8-bit Extended table (character codes 128 - 255):";
      Endif
      If n <= 31 Then ' control characters (e.g. new-line, tab, etc).
        Read c
      Elseif n = 32 Then ' regular space (invisible...)
        c = "sp"
      Elseif n = 127 Then ' lonesome control character "del"
        c = "del"
      Else
        c = Chr(n) ' ASCII code --> character
      Endif
      Locate (n Mod 16) + 3, (((n \\ 16) Mod 8) * 9) + 1

      Color 7: Print Using "000 "; n; ' ASCII code
      Color 14: Print c; ' ASCII (or ANSI) character
    Next
    Color 7, 0: Print: Print
    Print " * Nonstandard characters might look different on another system."
    Pause
    End
    ' nonprintable control characters (ASCII codes 0..31):
    Data "nul", "soh", "stx", "etx", "eot" ' 0..4
    Data "enq", "ack", "bel", "bs" , "tab" ' 5..9
    Data "lf" , "vt" , "np" , "cr" , "so"  ' 10..14
    Data "si" , "dle", "dc1", "dc2", "dc3" ' 15..19
    Data "dc4", "nak", "syn", "etb", "can" ' 20..24
    Data "em" , "eof", "esc", "fs" , "gs"  ' 25..29
    Data "rs" , "us"  ' 30..31

+========================================================================================+
|                                  257. (String) DISCLOSE                                |
+========================================================================================+

DISCLOSE (str[, pairs [, ignore-pairs]])

Discloses a string.

Default pairs and ignore pairs

  --------------------------------- ------- --------
  First non white-space character   Check   Ignore
  "                                 ""      ’’
  ’                                 ’’      ""
  (                                 ()      ""’’
  [                                 []      ""’’
  {                                 {}      ""’’
  <                                 <>      ""’’
  "                                 ""      ’’
  --------------------------------- ------- --------

    s = "abc (abc)"
    ? s; tab(26); disclose(s, "()")
    ' prints abc
    s = "abc (a(bc))"
    ? s; tab(26); disclose(s, "()"); tab(40); disclose(disclose(s, "()"), "()")
    ' prints a(bc), bc
    s = "abc (a='(bc)')"
    ? s; tab(26); disclose(s, "()", "''"); tab(40); &
        disclose(disclose(s, "()", "''"), "()", "''")
    ' prints a='(bc)', nothing

+========================================================================================+
|                                  258. (String) ENCLOSE                                 |
+========================================================================================+

ENCLOSE (str[, pair])

Encloses a string.

    ? enclose("abc", "()")
    ' Result: (abc)

ENCLOSE defaults to double quotes if the [pair] option is not used.


    test=10
    myStr="myStr"
    ? enclose(test)
    ? enclose(myStr)
    pause

+========================================================================================+
|                                   259. (String) FORMAT                                 |
+========================================================================================+

FORMAT (format, val)

Returns a formated string.

Numbers:

-   ‘#’ Digit or space
-   0 Digit or zero
-   ^ Stores a number in exponential format. Unlike QB’s USING format
    this is a place-holder like #.
-   . The position of the decimal point.
-   , Separator.
-   - Stores minus if the number is negative.
-   + Stores the sign of the number.

Strings:

-   & Stores a string expression without reformatting it.
-   ! Stores only the first character of a string expression.
-   \\ Stores only the first n + 2 characters of a string expression,
    where n is the number of spaces between the two backslashes.

Unlike QB, there can be literals inside the \ \. These literals are
inserted in the final string.

    ? FORMAT("#,##0", 1920.6) : REM prints 1,921
    ? FORMAT("\\  - \\", "abcde") : REM prints "abc-de"

PRINT USING and FORMAT use same or similar character codes, here are
some practical examples of use, including the creating of a reusable
Money function that returns a flexible length string for a money amount
(dollars and cents format).

    rem USING FORMAT Money.bas 2016-03-06 SmallBASIC 0.12.2 [B+=MGA]
    rem PRINT USING is excellent for columns of numbers

    columnformat="#,###,###.0000     " '<=== oh it does spaces too!
    for i=1 to 50
      print usg columnformat;rnd*10000000000/1000;
      if i mod 5=0 then print '<== after printing 5 numbers on line use print to start next line
    next
    ?:?
    'A problem with PRINT USING is that it needs a whole statement to itself,
    ' unlike PRINT that can print a list of expressions in a single statement (with ; , or +)
    ' another problem with USING, # is that they are place holders which is nice
    ' for column of numbers but not in following:
    currency="$-###,###,###,###,###,###.00"
    bignumber="###,###,###,###,###,###"
    onetrillion=1000000000000
    workers=150000000
    ? using currency;onetrillion;
    ?" divided by ";
    ? usg bignumber;workers;  '<=== usg is short for using
    ?" working people is ";
    ? usg currency;onetrillion/workers;
    ?" per working person."
    ?:?
    'Yuck! we need to trim things up, FORMAT works nicely with TRIM
    division="$ "+trim(format(bignumber,onetrillion/workers))
    onetrillion1="$ "+trim(format(bignumber,onetrillion))
    workers1=trim(format(bignumber,workers))
    ? onetrillion1+" divided by "+workers1;" working people is ";division;" per working person."
    ?:?
    'lets use what we learned here and make a reusable function: money
    ? money(onetrillion);" divided by ";workers1;" working people is "+money(onetrillion/workers)+" per working person."
    ?:?
    'test money in columns, dang we need to have the same length strings use RIGHT and SPACE
    for i=1 to 50
      if rnd>.5 then posneg=1 else posneg=-1
      print right(space(15)+money(rnd*10000000000/1000*posneg),20);
      if i mod 5=0 then print '<== after printing 5 numbers on line use print to start next line
    next
    pause
    func money(dollarsandcents) 'oh - numbers are saved
      money="$ "+trim(format("###,###,###,###,###,###.00",dollarsandcents))
    end

Must add extra space after ‘\’, if not there is an error:

    ? format("\\ _ \\", "abcde")   ' --> error missing ')'
    ? format("\\ _ \\ ", "abcde")  ' --> "ab_cd "
    ? format("\\  _ \\ ", "abcde") ' --> "abc_de "
    ? Usg "\\ _ \\"; "abcde"   ' --> error or prints nothing
    ? Usg "\\ _ \\ "; "abcde"  ' --> "ab_cd "
    ? Usg "\\  _ \\ "; "abcde" ' --> "abc_de "

+========================================================================================+
|                                    260. (String) HEX                                   |
+========================================================================================+

HEX (x)

Returns the hexadecimal value of x as string.

+========================================================================================+
|                                   261. (String) INSTR                                  |
+========================================================================================+

INSTR ([start,] s1, s2)

Returns the position of the first occurrence of the string s2 into
string s1 (starting from the position ‘start’). If there is no match,
INSTR returns 0


    ' INSTR oddity.bas  SmallBASIC 0.12.2 [B+=MGA] 2016-03-08
    'this oddity was discovered with inkey failure to work as expected
    ?instr("ABCD","")    'aha! returns 1
    pause
    'end
    'I am trying to figure out why the following code wont work, it's because instr("anything","")=1
    while 1
    s=" x=exit n=nice r=random g=globe"
    at (xmax-txtw(s))\\2,0:?s
    repeat 
      ink=inkey
      ink=upper(ink)
      delay 20
    'until ink="X" or ink="Q" or ink="N" or ink="R" or ink="G" '<= this works great!
    until instr("XQNRG",ink)>0 '<==== this refuses to work right
    cls
    at 0,3*txth("Q"):? "You pressed '";ink;"'"
    ? " instr XQNRG,ink  '";instr("XQNRG",ink);"'  press any..."
    pause
    if ink="X" then ? "Goodbye":end
    wend

+========================================================================================+
|                                    262. (String) JOIN                                  |
+========================================================================================+

JOIN words(), delimiters, string

Returns the words of the specified string into array ‘words’.

    s="/etc/temp/filename.ext"
    SPLIT s, "/.", v()
    JOIN v(), "/", s
    PRINT "[";s;"]"
    displays:
    [/etc/temp/filename/ext]

+========================================================================================+
|                                   263. (String) LCASE                                  |
+========================================================================================+

LCASE (s)

Converts the string s to lower case.

+========================================================================================+
|                                    264. (String) LEFT                                  |
+========================================================================================+

LEFT (s [,n])

Returns the n number of leftmost chars of string s. if not specified n =
1.

+========================================================================================+
|                                   265. (String) LEFTOF                                 |
+========================================================================================+

LEFTOF (s1, s2)

Returns the left part of s1 at the position of the first occurrence of
the string s2 into string s1.


    s1 = "small*SMALL*BASIC*basic"
    s2 = "*"
    Color 15
    ? "s1 parameter is:     "; s1
    ?
    ? "s2 parameter is:     "; s2
    ?
    ?
    Color 7
    ? "Leftof(s1, s2)                = "; Leftof(s1, s2)
    ? "Left(s1, Instr(s1, s2) - 1)   = "; Left(s1, Instr(s1, s2) - 1)
    ?
    ? "Leftoflast(s1, s2)            = "; Leftoflast(s1, s2)
    ? "Left(s1, Rinstr(s1, s2) - 1)  = "; Left(s1, Rinstr(s1, s2) - 1)
    ?
    ? "Rightof(s1, s2)               = "; Rightof(s1, s2)
    ? "Right(s1, Rinstr(s1, s2) - 1) = "; Right(s1, Rinstr(s1, s2) - 1)
    ?
    ? "Rightoflast(s1, s2)           = "; Rightoflast(s1, s2)
    ? "Right(s1, Instr(s1, s2) - 1)  = "; Right(s1, Instr(s1, s2) - 1)
    ?
    ?
    ? "Leftof(s1, s2) + Rightoflast(s1, s2): "; Leftof(s1, s2) + Rightoflast(s1, s2)
    Pause

+========================================================================================+
|                                 266. (String) LEFTOFLAST                               |
+========================================================================================+

LEFTOFLAST (s1, s2)

Returns the left part of s1 at the position of the last occurrence of
the string s2 into string s1.

+========================================================================================+
|                                   267. (String) LOWER                                  |
+========================================================================================+

LOWER (s)

Converts the string s to lower case.

+========================================================================================+
|                                   268. (String) LTRIM                                  |
+========================================================================================+

LTRIM (s)

Removes leading white-spaces from string s.

+========================================================================================+
|                                    269. (String) MID                                   |
+========================================================================================+

MID (s, start [,length])

Returns the part (length) of the string s starting from ‘start’
position.

If the ‘length’ parameter is omitted, MID returns the whole string from
the position ‘start’.

+========================================================================================+
|                                    270. (String) OCT                                   |
+========================================================================================+

OCT (x)

Returns the octal value of x as string.

+========================================================================================+
|                                  271. (String) REPLACE                                 |
+========================================================================================+

REPLACE (source, pos, str [, len])

Writes str into pos of source and returns the new string.

This function replaces only _len_ characters. The default value of _len_
is the length of _str_.

    s="123456"
    ...
    ' Cut
    ? replace(s,3,"",len(s))
    ...
    ' Replace
    ? replace(s,2,"bcd")
    ...
    ' Insert
    ? replace(s,3,"cde",0)
    ...
    ' Replace & insert
    ? replace(s,2,"RRI",2)

    'replace test.bas 2016-02-26
    'function replace(source,pos,str [,len])     len of source is default
    s="123456"
    ' Cut
    ? replace(s,3,"",len(s)) 'returns 12
    ? replace(s,3,"")        'returns 123456
    ? replace(s,3,"",1)      'returns 12456  yes!
    ' Replace
    ? replace(s,2,"bcd") 'returns 1bcd56
    ' Insert
    ? replace(s,3,"cde",0) 'returns 12cde3456
    ' Replace & insert
    ? replace(s,2,"RRI",2) 'returns 1RRI456
    pause

    ' Helper to print the "name of color" with its color:

      Const ESCS = Chr(27) + "["
      Const BG_BLACK = ESCS + "40m"
      Const BG_RED = ESCS + "41m"
      Const BG_GREEN = ESCS + "42m"
      Const BG_BLUE = ESCS + "44m"
      Const BG_YELLOW = ESCS + "43m"
      s = Translate(s, "Red",    BG_RED + "Red" + BG_BLACK)
      s = Translate(s, "Green",  BG_GREEN + "Green" + BG_BLACK)
      s = Translate(s, "Blue",   BG_BLUE + "Blue" + BG_BLACK)
      s = Translate(s, "Yellow", BG_YELLOW + "Yellow" + BG_BLACK)
      s = Translate(s, " ", "_")
      colors = s  
    End Func
    Def lset(s) = Replace(Space(30), 1, s + ": ")  ' left justify s in buffer

    ' Text to replace:
    Const TEXT = "Red Green Blue"
    Const Len_TEXT = Len(TEXT)
    Const BLANKS = Len_TEXT - Len(Translate(TEXT, " ", "")) ' number of blanks in TEXT

    ' Syntax: REPLACE (source, pos, str [, len]):
    ? lset("TEXT is"); colors(TEXT)
    ?
    ? lset("Replace Green with Yellow"); colors(Replace(TEXT, 5, "Yellow", 5))
    ? lset("Append Yellow");             colors(Replace(TEXT, Len_TEXT + 1, " Yellow"))
    ? lset("Prepend Yellow");            colors(Replace(TEXT, 1, "Yellow ", 0))
    ? lset("Insert Yellow after Red");   colors(Replace(TEXT, 5, "Yellow ", 0))
    ?
    ? lset("Delete Green"); colors(Replace(TEXT, 5, "", 6))
    ? lset("Chop Red");     colors(Replace(TEXT, 1, "", 4))
    ? lset("Chop Blue");    colors(Replace(TEXT, Instr(TEXT, " Blue"), "", Len(" Blue")))
    ?
    ? lset("Left justify TEXT in buffer");  colors(Replace(Space(30), 1, TEXT))
    ? lset("Right justify TEXT in buffer"); colors(Replace(Space(30), 30 - Len_TEXT + 1, TEXT))
    ? lset("Center TEXT in buffer");        colors(Replace(Space(30), 15 - (Len_TEXT \\ 2) + 1, TEXT))
    ? lset("(Justify TEXT in buffer)"); colors(Translate(TEXT, " ", Space((30 + BLANKS - Len_TEXT) / BLANKS)))
    ?
    ? lset("Replace TEXT with Yellow");  colors(Replace(TEXT, 1, "Yellow", Len_TEXT))
    ? lset("Override TEXT with Yellow"); colors(Replace(TEXT, (Len_TEXT / 2) - 3 + 1, "Yellow"))
    ? lset("Delete TEXT");               colors(Replace(TEXT, 1, "", Len_TEXT))
    ? lset("Create TEXT");               colors(Replace("", 1, TEXT))
    Pause

+========================================================================================+
|                                   272. (String) RIGHT                                  |
+========================================================================================+

RIGHT (s[,n])

Returns the n number of rightmost chars of string s. if not specified n
= 1.

+========================================================================================+
|                                  273. (String) RIGHTOF                                 |
+========================================================================================+

RIGHTOF (s1, s2)

Returns the right part of s1 at the position of the first occurrence of
the string s2 into string s1.

+========================================================================================+
|                                274. (String) RIGHTOFLAST                               |
+========================================================================================+

RIGHTOFLAST (s1, s2)

Returns the right part of s1 at the position of the last occurrence of
the string s2 into string s1.

+========================================================================================+
|                                   275. (String) RINSTR                                 |
+========================================================================================+

RINSTR ([start,] s1, s2)

Returns the position of the last occurrence of the string s2 into string
s1 (starting from the position ‘start’).

If there is no match, RINSTR returns 0

+========================================================================================+
|                                   276. (String) RTRIM                                  |
+========================================================================================+

RTRIM (s)

Removes trailing white-spaces from string s.

+========================================================================================+
|                                   277. (String) SINPUT                                 |
+========================================================================================+

SINPUT src; var [, delim] [,var [, delim]] ...

Splits the string ‘src’ into variables which are separated by
delimiters.

    SINPUT "if x>1 then y"; vif, " ", vcond, "then", vdo
    ? vcond, vdo
    ' result=
    ' x>1   y

+========================================================================================+
|                                   278. (String) SPACE                                  |
+========================================================================================+

SPACE (n)

Returns a string of n spaces.


    ' s is a string ("" or longer); l is length of buffer (0+);
    Def lset(s, l) = Left(s + Space(l), l) ' left justify text
    Def rset(s, l) = Right(Space(l) + s, l) ' right justify text
    Const buffer = 10 ' length of buffer
    While True Do
      Color 7, 0: Cls
      Print "[ Using a buffer of "; buffer; " spaces ]"
      Print
      Input "Enter text into buffer (Enter 'S' to stop): ", text
      IF text = "S" Or text = "s" Then
        Stop
      Endif
      Color 7, 0: Locate 5, 0: Print "Left justified:  ";
      Color 0, 7: Print lset(text, buffer);
      Color 7, 0: Locate 7, 0: Print "Right justified: ";
      Color 0, 7: Print rset(text, buffer);
      Pause 
    Wend

+========================================================================================+
|                                    279. (String) SPC                                   |
+========================================================================================+

SPC (n)

Returns a string of n spaces.

These are excellent for maintaining a fixed length string or buffer or
record or refining screen output by inserting a specified amount of
spaces in a string. This works well with LEFT and RIGHT keywords for
Left Center or Right aligning text.


    'here are right aligned numbers in 10 character length string between two single quote marks
    while 1
      myNumber=(rnd*10^(rnd*4)\\1)\\1
      ? "'";RIGHT(SPC(10)+STR(myNumber),10);"'";SPC(3)+"press a key or click for next..."
      pause
    wend

I think SPACE and SPC are both the same, see also SPACE.

+========================================================================================+
|                                   280. (String) SPLIT                                  |
+========================================================================================+

SPLIT string, delimiters, words() [, pairs] [USE expr]

Returns the words of the specified string into array ‘words’.

    s="/etc/temp/filename.ext"
    SPLIT s, "/.", v()
    FOR i=0 TO UBOUND(v)
      PRINT i;" [";v(i);"]"
    NEXT

displays:

    0 []
    1 [etc]
    2 [temp]
    3 [filename]
    4 [ext]

+========================================================================================+
|                                   281. (String) SPRINT                                 |
+========================================================================================+

SPRINT var; [USING...;] ...

Create formated string and storing it to var. See also: PRINT command.

    SPRINT s; 12.34; TAB(12); 11.23;

_Note: you can use ‘USG’ instead of ‘USING’._

+========================================================================================+
|                                  282. (String) SQUEEZE                                 |
+========================================================================================+

SQUEEZE (s)

Removes all leading, trailing and duplicated white-space.

    ? "["; SQUEEZE(" Hi  there "); "]"
    ' Result: [Hi there]

+========================================================================================+
|                                    283. (String) STR                                   |
+========================================================================================+

STR (n)

Converts the number n into a string.

+========================================================================================+
|                                   284. (String) STRING                                 |
+========================================================================================+

STRING ( count [,start | s] )

Creates a new string of count length.


    Def rainbow = Floor((Rnd * 100) Mod 16) ' random text color 0 to 15
    ' parameters for printing a box:
    Const ROW = 2
    Const COLUMN = 1
    Const HEIGHT = 8
    Const WIDTH = 9

    While True Do
      Color 7, 0: Cls
      Input "Enter 1 to 5 character(s) [Enter empty to stop]"; c
      c = Left(Str(c), 5) ' 12 -> "12"; 0 -> "0",  etc
      If Empty(c) Then ' c is ""?
        Stop
      Endif

      ' print box top line:
      Color rainbow: Locate ROW, COLUMN: Print String(WIDTH, c);
      ' print box vertical lines:
      v_lines = c + Space((WIDTH - 2) * Len(c)) + c
      For r = ROW + 1 To ROW + HEIGHT - 2 Do
        Color rainbow: Locate r, COLUMN: Print v_lines;
      Next
      ' print box down line:
      Color rainbow: Locate ROW + HEIGHT - 1, COLUMN: Print string(WIDTH, c);

      Color 7: Locate ROW + HEIGHT + 2, COLUMN: Print "Press any key...";
      Pause
    Wend

I wasted a day trying to figure what “Invalid parameter” was causing a
Mastermind program from crashing under certain circumstances. Turns out
STRING can’t handle a 0 value in first argument. It would have been nice
if the program stopped on that statement instead all the other places it
had.


    'in this little example code does stop with cursor on the wrong line
    cows = 2
    ? string(3,"Bulls")+string(cows,"Cows") 'returns BullsBullsBullsCowsCows
    cows =0
    ? string(3,"Bulls")+string(cows,"Cows") 'Error: "Invalid parameter"
    pause
    end

How to understand this syntax “STRING ( count [,start | s] )”:

    ' start is an ASCII value of a string character:
    x = STRING(2, ASC("Hello "))
    ? x ' --> x is "HH"
    ' s is a string of any length:
    x = STRING(2, "Hello ")
    ? x ' --> x is "Hello Hello "

+========================================================================================+
|                                 285. (String) TRANSLATE                                |
+========================================================================================+

TRANSLATE (source, what [, with])

Translates all occurrences of the string ‘what’ found in source with the
string ‘with’ and returns the new string.

    ? Translate("Hello world", "o", "O")
    ' displays: HellO wOrld

+========================================================================================+
|                                    286. (String) TRIM                                  |
+========================================================================================+

TRIM(s)

Removes all leading and trailing white-space.

+========================================================================================+
|                                   287. (String) UCASE                                  |
+========================================================================================+

UCASE (s)

Converts the string s to upper case.


    'The case of UPPER vs UCASE.bas  SmallBASIC 0.12.2 [B+=MGA] 2016-03-12
    '
    test="capital idea"
    if upper(test)=ucase(test) then ?"UPPER and UCASE do the same thing." else ?"UPPER and UCASE are different."
    pause

output: UPPER and UCASE do the same thing.

+========================================================================================+
|                                   288. (String) UPPER                                  |
+========================================================================================+

UPPER (s)

Converts the string s to upper case.

Yes, you should see the comment in UCASE.

+========================================================================================+
|                                    289. (String) VAL                                   |
+========================================================================================+

VAL (s)

Returns the numeric value of string s.

Here is an opportunity for enhancing SmallBASIC’s function VAL, this
EVAL is only beginning of what might be done.


    ' VAL test.bas  SmallBASIC 0.12.2 [B+=MGA] 2016-04-05
    s1="123.234*4+1000/2"
    ? val(s1)
    ? eval(s1)
    pause
    func eval(numericexpressionstring)
      'working left to right, no parenthesis
      e=0:cmd="+":ds=""
      for i=1 to len(numericexpressionstring)
        c=mid(numericexpressionstring,i,1)
        if instr("0123456789.",c) then ds=ds+c
        if instr("+-*/",c) or i=len(numericexpressionstring) then
          'execute last cmd if one
          if cmd<>""  then
            d=val(ds)
            select case cmd
            case "+":e=e+d
            case "-":e=e-d
            case "*":e=e*d
            case "/":e=e/d
            end select
            ds="":cmd=""
          end if
          if i<>len(numericexpressionstring) then cmd=c
        end if
      next
      'eval=str(e) '<=== I am setting up something for Turtle strings
      eval=e        '<=== normal people and usage might want this
    end

Math EVAL function = evaluates a string as though it were an expression
and returns a result.

I’ve written in Euphoria 4 correct math EVAL function, you can download
it and see how it works, if you’re really into it:
rapideuphoria.com*math_eval_v1_1_0.zip

It is straightforward to translate that Euphoria code into SmallBASIC
code. EVAL must be around here somewhere, it is a classic. I thought I
might find a version in TinyBASIC but I am too much into getting a
turtle string to repeat to hunt for it at moment.

The VAL command just converts a string to a number. For EVAL type
functionality, the CHAIN command is somewhat similar.

+========================================================================================+
|                                   290. (System) CHAIN                                  |
+========================================================================================+

CHAIN source

Compile and run the given source. Source can be a file name, a line of
code or an array of code. Use ENV to share variables with the parent
process.


    ' Note: CHAIN behaves like EVAL function in other languages.
    Option Base 1 ' (for 'IN' keyword which is 1-Based)
    ' Code using constants:
    Chain "? \\"100 + 50 is: \\"; 100 + 50: Pause" ' (100 + 50 = 150)

    ' Code using variables:
    Env "SB1=6" ' add two unique variables (for reuse)
    Env "SB2=2"
    Chain "? Env(\\"SB1\\") ^ Env(\\"SB2\\"): Pause" ' (SB1 ^ SB2 = 36)

    ' Code using an array:
    Env "SB1=3"  ' reuse SB1 variable
    Dim a()          ' append code to array a
    a << "x = Env(\\"SB1\\")"
    a << "For i = 1 To 5"
    a << "? i * x; Spc(1);"
    a << "Next i"
    a << "Pause"
    Chain a ' prints 3 6 9 12 15

    ' Code using a file name (output a array to demo file):
    Const FILE_NAME = "demo.bas"
    Env "SB1=4"  ' reuse SB1 variable
    Open FILE_NAME For Output as #1
    For i In a
      ? #1, i; ":"; ' output all code as a single string, ":";
    Next i
    Close #1
    ?
    Chain FILE_NAME ' prints 4 8 12 16 20

    ' Now append to file name a return value (on the same line):
    Env "SB1=5"  ' reuse SB1 variable
    Open FILE_NAME For Append As #1
    ? #1, "Env \\"SB1=\\" + Str(i):"; ' add extra space or ":"
    Close #1
    ?
    Chain FILE_NAME ' prints 5 10 15 20 25
    Color 15 ' print the return value from file
    ? " (Return value SB1 is: "; Env("SB1"); ")" ' (i is 6)
    Pause


    Const FILENAME = "demo.bas"
    ' Create demo bas file (could be any SmallBASIC file):
    Open FILENAME For Output As #1
    ? #1, "Sub count10(n)"
    ? #1, "  Local i"
    ? #1, "  Color 14"
    ? #1, "  For i = n To 10
    ? #1, "    Print i; " + Enclose(", ") + ";" 
    ? #1, "  Next i"
    ? #1, "  Env " + Enclose("SB1=") + " + Str(i) ' return value to parent
    ? #1, "End Sub"
    ? #1, 
    ? #1, "Color 7: ? " + Enclose("I'm The Child Program...! I can count!") + ": ?"
    ? #1, 
    ? #1, "n = Val(Env(" + Enclose("SB1") + ")) ' get value from parent"
    ? #1, 
    ? #1, "count10 n ' run sub-routine to count n to 10"
    ? #1, 
    ? #1, "?:?"
    Close #1
    ' Load demo bas file into array:
    Tload FILENAME, lines
    Env "SB1=2" ' Set value for child program (1..10)
    ' Execute the demo bas file (the array):
    Chain lines
    ' now print the return value from child program:
    Color 7:  ? "I'm The Parent Program..."
    ?
    Color 15: ? "Child program returned value: "; Env("SB1")
    Pause


    ' Dedicated to MGA.
    ' s is any legal SmallBASIC Math Expression as String, e.g. "1 + 2 / 4"
    Func EVAL(s)
      ' It takes 2 lines of SmallBASIC code to implement Math EVAL Function:
      Chain "Env " + Enclose("SBEVAL=") + " + Str(" + s + ")"
      eval = Val(Env("SBEVAL"))
    End Func

    ' now run few demos:
    ? eval("1+2") ' prints 3, ...
    ? eval("Rad(45) * 2") 
    ? eval("PI / 2 + PI")
    ? eval("0b1111 * Pow(2, 4)")
    ? eval("Sin(2) * Tan(4) / Cos(6)")
    ? eval("1 + 2 / 4")
    ? eval("6 * (Pow(2, 4) * 8)")
    ? eval("Rad((45 * 3) - 20) * 2")
    Pause

+========================================================================================+
|                                  291. (System) COMMAND                                 |
+========================================================================================+

COMMAND

SmallBASIC startup command line options.

SDL version (GUI):> Running the following line from the command line:

    sbasicg -r test.bas "abc xyz fileName"

When “test.bas” is:


    ?  COMMAND
    Pause

Will print “abc xyz fileName” Note: Run ~~~ sbasicg -e test.bas ~~~ to
enable ‘Edit’ mode again.> Non-graphical console version (cygwin or
linux):> (Download from: https://github.com/smallbasic/SmallBASIC)
(Build the source, then run: ./SmallBASIC/src/platform/unix/sbasic)
Running the following line from the command line:

    sbasic test.bas "abc xyz fileName"

When “test.bas” is:


    ?  COMMAND
    ' if you add PAUSE keyword then press Ctrl+C to return to command prompt.

Will print “abc xyz fileName”

+========================================================================================+
|                                    292. (System) CWD                                   |
+========================================================================================+

CWD

Current working directory

+========================================================================================+
|                                   293. (System) DELAY                                  |
+========================================================================================+

DELAY ms

Delay for a specified amount of milliseconds. Note ‘delay’ depends on
the system clock.

+========================================================================================+
|                                    294. (System) ENV                                   |
+========================================================================================+

ENV expr

Adds a variable to or deletes a variable from the current environment
variable-table.

ENV can be used as SUB for setting or erasing Environment Variables (EV)
and ENV can be used as a FUNCtion for returning a particular EV or the
whole set of them into an array using: EVarray=ENV("")


    ' ENV test.bas  SmallBASIC 0.12.2 [B+=MGA] 2016-04-10
    'OK this works
    'OK this is supposed to return an array of my Environment variables
    EVS=ENV("")
    for e in EVS
      ? e
    next
    ?:? "press any..."
    pause
    'wow it worked! I have a load of them...
    'OK now try and set one of my own
    cls
    myEV1="This is a test of ENV."
    ENV "myEV1="+myEV1
    'did it get added to list?
    EVS=ENV("")
    for e in EVS
      ? e
    next
    ?:? "press any..."
    pause
    'YES!
    'OK let's see it
    myEV1return=ENV("myEV1")
    cls
    ? myEV1return
    ?:? "press any..."
    pause
    'now can we erase it?
    ENV "myEV1="
    cls
    ? "myEV1 should be erased, it is now '";ENV("myEV1");"'"
    ?:? "Test of ENV is complete."
    pause
    'yes, it was erased because when I ran same code a second time, it wasn't there THEN!
    ' so it didn't just LOOK erased from a bad call

    ENV "myEV1="

does not erase the variable on Linux… On Linux I could only erase the
variable from a terminal:

    unset $myEV1

In general: 1. Never use names which are already used by the system or
another process, such as “PATH”, “HOME”, “PWD”, etc. You can check which
variable names are already used, from SmallBASIC:

    ? Environ("")

2.  Use short and unique names, such as: “SB1”, SB2" or “SBv1”, “SBv2”,
    etc. It will keep the environment-variables-table readable, and will
    save space in the table.
3.  Don’t create more variables then you need. Reuse any variable which
    is not used. i.e. if “SB1” is unused anymore, then reuse it:

    Environ "SB1=5"

. Again, it keeps the environment-variables-table readable, and saves
space in the table. 4. On some systems the environment-variables-table
is unique for each session (Linux for example) and this may be a bit
confusing. 5. Environment variables may or may not be case sensitive,
i.e. “SB1” may be different then “sb1” on some systems (Linux for
example).

+========================================================================================+
|                                    295. (System) ENV                                   |
+========================================================================================+

ENV expr

Returns the value of a specified entry in the current environment table.
If the parameter is empty ("") then returns an array of the environment
variables (in var=value form).

ENV can be used as SUB for setting or erasing Environment Variables (EV)
and ENV can be used as a FUNCtion for returning a particular EV or the
whole set of them into an array using: EVarray=ENV("")


    ' ENV test.bas  SmallBASIC 0.12.2 [B+=MGA] 2016-04-10
    'OK this works 
    'OK this is supposed to return an array of my Environment variables
    EVS=ENV("")
    for e in EVS
      ? e
    next
    ?:? "press any..."
    pause
    'wow it worked! I have a load of them...
    'OK now try and set one of my own
    cls
    myEV1="This is a test of ENV."
    ENV "myEV1="+myEV1
    'did it get added to list?
    EVS=ENV("")
    for e in EVS
      ? e
    next
    ?:? "press any..."
    pause
    'YES!
    'OK let's see it 
    myEV1return=ENV("myEV1")
    cls
    ? myEV1return
    ?:? "press any..."
    pause
    'now can we erase it?
    ENV "myEV1="
    cls
    ? "myEV1 should be erased, it is now '";ENV("myEV1");"'"
    ?:? "Test of ENV is complete."
    pause
    'yes, it was erased because when I ran same code a second time, it wasn't there THEN!
    ' so it didn't just LOOK erased from a bad call

+========================================================================================+
|                                    296. (System) EXEC                                  |
+========================================================================================+

EXEC file

Transfers control to another operating system program.


    Const IS_LINUX = (Left(HOME, 1) = "/")  ' Check if it's Linux system
    Const IS_WINDOWS = Not IS_LINUX
    Const FILE_NAME = "demo.bas"  ' demo file name

    ' Print header before each mission:
    Sub header(text)
      ? Cbs("\\n\\n" + Cat(0) + Cat(3) + Enclose(text, " ") + Cat(0) + Chr(7))
      Pause
    End Sub

    ' Create demo SmallBASIC file:
    code << "Color 15, 1: ? " + Enclose("Hello World") + ": Pause" ' append line
    Tsave FILE_NAME, code

    ' CHAIN(source)
    '
    '  Compile and run the given source. Source can be a file name, a line of code
    '  or an array of code. Use ENV to share variables with the parent process.
    header "Press a key to Chain another SB program and return afterwards..."
    Chain FILE_NAME ' Chain only executes another SmallBASIC code.

    ' RUN(command)     ' invoked as a COMMAND
    ' x = RUN(command) ' invoked as a FUNC, returning the results of the sub process
    '
    '  With both of these, control returns to the .bas once system 'command'
    '  has completed.
    header "Press a key to Run another program and return afterwards..."
    Select Case 1
      Case IS_LINUX:   Run "gedit " + FILE_NAME
      Case IS_WINDOWS: Run "Notepad " + FILE_NAME
    End Select
    ? "OK."

    ' EXEC(command)
    '
    '  Invoked as a COMMAND, control returns to the .bas immediately and the
    '  system command does it's own thing external to SmallBASIC:
    header "Press a key to Execute another program in the background..."
    Select Case 1
      Case IS_LINUX:   Exec "gedit"
      Case IS_WINDOWS: Exec "Notepad"
    End Select
    ? "Done.";
    Pause

Apparently, RUN/EXEC have bugs in SmallBASIC version 0.12.2…:

RUN/EXEC

There are three modes: 1. RUN(command) ’ invoked as a COMMAND 2.
v=RUN(command) ‘invoked as a FUNC, returning the results of the sub
process With both of these, control returns to the .bas once system
’command’ has completed. 3. EXEC(command) ’invoked as a COMMAND, control
returns to the .bas immediately and the system command does it’s own
thing external to SmallBASIC.

Note: In the android version you can use v=RUN to look at interesting
things in the /proc file system.

+========================================================================================+
|                                   297. (System) EXPORT                                 |
+========================================================================================+

EXPORT thing

Export a SUB, FUNC or variable from a UNIT to be used by the unit
consumer.

+========================================================================================+
|                                    298. (System) FRE                                   |
+========================================================================================+

FRE (x)

Returns system information. eg, 0 = free memory,

Where x: QB-standard:

  ----- ---------------------------
  0 f   ree memory
  -1    largest block of integers
  -2    free stack
  -3    largest free block
  ----- ---------------------------

Our standard (it is optional for now):

  ----- -----------------------
  -10   total physical memory
  -11   used physical memory
  -12   free physical memory
  ----- -----------------------

Optional-set #1:

  ----- ---------------------------
  -13   shared memory size
  -14   buffers
  -15   cached
  -16   total virtual memory size
  -17   used virtual memory
  -18   free virtual memory
  ----- ---------------------------

Optional-set #2:

  ----- --------------------------------
  -40   battery voltage * 1000
  -41   battery percent
  -42   critical voltage value (*1000)
  -43   warning voltage value (*1000)
  ----- --------------------------------

The optional values will return 0 if not supported.

+========================================================================================+
|                                    299. (System) HOME                                  |
+========================================================================================+

HOME

User HOME folder

+========================================================================================+
|                                   300. (System) IMPORT                                 |
+========================================================================================+

IMPORT

Import an exported UNIT variable, SUB or FUNC.

+========================================================================================+
|                                  301. (System) INCLUDE                                 |
+========================================================================================+

INCLUDE source-file.bas

Inserts code in the named file when the program is compiled.

INCLUDE is not in the main list for the Language reference. But here it
is, right after IMPORT under the System category! Here is part_1.bas,
the first part of our long program:


    ' "part_1.bas" demo file for INCLUDE keyword.
    Label startProgram
    Print "i is: "; i

Here is part_2.bas, the second (and startup) part of our long program:


    ' "part_2.bas" demo file for INCLUDE keyword - This is the startup file
    ' to run the demo program.
    ' -------------
    ' Include keyword allows us to merge another SmallBASIC source file into 
    ' our file, which means that any code is common to all files.
    ' It's useful when the program is too long and we simply want to divide it
    ' into "pages", instead of one single long "page".
    ' 
    ' See also Home -- Language reference -- Graphics -- COLOR -- color_const.bas
    ' for practical example of Include.
    '
    ' Note: INCLUDE keyword is very different from UNIT keyword. 
    '       UNIT allows us to use only specific code, therefore it is more suitable 
    '       for modular programming.
    '       UNIT also supports "Namespaces": Namespaces allow reuse of same names 
    '       in different contexts. e.g. BitLib.Set(x) and StrLib.Set(x) are both 
    '       using a function with the same name, "Set", but in different contexts.
    ' -------------

    ' Here we include (merge) another file in our program:
    ' Note: actuall filename must be lower case for Linux.
    Include "part_1.bas" 

    ' demo:
    i += 1
    If i <= 10 Then Goto startProgram ' startProgram label is in part_1.bas
    Pause

+========================================================================================+
|                                   302. (System) MAXINT                                 |
+========================================================================================+

MAXINT

Holds the maximum value for an integer. The value depends on whether you
are using a 32 or 64 bit build of SmallBASIC.

+========================================================================================+
|                                    303. (System) NIL                                   |
+========================================================================================+

NIL

NIL is used to mean ‘not set’ as distinct from having an INT set to 0

+========================================================================================+
|                                   304. (System) OPTION                                 |
+========================================================================================+

OPTION keyword

Used to pass parameters to the run-time environment.

+========================================================================================+
|                                   305. (System) PAUSE                                  |
+========================================================================================+

PAUSE [secs]

Pauses the execution for a specified length of time, or until user hit
the keyboard.

PAUSE n - n is optional number of secs, with or without n, PAUSE will
wait for key press or mouse click (or the optional amount of secs)
before executing next statement. BUT! be warned PAUSE may interfere with
INKEY or PEN(3) events if they follow a PAUSE. PAUSE is the perfect
choice for the PRINT “Hello World” classic first program. Now days, that
screen wont stay up long enough to see without something like PAUSE to
halt program execution (for the user to see the output screen).


    'ribbons.bas SmallBASIC 0.12.2 [B+=MGA] 2016-03-24
    'new and improved update of SB and Bpf posts 2015-04-16 B+
    at 80,610:? "Wait 8 secs or press any for next screen..."
    const a=127
    while 1 
      for i=0 to 9
        b=rnd^2:c=rnd^2:d=rnd^2
        for x=1 to 600
          cl=RGB(a+a*sin(b*x),a+a*sin(c*x),a+a*sin(d*x))
          line x,i*60+1 step 0,60,cl
        next x
      next i
      pause 8 '<=========== pause waits 8 secs or key press
    wend

+========================================================================================+
|                                     306. (System) PI                                   |
+========================================================================================+

PI

Holds PI

See: https://en.wikipedia.org/wiki/Pi

+========================================================================================+
|                                  307. (System) PROGLINE                                |
+========================================================================================+

PROGLINE

Returns the current program line number.

+========================================================================================+
|                                 308. (System) RANDOMIZE                                |
+========================================================================================+

RANDOMIZE [int]

Seeds the random number generator.

+========================================================================================+
|                                    309. (System) RUN                                   |
+========================================================================================+

RUN cmdstr

Loads a secondary copy of system’s shell and, executes an program, or an
shell command.

    ' Note: RUN is different then CHAIN. RUN executes external system command,
    '       while CHAIN executes SmallBASIC code (similar to EVAL function).
    Const IS_LINUX = (Left(HOME, 1) = "/")  ' Check if it's Linux system
    Const IS_WINDOWS = Not IS_LINUX
    Const DEMOFILE = Enclose("demo.tmp")

    ' Print header before each RUN mission:
    Sub header(text)
      ? Cbs("\\n\\n" + Cat(3) + Enclose(text, " ") + Cat(0) + Chr(7))
      Pause
    End Sub

    ' Run a built-in shell command - as a FUNCTION:
    header "Press Enter to output directory list into string..."
    Select Case 1
      Case IS_LINUX:   lines = Run("ls")   ' "ls" command on Linux
      Case IS_WINDOWS: lines = Run("DIR")  ' "DIR" command on Windows
    End Select
    Split lines, Cbs("\\n"), lines   ' Convert string to array
    For i In lines: ? i,: Next      ' Print array content

    ' Run a built-in shell command - as a COMMAND:
    header "Press Enter to output directory list into file " + DEMOFILE + "..."
    Select Case 1
      Case IS_LINUX:   Run "ls > " + DEMOFILE   ' "ls" command on Linux
      Case IS_WINDOWS: Run "DIR > " + DEMOFILE  ' "DIR" command on Windows
    End Select
    Tload Disclose(DEMOFILE), lines   ' load DEMOFILE into array
    For i In lines: ? i,: Next        ' Print array content

    ' Run another program:
    header "Press Enter to edit " + DEMOFILE + " in external editor..."
    Select Case 1
      Case IS_LINUX:   Run "gedit " + DEMOFILE
      Case IS_WINDOWS: Run "Notepad " + DEMOFILE
    End Select
    ? "OK."
    ' Run another program (which is actually SmallBASIC's IDE):
    header "Press Enter to edit " + DEMOFILE + " in SmallBASIC editor..."
    Select Case 1
      Case IS_LINUX:   Run "sbasicg -e " + DEMOFILE
      Case IS_WINDOWS: Run "sbasicg -e " + DEMOFILE
    End Select
    ? "Done...";
    Pause

RUN/EXEC

There are three modes:

1.  RUN(command) ’ invoked as a COMMAND

2.  v=RUN(command) ‘invoked as a FUNC, returning the results of the sub
    process. With both of these, control returns to the .bas once system
    ’command’ has completed.

3.  EXEC(command) ’invoked as a COMMAND, control returns to the .bas
    immediately and the system command does it’s own thing external to
    SmallBASIC.

Note: In the android version you can use v=RUN to look at interesting
things in the /proc file system.

1.  The search path for running a command (executable file) is defined
    in the “PATH” environment variable (unless full path to the
    executable is supplied). In Windows, the current directory will be
    searched before the directories specified in the PATH variable (but
    not on Linux).

    Const IS_LINUX = (Left(HOME, 1) = "/") ' check if it's Linux system
    ' find current PATH with:
    If IS_LINUX Then
      RUN "echo $PATH > path.tmp"
    Else ' Windows (syntax...?)
      RUN "SET PATH > path.tmp"
    Fi
    Tload "path.tmp", lines
    ? lines
    Pause

2.  Command to execute is case sensitive on Linux (not on Windows).

3.  RUN loads a secondary command shell to execute a command. In Linux,
    and maybe on other systems as well, each command shell has unique
    environment-variables-table; which means that you cannot always
    share environment variables with command executed by RUN:

    Const IS_LINUX = (Left(HOME, 1) = "/") ' check if it's Linux system
    ' This can work (verified on Linux):
    ' SB1 variable is set in main shell, and shared with secondary shell:
    ENVIRON "SB1=67890"
    If IS_LINUX Then
      RUN "echo $SB1 > test.tmp"
    Else ' Windows (syntax...?)
      RUN "SET SB1 > test.tmp"
    Fi
    Tload "test.tmp", lines
    ? lines
    Pause
    ' This cannot work (verified on Linux, without using the 'export' keyword):
    ' SB1 variable is set in secondary shell:
    If IS_LINUX Then
      RUN "SB1=12345"
    Else ' Windows (syntax...?)
      RUN "SET SB1=12345"
    Fi
    ' Now back to main shell, so SB1 is 67890 again...:
    ? ENVIRON("SB1")
    Pause

4.  Using RUN with built-in shell commands, such as DIR (to show
    directory list), might be confusing, because the result is not
    always visible. To delete a file you can try:

    RUN "DEL test.tmp"

on Windows.

    RUN "rm test.tmp"

on Linux. Then check if file is deleted from SmallBASIC with

    ? EXIST "test.tmp"

To retrieve directory list it’s better to output the data to a file:

    RUN "DIR > test.tmp"

on Windows.

    RUN "ls > test.tmp"

on Linux.

    TLOAD test.tmp, lines: ? lines

will verify that the command was executed well.

5.  Systems commands, especially on Linux, are very powerful, and can
    add lots of valuable features to a SmallBASIC program. With system
    commands you can configure the COM port, send email (Linux at
    least), get lots of information about the environment, etc, etc. But
    before you can actually use these features - you must learn how your
    system is working, and which commands are available (Read Ebook or a
    book to understand the basics).

+========================================================================================+
|                                   310. (System) SBVER                                  |
+========================================================================================+

SBVER

Version and build information

+========================================================================================+
|                                    311. (System) SELF                                  |
+========================================================================================+

SELF

Pseudo class instance variable

The SELF variable works with MAP variables. You can assign a reference
to a FUNC or SUB to a MAP variable. When you call the SUB or FUNC the
SELF variable provides access to values from the enclosing MAP variable.
This provides pseudo class/object functionality.

Note: ‘MAP’ is the name given to the dictionary/hashmap variable
variant.

Example:

    SUB hello
    print "hello " + self.world
    END
    a.world="world"
    a.foo=@hello
    a.foo()

+========================================================================================+
|                                  312. (System) STKDUMP                                 |
+========================================================================================+

STKDUMP

Display internal execution stack.

+========================================================================================+
|                                   313. (System) TROFF                                  |
+========================================================================================+

TROFF

See TRON.

+========================================================================================+
|                                    314. (System) TRON                                  |
+========================================================================================+

TRON

When trace mechanism is ON, displays each line number as the program is
executed.

+========================================================================================+
|                                    315. (System) UNIT                                  |
+========================================================================================+

UNIT name

Declares the source module as a unit. Units are a set of procedures,
functions and/or variables that can be used by another program or unit.

As of SmallBASIC version 0.12.6:

1.  UNIT supports ‘namespace’ (Namespaces allow reuse of same names in
    different contexts. e.g. BitLib.Set(x) and StrLib.Set(x) are both
    using a function with the same name, “Set”, but in different
    contexts).
2.  UNIT name on Linux system is no longer case sensitive (which makes
    life easier for Linux users).

The UNIT file is strlib.bas:


    ' File: strlib.bas
    ' ------------
    ' In this demo we are using UNIT to add more useful String commands to
    ' SmallBASIC, by carefully creating our own String-Library: strlib.bas
    '
    ' This demo includes only two useful functions, Lset() and Rset(); You
    ' can add more useful functions, subs, constants - but make sure that
    ' they are all String commands (not Array, File, Data, etc).
    '
    ' Write your code carefully and efficiently, because you will use these
    ' commands frequently in other projects. And don't forget to debug the
    ' code and to add clear documentation, for you and for others.
    '
    ' See also Home-->Article-->Welcome to SmallBASIC-->Units.
    ' ------------
    '

    ' Here we declare that this file is a UNIT file.
    ' Note: Keep file-name and unit-name the same. That helps the SB to
    '       automatically recompile the required units when it is needed (i.e.
    '       to create strlib.sbu file).
    '       The actual file name must be in lower case for Linux OS.
    Unit strlib ' (without .bas extension)
    ' Here we allow other SmallBASIC files to use some of our library keywords:
    Export Lset, Rset

    ' Left justify string s in buffer of length b.
    ' example: x = Lset(" SmallBASIC ", 15) ' --> x is " SmallBASIC    "
    Func Lset(s, b)
      Local l = Len(s)

      If l >= b Then
        Lset = Left(s, b)
      Else
        Lset = s + Space(b - l)
      Fi
    End
    ' Right justify string s in buffer of length b.
    ' example: x = Rset(" SmallBASIC ", 15) ' --> x is "    SmallBASIC "
    Func Rset(s, b)
      Local l = Len(s)

      If l >= b Then
        Rset = Right(s, b)
      Else
        Rset = Space(b - l) + s
      Fi
    End

Demo file, demo.bas, which is using strlib.bas above:

    ' Here we declare that this file is using another UNIT file.
    ' Note: The actual file name must be in lower case for Linux OS.
    Import strlib ' (without .bas extension)
    ' Note: To access a member of a UNIT we must use the unit-name, a point
    '       and the name of the member, e.g. Strlib.Lset("Hello", 10).
    ' demo:
    Color 14, 1
    Locate 4, 30
    Print Strlib.Lset("  -->>", 25)
    Locate 5, 30
    Print Strlib.Lset(Strlib.Rset("This way...", 18), 25)
    Locate 6, 30
    Print Strlib.Rset("-->>  ", 25)
    Pause

1.  While UNIT can be used as a collection of sub-routines for your own
    program, UNIT is particularly useful for creating a general-purpose
    library. General purpose library can be useful for many programs or
    projects, the same way the internal routine “PRINT” is useful for
    many programs, and not only for specific one.

2.  It is very important to keep the syntax of EXPORTed routines fixed.
    For example: Imagine that the internal routine “PRINT” will use a
    new syntax in future version of SmallBASIC, something like:

    PRINT [fileN,] x, y, color, "string"  ' the "new" syntax

In this case many older programs will not work with the new version of
SmallBASIC.

The same way, when you create a UNIT to be used as a general-purpose
library, you must keep the syntax of EXPORTed routines fixed, so old
programs will continue to work well with newer versions of your UNIT.

3.  If you modify an existing UNIT, you should assign to it a new
    version number. The easy way to maintain a Software versioning is
    like this:

    “Unit Name”, Version major.minor.revision, Release_Date

    For example:

    REM Unit "StrLib" Version 1.15.11, 20/3/2016

major number:> is increased when there are significant jumps in
functionality such as changing the framework which could cause
incompatibility with interfacing programs. minor number:> is incremented
when only minor features or significant fixes have been added.

revision number:> is incremented when minor bugs are fixed.

By assigning a version number, other users will know what to expect from
the modified version. You should also add a short description of the
changes that you have made.

4.  If your UNIT is quite advanced, and you expect it to work
    differently in future versions, you can use the following method
    which allows Old & New programs to work with your unit correctly:

    Instead of using a fixed syntax for sub routines, such as:

    ZipText(string, method, fileName)

Use a single object parameter which has a default value of 0:

    ZipText(x)

Now, in version 1.0.0 for example, x might have this syntax as an array:

    x is [string, method, fileName] ' Version 1.0.0

And in some future version, x might have another syntax, such as:

    x is [string, method, fileName, format] ' Version 1.1.0

Or…

    x is [string, fileName] ' Version 1.14.5

Etc.

The

    ZipText(x)

routine will verify the number of arguments and/or their type (array,
string, etc) and execute the correct code for this version’s-syntax.

This method is especially useful for maintaining a big project for a
long time, which is going to offer more and more features in the future.
It will allow old programs to work as usual, and new programs to benefit
from the new features.

1.  UNIT should Export only> routines or constants (variables) which
    related to the specific use of that unit. For example, UNIT which
    offers string manipulation routines should only> Export string
    manipulation routines or string constants.

    If UNITs contain routines for many different uses, it is likely that
    two UNITs will have to IMPORT each other - and this is basically
    illogical.

2.  -   UNIT must be documented well, so other users can use it.
    -   UNIT should be efficient, because it should serves many other
        programs.
    -   Routines syntax should be consistent and standard, to be easy to
        use.
    -   UNIT is saved as Byte-Code (SBU), which is fast and does not
        include spaces, comments, etc. So feel free to add enough
        comments and spaces…

There are more about UNITs (shared libraries), but the most important:
When you write a UNIT to be used by others, try to be merciful… i.e.
write clear and documented code, and make it easy for others to use your
UNIT.

